{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACn1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC92DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7jCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AClDA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrIA;AACA;AACA;;;;;;;;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7jBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjTA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxyDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACxRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACx8DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACp0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACrRA;;;;;;;;ACAA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACjIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC9LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC5PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;AEDA;AACA;AACA;AACA","sources":["../webpack://typescript-action/./lib/main.js","../webpack://typescript-action/./lib/requests.js","../webpack://typescript-action/./lib/tool.js","../webpack://typescript-action/./node_modules/@actions/core/lib/command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/core.js","../webpack://typescript-action/./node_modules/@actions/core/lib/file-command.js","../webpack://typescript-action/./node_modules/@actions/core/lib/oidc-utils.js","../webpack://typescript-action/./node_modules/@actions/core/lib/utils.js","../webpack://typescript-action/./node_modules/@actions/http-client/auth.js","../webpack://typescript-action/./node_modules/@actions/http-client/index.js","../webpack://typescript-action/./node_modules/@actions/http-client/proxy.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/index.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/async_search.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/autoscaling.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/bulk.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/cat.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ccr.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/clear_scroll.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/close_point_in_time.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/cluster.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/count.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/create.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/dangling_indices.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/delete.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/delete_by_query_rethrottle.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/delete_script.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/enrich.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/eql.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/exists.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/exists_source.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/explain.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/features.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/field_caps.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/fleet.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/get.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/get_script.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_context.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/get_script_languages.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/get_source.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/graph.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ilm.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/index.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/indices.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/info.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ingest.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/knn_search.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/license.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/logstash.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/mget.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/migration.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ml.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/monitoring.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/msearch.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/msearch_template.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/mtermvectors.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/nodes.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/open_point_in_time.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ping.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/put_script.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/rank_eval.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/reindex.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/reindex_rethrottle.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/render_search_template.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/rollup.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/scripts_painless_execute.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/scroll.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/search.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/search_mvt.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/search_shards.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/search_template.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/searchable_snapshots.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/security.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/shutdown.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/slm.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/snapshot.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/sql.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/ssl.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/tasks.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/terms_enum.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/termvectors.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/text_structure.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/transform.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/update.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/update_by_query_rethrottle.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/watcher.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/api/xpack.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/api/index.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/client.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/helpers.js","../webpack://typescript-action/./node_modules/@elastic/elasticsearch/lib/sniffingTransport.js","../webpack://typescript-action/./node_modules/@elastic/transport/index.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/Diagnostic.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/Serializer.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/Transport.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/connection/BaseConnection.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/connection/HttpConnection.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/connection/UndiciConnection.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/connection/index.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/errors.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/pool/BaseConnectionPool.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/pool/CloudConnectionPool.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/pool/ClusterConnectionPool.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/pool/WeightedConnectionPool.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/pool/index.js","../webpack://typescript-action/./node_modules/@elastic/transport/lib/symbols.js","../webpack://typescript-action/./node_modules/axios/index.js","../webpack://typescript-action/./node_modules/axios/lib/adapters/http.js","../webpack://typescript-action/./node_modules/axios/lib/adapters/xhr.js","../webpack://typescript-action/./node_modules/axios/lib/axios.js","../webpack://typescript-action/./node_modules/axios/lib/cancel/Cancel.js","../webpack://typescript-action/./node_modules/axios/lib/cancel/CancelToken.js","../webpack://typescript-action/./node_modules/axios/lib/cancel/isCancel.js","../webpack://typescript-action/./node_modules/axios/lib/core/Axios.js","../webpack://typescript-action/./node_modules/axios/lib/core/InterceptorManager.js","../webpack://typescript-action/./node_modules/axios/lib/core/buildFullPath.js","../webpack://typescript-action/./node_modules/axios/lib/core/createError.js","../webpack://typescript-action/./node_modules/axios/lib/core/dispatchRequest.js","../webpack://typescript-action/./node_modules/axios/lib/core/enhanceError.js","../webpack://typescript-action/./node_modules/axios/lib/core/mergeConfig.js","../webpack://typescript-action/./node_modules/axios/lib/core/settle.js","../webpack://typescript-action/./node_modules/axios/lib/core/transformData.js","../webpack://typescript-action/./node_modules/axios/lib/defaults.js","../webpack://typescript-action/./node_modules/axios/lib/env/data.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/bind.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/buildURL.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/combineURLs.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/cookies.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/isAbsoluteURL.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/isAxiosError.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/isURLSameOrigin.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/normalizeHeaderName.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/parseHeaders.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/spread.js","../webpack://typescript-action/./node_modules/axios/lib/helpers/validator.js","../webpack://typescript-action/./node_modules/axios/lib/utils.js","../webpack://typescript-action/./node_modules/debug/node_modules/ms/index.js","../webpack://typescript-action/./node_modules/debug/src/browser.js","../webpack://typescript-action/./node_modules/debug/src/common.js","../webpack://typescript-action/./node_modules/debug/src/index.js","../webpack://typescript-action/./node_modules/debug/src/node.js","../webpack://typescript-action/./node_modules/follow-redirects/debug.js","../webpack://typescript-action/./node_modules/follow-redirects/index.js","../webpack://typescript-action/./node_modules/has-flag/index.js","../webpack://typescript-action/./node_modules/hpagent/index.js","../webpack://typescript-action/./node_modules/ms/index.js","../webpack://typescript-action/./node_modules/secure-json-parse/index.js","../webpack://typescript-action/./node_modules/supports-color/index.js","../webpack://typescript-action/./node_modules/tslib/tslib.js","../webpack://typescript-action/./node_modules/tunnel/index.js","../webpack://typescript-action/./node_modules/tunnel/lib/tunnel.js","../webpack://typescript-action/./node_modules/undici/index.js","../webpack://typescript-action/./node_modules/undici/lib/agent.js","../webpack://typescript-action/./node_modules/undici/lib/api/abort-signal.js","../webpack://typescript-action/./node_modules/undici/lib/api/api-connect.js","../webpack://typescript-action/./node_modules/undici/lib/api/api-pipeline.js","../webpack://typescript-action/./node_modules/undici/lib/api/api-request.js","../webpack://typescript-action/./node_modules/undici/lib/api/api-stream.js","../webpack://typescript-action/./node_modules/undici/lib/api/api-upgrade.js","../webpack://typescript-action/./node_modules/undici/lib/api/index.js","../webpack://typescript-action/./node_modules/undici/lib/api/readable.js","../webpack://typescript-action/./node_modules/undici/lib/balanced-pool.js","../webpack://typescript-action/./node_modules/undici/lib/client.js","../webpack://typescript-action/./node_modules/undici/lib/compat/dispatcher-weakref.js","../webpack://typescript-action/./node_modules/undici/lib/core/connect.js","../webpack://typescript-action/./node_modules/undici/lib/core/errors.js","../webpack://typescript-action/./node_modules/undici/lib/core/request.js","../webpack://typescript-action/./node_modules/undici/lib/core/symbols.js","../webpack://typescript-action/./node_modules/undici/lib/core/util.js","../webpack://typescript-action/./node_modules/undici/lib/dispatcher.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/body.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/constants.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/dataURL.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/file.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/formdata.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/headers.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/index.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/request.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/response.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/symbols.js","../webpack://typescript-action/./node_modules/undici/lib/fetch/util.js","../webpack://typescript-action/./node_modules/undici/lib/handler/redirect.js","../webpack://typescript-action/./node_modules/undici/lib/llhttp/constants.js","../webpack://typescript-action/./node_modules/undici/lib/llhttp/llhttp.wasm.js","../webpack://typescript-action/./node_modules/undici/lib/llhttp/llhttp_simd.wasm.js","../webpack://typescript-action/./node_modules/undici/lib/llhttp/utils.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-agent.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-client.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-errors.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-interceptor.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-pool.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-symbols.js","../webpack://typescript-action/./node_modules/undici/lib/mock/mock-utils.js","../webpack://typescript-action/./node_modules/undici/lib/node/fixed-queue.js","../webpack://typescript-action/./node_modules/undici/lib/pool-base.js","../webpack://typescript-action/./node_modules/undici/lib/pool.js","../webpack://typescript-action/./node_modules/undici/lib/proxy-agent.js","../webpack://typescript-action/./node_modules/@vercel/ncc/dist/ncc/@@notfound.js","../webpack://typescript-action/external node-commonjs \"assert\"","../webpack://typescript-action/external node-commonjs \"async_hooks\"","../webpack://typescript-action/external node-commonjs \"buffer\"","../webpack://typescript-action/external node-commonjs \"diagnostics_channel\"","../webpack://typescript-action/external node-commonjs \"events\"","../webpack://typescript-action/external node-commonjs \"fs\"","../webpack://typescript-action/external node-commonjs \"http\"","../webpack://typescript-action/external node-commonjs \"https\"","../webpack://typescript-action/external node-commonjs \"net\"","../webpack://typescript-action/external node-commonjs \"os\"","../webpack://typescript-action/external node-commonjs \"path\"","../webpack://typescript-action/external node-commonjs \"perf_hooks\"","../webpack://typescript-action/external node-commonjs \"querystring\"","../webpack://typescript-action/external node-commonjs \"stream\"","../webpack://typescript-action/external node-commonjs \"stream/web\"","../webpack://typescript-action/external node-commonjs \"tls\"","../webpack://typescript-action/external node-commonjs \"tty\"","../webpack://typescript-action/external node-commonjs \"url\"","../webpack://typescript-action/external node-commonjs \"util\"","../webpack://typescript-action/external node-commonjs \"zlib\"","../webpack://typescript-action/webpack/bootstrap","../webpack://typescript-action/webpack/runtime/compat","../webpack://typescript-action/webpack/before-startup","../webpack://typescript-action/webpack/startup","../webpack://typescript-action/webpack/after-startup"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst core = __importStar(require(\"@actions/core\"));\nconst requests_1 = require(\"./requests\");\nconst tool_1 = require(\"./tool\");\nasync function run() {\n    try {\n        const githubToken = (0, tool_1.loadInput)('githubToken');\n        const githubOrg = (0, tool_1.loadInput)('githubOrg');\n        const githubRepository = (0, tool_1.loadInput)('githubRepository');\n        const githubRunId = (0, tool_1.loadInput)('githubRunId');\n        const elasticApiKeyId = (0, tool_1.loadInput)('elasticApiKeyId');\n        const elasticApiKey = (0, tool_1.loadInput)('elasticApiKey');\n        const elasticHost = (0, tool_1.loadInput)('elasticHost');\n        const elasticIndex = (0, tool_1.loadInput)('elasticIndex');\n        const elasticCloudId = (0, tool_1.loadInput)('elasticCloudId');\n        const elasticCloudUser = (0, tool_1.loadInput)('elasticCloudUser');\n        const elasticCloudPassword = (0, tool_1.loadInput)('elasticCloudPassword');\n        core.info(`Initializing Github Connection Instance`);\n        const githubInstance = (0, requests_1.createAxiosGithubInstance)(githubToken);\n        core.info(`Initializing Elastic Instance`);\n        const elasticInstance = (0, requests_1.createElasticInstance)(elasticHost, elasticApiKeyId, elasticApiKey, elasticCloudId, elasticCloudUser, elasticCloudPassword);\n        const metadataUrl = `/repos/${githubOrg}/${githubRepository}/actions/runs/${githubRunId}`;\n        core.info(`Retrieving metadata from Github Pipeline ${githubRunId}`);\n        const metadata = await (0, requests_1.sendRequestToGithub)(githubInstance, metadataUrl);\n        const jobsUrl = metadata.jobs_url;\n        core.info(`Retrieving jobs list  from Github Pipeline ${githubRunId}`);\n        const jobs = await (0, requests_1.sendRequestToGithub)(githubInstance, jobsUrl);\n        for (const job of jobs.jobs) {\n            core.info(`Parsing Job '${job.name}'`);\n            const achievedJob = {\n                id: job.id,\n                name: job.name,\n                metadata,\n                status: job.status,\n                conclusion: job.conclusion,\n                steps: job.steps,\n                details: job,\n                logs: await (0, requests_1.sendRequestToGithub)(githubInstance, `/repos/${githubOrg}/${githubRepository}/actions/jobs/${job.id}/logs`)\n            };\n            await (0, requests_1.sendMessagesToElastic)(elasticInstance, achievedJob, elasticIndex);\n        }\n    }\n    catch (e) {\n        if (e instanceof Error) {\n            core.setFailed(e.message);\n        }\n    }\n}\nrun();\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createElasticInstance = exports.createAxiosGithubInstance = exports.sendMessagesToElastic = exports.sendRequestToGithub = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nconst axios_1 = __importDefault(require(\"axios\"));\nconst elasticsearch_1 = require(\"@elastic/elasticsearch\");\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nasync function sendRequestToGithub(client, path) {\n    try {\n        const response = await client.get(path);\n        core.debug(response.data);\n        return response.data;\n    }\n    catch (e) {\n        throw new Error(`Cannot send request to Github : ${e}`);\n    }\n}\nexports.sendRequestToGithub = sendRequestToGithub;\nasync function sendMessagesToElastic(client, messages, elasticIndex) {\n    try {\n        core.debug(`Push to elasticIndex`);\n        client.index({ body: messages, index: elasticIndex });\n    }\n    catch (e) {\n        throw new Error(`Cannot send request to Elastic : ${e}`);\n    }\n}\nexports.sendMessagesToElastic = sendMessagesToElastic;\nfunction createAxiosGithubInstance(token) {\n    return axios_1.default.create({\n        baseURL: 'https://api.github.com',\n        timeout: 1000,\n        headers: { Authorization: `token ${token}` }\n    });\n}\nexports.createAxiosGithubInstance = createAxiosGithubInstance;\nfunction createElasticInstance(elasticUrl, elasticApiKeyId, elasticApiKey, elasticCloudId, elasticCloudUser, elasticCloudPassword) {\n    return !elasticCloudId\n        ? new elasticsearch_1.Client({\n            node: elasticUrl,\n            auth: {\n                apiKey: {\n                    id: elasticApiKeyId,\n                    api_key: elasticApiKey\n                }\n            }\n        })\n        : new elasticsearch_1.Client({\n            node: elasticUrl,\n            cloud: { id: elasticCloudId },\n            auth: {\n                username: elasticCloudUser,\n                password: elasticCloudPassword\n            }\n        });\n}\nexports.createElasticInstance = createElasticInstance;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadInput = void 0;\nconst core = __importStar(require(\"@actions/core\"));\nfunction loadInput(inputName) {\n    try {\n        return core.getInput(inputName);\n    }\n    catch (e) {\n        throw new Error(`Cannot retrieve parameters ${inputName}`);\n    }\n}\nexports.loadInput = loadInput;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        const delimiter = '_GitHubActionsFileCommandDelimeter_';\n        const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;\n        file_command_1.issueCommand('ENV', commandValue);\n    }\n    else {\n        command_1.issueCommand('set-env', { name }, convertedVal);\n    }\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    return inputs;\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, value);\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    command_1.issueCommand('save-state', { name }, value);\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issueCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\nfunction issueCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueCommand = issueCommand;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.result.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' +\n                Buffer.from(this.username + ':' + this.password).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] = 'Bearer ' + this.token;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        options.headers['Authorization'] =\n            'Basic ' + Buffer.from('PAT:' + this.token).toString('base64');\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication(response) {\n        return false;\n    }\n    handleAuthentication(httpClient, requestInfo, objs) {\n        return null;\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http = require(\"http\");\nconst https = require(\"https\");\nconst pm = require(\"./proxy\");\nlet tunnel;\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return new Promise(async (resolve, reject) => {\n            let output = Buffer.alloc(0);\n            this.message.on('data', (chunk) => {\n                output = Buffer.concat([output, chunk]);\n            });\n            this.message.on('end', () => {\n                resolve(output.toString());\n            });\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    let parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n    }\n    get(requestUrl, additionalHeaders) {\n        return this.request('GET', requestUrl, null, additionalHeaders || {});\n    }\n    del(requestUrl, additionalHeaders) {\n        return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return this.request('POST', requestUrl, data, additionalHeaders || {});\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return this.request('PUT', requestUrl, data, additionalHeaders || {});\n    }\n    head(requestUrl, additionalHeaders) {\n        return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return this.request(verb, requestUrl, stream, additionalHeaders);\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    async getJson(requestUrl, additionalHeaders = {}) {\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        let res = await this.get(requestUrl, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async postJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.post(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async putJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.put(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    async patchJson(requestUrl, obj, additionalHeaders = {}) {\n        let data = JSON.stringify(obj, null, 2);\n        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n        let res = await this.patch(requestUrl, data, additionalHeaders);\n        return this._processResponse(res, this.requestOptions);\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    async request(verb, requestUrl, data, headers) {\n        if (this._disposed) {\n            throw new Error('Client has already been disposed.');\n        }\n        let parsedUrl = new URL(requestUrl);\n        let info = this._prepareRequest(verb, parsedUrl, headers);\n        // Only perform retries on reads since writes may not be idempotent.\n        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1\n            ? this._maxRetries + 1\n            : 1;\n        let numTries = 0;\n        let response;\n        while (numTries < maxTries) {\n            response = await this.requestRaw(info, data);\n            // Check if it's an authentication challenge\n            if (response &&\n                response.message &&\n                response.message.statusCode === HttpCodes.Unauthorized) {\n                let authenticationHandler;\n                for (let i = 0; i < this.handlers.length; i++) {\n                    if (this.handlers[i].canHandleAuthentication(response)) {\n                        authenticationHandler = this.handlers[i];\n                        break;\n                    }\n                }\n                if (authenticationHandler) {\n                    return authenticationHandler.handleAuthentication(this, info, data);\n                }\n                else {\n                    // We have received an unauthorized response but have no handlers to handle it.\n                    // Let the response return to the caller.\n                    return response;\n                }\n            }\n            let redirectsRemaining = this._maxRedirects;\n            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 &&\n                this._allowRedirects &&\n                redirectsRemaining > 0) {\n                const redirectUrl = response.message.headers['location'];\n                if (!redirectUrl) {\n                    // if there's no location to redirect to, we won't\n                    break;\n                }\n                let parsedRedirectUrl = new URL(redirectUrl);\n                if (parsedUrl.protocol == 'https:' &&\n                    parsedUrl.protocol != parsedRedirectUrl.protocol &&\n                    !this._allowRedirectDowngrade) {\n                    throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                }\n                // we need to finish reading the response before reassigning response\n                // which will leak the open socket.\n                await response.readBody();\n                // strip authorization header if redirected to a different hostname\n                if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                    for (let header in headers) {\n                        // header names are case insensitive\n                        if (header.toLowerCase() === 'authorization') {\n                            delete headers[header];\n                        }\n                    }\n                }\n                // let's make the request with the new redirectUrl\n                info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                response = await this.requestRaw(info, data);\n                redirectsRemaining--;\n            }\n            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {\n                // If not a retry code, return immediately instead of retrying\n                return response;\n            }\n            numTries += 1;\n            if (numTries < maxTries) {\n                await response.readBody();\n                await this._performExponentialBackoff(numTries);\n            }\n        }\n        return response;\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return new Promise((resolve, reject) => {\n            let callbackForResult = function (err, res) {\n                if (err) {\n                    reject(err);\n                }\n                resolve(res);\n            };\n            this.requestRawWithCallback(info, data, callbackForResult);\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        let socket;\n        if (typeof data === 'string') {\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        let handleResult = (err, res) => {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        };\n        let req = info.httpModule.request(info.options, (msg) => {\n            let res = new HttpClientResponse(msg);\n            handleResult(null, res);\n        });\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error('Request timeout: ' + info.options.path), null);\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err, null);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        let parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            this.handlers.forEach(handler => {\n                handler.prepareRequest(info.options);\n            });\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        const lowercaseKeys = obj => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        let proxyUrl = pm.getProxyUrl(parsedUrl);\n        let useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (!!agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (!!this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        if (useProxy) {\n            // If using proxy, need tunnel\n            if (!tunnel) {\n                tunnel = require('tunnel');\n            }\n            const agentOptions = {\n                maxSockets: maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: {\n                    ...((proxyUrl.username || proxyUrl.password) && {\n                        proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                    }),\n                    host: proxyUrl.hostname,\n                    port: proxyUrl.port\n                }\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets: maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n        return new Promise(resolve => setTimeout(() => resolve(), ms));\n    }\n    static dateTimeDeserializer(key, value) {\n        if (typeof value === 'string') {\n            let a = new Date(value);\n            if (!isNaN(a.valueOf())) {\n                return a;\n            }\n        }\n        return value;\n    }\n    async _processResponse(res, options) {\n        return new Promise(async (resolve, reject) => {\n            const statusCode = res.message.statusCode;\n            const response = {\n                statusCode: statusCode,\n                result: null,\n                headers: {}\n            };\n            // not found leads to null obj returned\n            if (statusCode == HttpCodes.NotFound) {\n                resolve(response);\n            }\n            let obj;\n            let contents;\n            // get the result from the body\n            try {\n                contents = await res.readBody();\n                if (contents && contents.length > 0) {\n                    if (options && options.deserializeDates) {\n                        obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);\n                    }\n                    else {\n                        obj = JSON.parse(contents);\n                    }\n                    response.result = obj;\n                }\n                response.headers = res.message.headers;\n            }\n            catch (err) {\n                // Invalid resource (contents not json);  leaving result obj null\n            }\n            // note that 3xx redirects are handled by the http layer.\n            if (statusCode > 299) {\n                let msg;\n                // if exception/error in body, attempt to get better error\n                if (obj && obj.message) {\n                    msg = obj.message;\n                }\n                else if (contents && contents.length > 0) {\n                    // it may be the case that the exception is in the body message as string\n                    msg = contents;\n                }\n                else {\n                    msg = 'Failed request: (' + statusCode + ')';\n                }\n                let err = new HttpClientError(msg, statusCode);\n                err.result = response.result;\n                reject(err);\n            }\n            else {\n                resolve(response);\n            }\n        });\n    }\n}\nexports.HttpClient = HttpClient;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction getProxyUrl(reqUrl) {\n    let usingSsl = reqUrl.protocol === 'https:';\n    let proxyUrl;\n    if (checkBypass(reqUrl)) {\n        return proxyUrl;\n    }\n    let proxyVar;\n    if (usingSsl) {\n        proxyVar = process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n    }\n    else {\n        proxyVar = process.env['http_proxy'] || process.env['HTTP_PROXY'];\n    }\n    if (proxyVar) {\n        proxyUrl = new URL(proxyVar);\n    }\n    return proxyUrl;\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    let noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    let upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (let upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperReqHosts.some(x => x === upperNoProxyItem)) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\n","/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict'\n\nconst {\n  Diagnostic,\n  Transport,\n  WeightedConnectionPool,\n  ClusterConnectionPool,\n  BaseConnectionPool,\n  CloudConnectionPool,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  Serializer,\n  errors,\n  events\n} = require('@elastic/transport')\n\nconst { default: Client } = require('./lib/client')\n\nmodule.exports = {\n  Client,\n  Diagnostic,\n  Transport,\n  WeightedConnectionPool,\n  ClusterConnectionPool,\n  BaseConnectionPool,\n  CloudConnectionPool,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  Serializer,\n  errors,\n  events\n}\n","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AsyncSearch {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_async_search/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async status(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_async_search/status/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async submit(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) {\n                    querystring[key] = params[key];\n                }\n                else {\n                    // @ts-expect-error\n                    body[key] = params[key];\n                }\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_async_search`;\n        }\n        else {\n            method = 'POST';\n            path = '/_async_search';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = AsyncSearch;\n//# sourceMappingURL=async_search.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Autoscaling {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteAutoscalingPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAutoscalingCapacity(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_autoscaling/capacity';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAutoscalingPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putAutoscalingPolicy(params, options) {\n        var _a;\n        const acceptedPath = ['name'];\n        const acceptedBody = ['policy'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_autoscaling/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Autoscaling;\n//# sourceMappingURL=autoscaling.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function BulkApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['operations'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = 'POST';\n        path = `/${encodeURIComponent(params.index.toString())}/_bulk`;\n    }\n    else {\n        method = 'POST';\n        path = '/_bulk';\n    }\n    return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n}\nexports.default = BulkApi;\n//# sourceMappingURL=bulk.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Cat {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async aliases(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_cat/aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/aliases';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async allocation(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_cat/allocation/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/allocation';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async count(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/count/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/count';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async fielddata(params, options) {\n        const acceptedPath = ['fields'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.fields != null) {\n            method = 'GET';\n            path = `/_cat/fielddata/${encodeURIComponent(params.fields.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/fielddata';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async health(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/health';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async help(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async indices(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/indices/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/indices';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async master(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/master';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async mlDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_cat/ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/data_frame/analytics';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async mlDatafeeds(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/datafeeds';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async mlJobs(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/anomaly_detectors';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async mlTrainedModels(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_cat/ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/ml/trained_models';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async nodeattrs(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/nodeattrs';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async nodes(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/nodes';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async pendingTasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/pending_tasks';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async plugins(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/plugins';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async recovery(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/recovery/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/recovery';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async repositories(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/repositories';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async segments(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/segments/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/segments';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async shards(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cat/shards/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/shards';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async snapshots(params, options) {\n        const acceptedPath = ['repository'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.repository != null) {\n            method = 'GET';\n            path = `/_cat/snapshots/${encodeURIComponent(params.repository.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/snapshots';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async tasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cat/tasks';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async templates(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_cat/templates/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/templates';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async threadPool(params, options) {\n        const acceptedPath = ['thread_pool_patterns'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.thread_pool_patterns != null) {\n            method = 'GET';\n            path = `/_cat/thread_pool/${encodeURIComponent(params.thread_pool_patterns.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/thread_pool';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async transforms(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = 'GET';\n            path = `/_cat/transforms/${encodeURIComponent(params.transform_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cat/transforms';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Cat;\n//# sourceMappingURL=cat.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Ccr {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async follow(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['leader_index', 'max_outstanding_read_requests', 'max_outstanding_write_requests', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size', 'read_poll_timeout', 'remote_cluster'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/follow`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async followInfo(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/info`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async followStats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/stats`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async forgetFollower(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['follower_cluster', 'follower_index', 'follower_index_uuid', 'leader_remote_cluster'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/forget_follower`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ccr/auto_follow';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async pauseAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/pause`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async pauseFollow(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/pause_follow`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['remote_cluster', 'follow_index_pattern', 'leader_index_patterns', 'leader_index_exclusion_patterns', 'max_outstanding_read_requests', 'settings', 'max_outstanding_write_requests', 'read_poll_timeout', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async resumeAutoFollowPattern(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ccr/auto_follow/${encodeURIComponent(params.name.toString())}/resume`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async resumeFollow(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['max_outstanding_read_requests', 'max_outstanding_write_requests', 'max_read_request_operation_count', 'max_read_request_size', 'max_retry_delay', 'max_write_buffer_count', 'max_write_buffer_size', 'max_write_request_operation_count', 'max_write_request_size', 'read_poll_timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/resume_follow`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ccr/stats';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async unfollow(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ccr/unfollow`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Ccr;\n//# sourceMappingURL=ccr.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ClearScrollApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['scroll_id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = '/_search/scroll';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ClearScrollApi;\n//# sourceMappingURL=clear_scroll.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ClosePointInTimeApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = '/_pit';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ClosePointInTimeApi;\n//# sourceMappingURL=close_point_in_time.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Cluster {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async allocationExplain(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['current_node', 'index', 'primary', 'shard'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_cluster/allocation/explain';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteVotingConfigExclusions(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_cluster/voting_config_exclusions';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async existsComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_component_template';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cluster/settings';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async health(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/_cluster/health/${encodeURIComponent(params.index.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/health';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async pendingTasks(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_cluster/pending_tasks';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postVotingConfigExclusions(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_cluster/voting_config_exclusions';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putComponentTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['template', 'aliases', 'mappings', 'settings', 'version', '_meta'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_component_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putSettings(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['persistent', 'transient'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_cluster/settings';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async remoteInfo(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_remote/info';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async reroute(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['commands'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_cluster/reroute';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async state(params, options) {\n        const acceptedPath = ['metric', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.metric != null && params.index != null) {\n            method = 'GET';\n            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_cluster/state/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/state';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_cluster/stats/nodes/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_cluster/stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Cluster;\n//# sourceMappingURL=cluster.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function CountApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['query'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_count`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_count';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = CountApi;\n//# sourceMappingURL=count.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function CreateApi(params, options) {\n    var _a;\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['document'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'PUT';\n    const path = `/${encodeURIComponent(params.index.toString())}/_create/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = CreateApi;\n//# sourceMappingURL=create.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass DanglingIndices {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteDanglingIndex(params, options) {\n        const acceptedPath = ['index_uuid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async importDanglingIndex(params, options) {\n        const acceptedPath = ['index_uuid'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_dangling/${encodeURIComponent(params.index_uuid.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async listDanglingIndices(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_dangling';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = DanglingIndices;\n//# sourceMappingURL=dangling_indices.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function DeleteApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = DeleteApi;\n//# sourceMappingURL=delete.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function DeleteByQueryApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['max_docs', 'query', 'slice'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_delete_by_query`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = DeleteByQueryApi;\n//# sourceMappingURL=delete_by_query.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function DeleteByQueryRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_delete_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = DeleteByQueryRethrottleApi;\n//# sourceMappingURL=delete_by_query_rethrottle.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function DeleteScriptApi(params, options) {\n    const acceptedPath = ['id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'DELETE';\n    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = DeleteScriptApi;\n//# sourceMappingURL=delete_script.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Enrich {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deletePolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async executePolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}/_execute`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_enrich/policy';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putPolicy(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['geo_match', 'match'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_enrich/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_enrich/_stats';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Enrich;\n//# sourceMappingURL=enrich.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Eql {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_eql/search/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_eql/search/status/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async search(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['query', 'case_sensitive', 'event_category_field', 'tiebreaker_field', 'timestamp_field', 'fetch_size', 'filter', 'keep_alive', 'keep_on_completion', 'wait_for_completion_timeout', 'size', 'fields', 'result_position', 'runtime_mappings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_eql/search`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Eql;\n//# sourceMappingURL=eql.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ExistsApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ExistsApi;\n//# sourceMappingURL=exists.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ExistsSourceApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ExistsSourceApi;\n//# sourceMappingURL=exists_source.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ExplainApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['query'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_explain/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ExplainApi;\n//# sourceMappingURL=explain.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Features {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async getFeatures(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_features';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async resetFeatures(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_features/_reset';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Features;\n//# sourceMappingURL=features.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function FieldCapsApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['index_filter', 'runtime_mappings'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_field_caps`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_field_caps';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = FieldCapsApi;\n//# sourceMappingURL=field_caps.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Fleet {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async globalCheckpoints(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/global_checkpoints`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async msearch(params, options) {\n        var _a;\n        const acceptedPath = ['index'];\n        const acceptedBody = ['searches'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_msearch`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_fleet/_fleet_msearch';\n        }\n        return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n    }\n    async search(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_fleet/_fleet_search`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Fleet;\n//# sourceMappingURL=fleet.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function GetApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = GetApi;\n//# sourceMappingURL=get.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function GetScriptApi(params, options) {\n    const acceptedPath = ['id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = GetScriptApi;\n//# sourceMappingURL=get_script.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function GetScriptContextApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/_script_context';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = GetScriptContextApi;\n//# sourceMappingURL=get_script_context.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function GetScriptLanguagesApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/_script_language';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = GetScriptLanguagesApi;\n//# sourceMappingURL=get_script_languages.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function GetSourceApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_source/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = GetSourceApi;\n//# sourceMappingURL=get_source.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Graph {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async explore(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['connections', 'controls', 'query', 'vertices'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_graph/explore`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Graph;\n//# sourceMappingURL=graph.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Ilm {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async explainLifecycle(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/explain`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ilm/policy';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ilm/status';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async migrateToDataTiers(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['legacy_template_to_delete', 'node_attribute'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/migrate_to_data_tiers';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async moveToStep(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['current_step', 'next_step'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ilm/move/${encodeURIComponent(params.index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putLifecycle(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['policy'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ilm/policy/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async removePolicy(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/remove`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async retry(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_ilm/retry`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/start';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ilm/stop';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Ilm;\n//# sourceMappingURL=ilm.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function IndexApi(params, options) {\n    var _a;\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['document'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null && params.id != null) {\n        method = 'PUT';\n        path = `/${encodeURIComponent(params.index.toString())}/_doc/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = 'POST';\n        path = `/${encodeURIComponent(params.index.toString())}/_doc`;\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = IndexApi;\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Indices {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async addBlock(params, options) {\n        const acceptedPath = ['index', 'block'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_block/${encodeURIComponent(params.block.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async analyze(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['analyzer', 'attributes', 'char_filter', 'explain', 'field', 'filter', 'normalizer', 'text', 'tokenizer'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_analyze`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_analyze';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCache(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_cache/clear`;\n        }\n        else {\n            method = 'POST';\n            path = '/_cache/clear';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clone(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_clone/${encodeURIComponent(params.target.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async close(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_close`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async create(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aliases', 'mappings', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async createDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async dataStreamsStats(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_data_stream/${encodeURIComponent(params.name.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_data_stream/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async delete(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteAlias(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'DELETE';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async diskUsage(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_disk_usage`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async exists(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async existsAlias(params, options) {\n        const acceptedPath = ['name', 'index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'HEAD';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'HEAD';\n            path = `/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async existsIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async existsTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'HEAD';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async fieldUsageStats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_field_usage_stats`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async flush(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_flush`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_flush';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async forcemerge(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_forcemerge`;\n        }\n        else {\n            method = 'POST';\n            path = '/_forcemerge';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAlias(params, options) {\n        const acceptedPath = ['name', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.name != null) {\n            method = 'GET';\n            path = `/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias`;\n        }\n        else {\n            method = 'GET';\n            path = '/_alias';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_data_stream/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_data_stream';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getFieldMapping(params, options) {\n        const acceptedPath = ['fields', 'index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.fields != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_mapping/field/${encodeURIComponent(params.fields.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = `/_mapping/field/${encodeURIComponent(params.fields.toString())}`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_index_template';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getMapping(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_mapping`;\n        }\n        else {\n            method = 'GET';\n            path = '/_mapping';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getSettings(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings`;\n        }\n        else if (params.name != null) {\n            method = 'GET';\n            path = `/_settings/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_settings';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_template';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async migrateToDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_data_stream/_migrate/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async modifyDataStream(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_data_stream/_modify';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async open(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_open`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async promoteDataStream(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_data_stream/_promote/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putAlias(params, options) {\n        const acceptedPath = ['index', 'name'];\n        const acceptedBody = ['filter', 'index_routing', 'is_write_index', 'routing', 'search_routing'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.name != null) {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_alias/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_aliases/${encodeURIComponent(params.name.toString())}`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['index_patterns', 'composed_of', 'template', 'data_stream', 'priority', 'version', '_meta'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_index_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putMapping(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['date_detection', 'dynamic', 'dynamic_date_formats', 'dynamic_templates', '_field_names', '_meta', 'numeric_detection', 'properties', '_routing', '_source', 'runtime'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_mapping`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putSettings(params, options) {\n        var _a;\n        const acceptedPath = ['index'];\n        const acceptedBody = ['settings'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'PUT';\n            path = `/${encodeURIComponent(params.index.toString())}/_settings`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_settings';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['aliases', 'index_patterns', 'mappings', 'order', 'settings', 'version'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_template/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async recovery(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_recovery`;\n        }\n        else {\n            method = 'GET';\n            path = '/_recovery';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async refresh(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_refresh`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_refresh';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async reloadSearchAnalyzers(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_reload_search_analyzers`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async resolveIndex(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_resolve/index/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async rollover(params, options) {\n        const acceptedPath = ['alias', 'new_index'];\n        const acceptedBody = ['aliases', 'conditions', 'mappings', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.alias != null && params.new_index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.alias.toString())}/_rollover/${encodeURIComponent(params.new_index.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.alias.toString())}/_rollover`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async segments(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_segments`;\n        }\n        else {\n            method = 'GET';\n            path = '/_segments';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async shardStores(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_shard_stores`;\n        }\n        else {\n            method = 'GET';\n            path = '/_shard_stores';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async shrink(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_shrink/${encodeURIComponent(params.target.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async simulateIndexTemplate(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['allow_auto_create', 'index_patterns', 'composed_of', 'template', 'data_stream', 'priority', 'version', '_meta'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_index_template/_simulate_index/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async simulateTemplate(params, options) {\n        var _a;\n        const acceptedPath = ['name'];\n        const acceptedBody = ['template'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'POST';\n            path = `/_index_template/_simulate/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = '/_index_template/_simulate';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async split(params, options) {\n        const acceptedPath = ['index', 'target'];\n        const acceptedBody = ['aliases', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/${encodeURIComponent(params.index.toString())}/_split/${encodeURIComponent(params.target.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['metric', 'index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null && params.metric != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async unfreeze(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_unfreeze`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateAliases(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['actions'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_aliases';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async validateQuery(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['query'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_validate/query`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_validate/query';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Indices;\n//# sourceMappingURL=indices.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function InfoApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'GET';\n    const path = '/';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = InfoApi;\n//# sourceMappingURL=info.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Ingest {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deletePipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async geoIpStats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ingest/geoip/stats';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ingest/pipeline';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async processorGrok(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ingest/processor/grok';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['_meta', 'description', 'on_failure', 'processors', 'version'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async simulate(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['docs', 'pipeline'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ingest/pipeline/${encodeURIComponent(params.id.toString())}/_simulate`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ingest/pipeline/_simulate';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Ingest;\n//# sourceMappingURL=ingest.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function KnnSearchApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['_source', 'docvalue_fields', 'stored_fields', 'fields', 'knn'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_knn_search`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = KnnSearchApi;\n//# sourceMappingURL=knn_search.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass License {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async delete(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_license';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getBasicStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license/basic_status';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTrialStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_license/trial_status';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async post(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['license', 'licenses'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_license';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postStartBasic(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_license/start_basic';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postStartTrial(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_license/start_trial';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = License;\n//# sourceMappingURL=license.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Logstash {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deletePipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getPipeline(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putPipeline(params, options) {\n        var _a;\n        const acceptedPath = ['id'];\n        const acceptedBody = ['pipeline'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_logstash/pipeline/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Logstash;\n//# sourceMappingURL=logstash.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function MgetApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['docs', 'ids'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_mget`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_mget';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = MgetApi;\n//# sourceMappingURL=mget.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Migration {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deprecations(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_migration/deprecations`;\n        }\n        else {\n            method = 'GET';\n            path = '/_migration/deprecations';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getFeatureUpgradeStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_migration/system_features';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postFeatureUpgrade(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_migration/system_features';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Migration;\n//# sourceMappingURL=migration.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Ml {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async closeJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_no_match', 'force', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_close`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteCalendar(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteCalendarEvent(params, options) {\n        const acceptedPath = ['calendar_id', 'event_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events/${encodeURIComponent(params.event_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteCalendarJob(params, options) {\n        const acceptedPath = ['calendar_id', 'job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteExpiredData(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['requests_per_second', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'DELETE';\n            path = `/_ml/_delete_expired_data/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = '/_ml/_delete_expired_data';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteForecast(params, options) {\n        const acceptedPath = ['job_id', 'forecast_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.forecast_id != null) {\n            method = 'DELETE';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast/${encodeURIComponent(params.forecast_id.toString())}`;\n        }\n        else {\n            method = 'DELETE';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteTrainedModel(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteTrainedModelAlias(params, options) {\n        const acceptedPath = ['model_alias', 'model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async estimateModelMemory(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['analysis_config', 'max_bucket_cardinality', 'overall_cardinality'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_estimate_model_memory';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async evaluateDataFrame(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['evaluation', 'index', 'query'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/data_frame/_evaluate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async explainDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['source', 'dest', 'analysis', 'description', 'model_memory_limit', 'max_num_threads', 'analyzed_fields', 'allow_lazy_start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_explain`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/data_frame/analytics/_explain';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async flushJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['advance_time', 'calc_interim', 'end', 'skip_time', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_flush`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async forecast(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['duration', 'expires_in', 'max_model_memory'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_forecast`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getBuckets(params, options) {\n        const acceptedPath = ['job_id', 'timestamp'];\n        const acceptedBody = ['anomaly_score', 'desc', 'end', 'exclude_interim', 'expand', 'page', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.timestamp != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets/${encodeURIComponent(params.timestamp.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/buckets`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getCalendarEvents(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getCalendars(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.calendar_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/calendars';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getCategories(params, options) {\n        const acceptedPath = ['job_id', 'category_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.category_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/${encodeURIComponent(params.category_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/categories/`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/data_frame/analytics';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getDataFrameAnalyticsStats(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/data_frame/analytics/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getDatafeedStats(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/datafeeds/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getDatafeeds(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/datafeeds';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getFilters(params, options) {\n        const acceptedPath = ['filter_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.filter_id != null) {\n            method = 'GET';\n            path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/filters';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getInfluencers(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['page'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/influencers`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getJobStats(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/anomaly_detectors/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getJobs(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null) {\n            method = 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/anomaly_detectors';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getModelSnapshotUpgradeStats(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade/_stats`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getModelSnapshots(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['desc', 'end', 'page', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.job_id != null && params.snapshot_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getOverallBuckets(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_no_match', 'bucket_span', 'end', 'exclude_interim', 'overall_score', 'start', 'top_n'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/overall_buckets`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRecords(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['desc', 'end', 'exclude_interim', 'page', 'record_score', 'sort', 'start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/results/records`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTrainedModels(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/trained_models';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTrainedModelsStats(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.model_id != null) {\n            method = 'GET';\n            path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/_stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_ml/trained_models/_stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async inferTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['docs'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_infer`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async info(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ml/info';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async openJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_open`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postCalendarEvents(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['events'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/events`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async postData(params, options) {\n        var _a;\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['data'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_data`;\n        return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n    }\n    async previewDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['config'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/data_frame/analytics/_preview';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async previewDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['datafeed_config', 'job_config'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.datafeed_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_ml/datafeeds/_preview';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putCalendar(params, options) {\n        const acceptedPath = ['calendar_id'];\n        const acceptedBody = ['job_ids', 'description'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putCalendarJob(params, options) {\n        const acceptedPath = ['calendar_id', 'job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/calendars/${encodeURIComponent(params.calendar_id.toString())}/jobs/${encodeURIComponent(params.job_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['allow_lazy_start', 'analysis', 'analyzed_fields', 'description', 'dest', 'max_num_threads', 'model_memory_limit', 'source', 'headers', 'version'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['aggregations', 'chunking_config', 'delayed_data_check_config', 'frequency', 'indices', 'indexes', 'indices_options', 'job_id', 'max_empty_searches', 'query', 'query_delay', 'runtime_mappings', 'script_fields', 'scroll_size', 'headers'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const acceptedBody = ['description', 'items'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_lazy_open', 'analysis_config', 'analysis_limits', 'background_persist_interval', 'custom_settings', 'daily_model_snapshot_retention_after_days', 'data_description', 'datafeed_config', 'description', 'groups', 'model_plot_config', 'model_snapshot_retention_days', 'renormalization_window_days', 'results_index_name', 'results_retention_days'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTrainedModel(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['compressed_definition', 'definition', 'description', 'inference_config', 'input', 'metadata', 'model_type', 'model_size_bytes', 'tags'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTrainedModelAlias(params, options) {\n        const acceptedPath = ['model_alias', 'model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/model_aliases/${encodeURIComponent(params.model_alias.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTrainedModelDefinitionPart(params, options) {\n        const acceptedPath = ['model_id', 'part'];\n        const acceptedBody = ['definition', 'total_definition_length', 'total_parts'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/definition/${encodeURIComponent(params.part.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTrainedModelVocabulary(params, options) {\n        const acceptedPath = ['model_id'];\n        const acceptedBody = ['vocabulary'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/vocabulary`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async resetJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_reset`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async revertModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['delete_intervening_results'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_revert`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async setUpgradeMode(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/set_upgrade_mode';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async startDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_start`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async startDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['end', 'start', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_start`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async startTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_start`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stopDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_stop`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stopDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['allow_no_match', 'force', 'timeout'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_stop`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stopTrainedModelDeployment(params, options) {\n        const acceptedPath = ['model_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/trained_models/${encodeURIComponent(params.model_id.toString())}/deployment/_stop`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateDataFrameAnalytics(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['description', 'model_memory_limit', 'max_num_threads', 'allow_lazy_start'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/data_frame/analytics/${encodeURIComponent(params.id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateDatafeed(params, options) {\n        const acceptedPath = ['datafeed_id'];\n        const acceptedBody = ['aggregations', 'chunking_config', 'delayed_data_check_config', 'frequency', 'indices', 'indexes', 'indices_options', 'max_empty_searches', 'query', 'query_delay', 'runtime_mappings', 'script_fields', 'scroll_size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/datafeeds/${encodeURIComponent(params.datafeed_id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateFilter(params, options) {\n        const acceptedPath = ['filter_id'];\n        const acceptedBody = ['add_items', 'description', 'remove_items'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/filters/${encodeURIComponent(params.filter_id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateJob(params, options) {\n        const acceptedPath = ['job_id'];\n        const acceptedBody = ['allow_lazy_open', 'analysis_limits', 'background_persist_interval', 'custom_settings', 'categorization_filters', 'description', 'model_plot_config', 'daily_model_snapshot_retention_after_days', 'model_snapshot_retention_days', 'renormalization_window_days', 'results_retention_days', 'groups', 'detectors', 'per_partition_categorization'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateModelSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const acceptedBody = ['description', 'retain'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async upgradeJobSnapshot(params, options) {\n        const acceptedPath = ['job_id', 'snapshot_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_ml/anomaly_detectors/${encodeURIComponent(params.job_id.toString())}/model_snapshots/${encodeURIComponent(params.snapshot_id.toString())}/_upgrade`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async validate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['job_id', 'analysis_config', 'analysis_limits', 'data_description', 'description', 'model_plot', 'model_snapshot_id', 'model_snapshot_retention_days', 'results_index_name'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_validate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async validateDetector(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['detector'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_ml/anomaly_detectors/_validate/detector';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Ml;\n//# sourceMappingURL=ml.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Monitoring {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async bulk(params, options) {\n        var _a;\n        const acceptedPath = ['type'];\n        const acceptedBody = ['operations'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_monitoring/bulk';\n        return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n    }\n}\nexports.default = Monitoring;\n//# sourceMappingURL=monitoring.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function MsearchApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['searches'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_msearch`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_msearch';\n    }\n    return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n}\nexports.default = MsearchApi;\n//# sourceMappingURL=msearch.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function MsearchTemplateApi(params, options) {\n    var _a;\n    const acceptedPath = ['index'];\n    const acceptedBody = ['search_templates'];\n    const querystring = {};\n    // @ts-expect-error\n    let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            // @ts-expect-error\n            body = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_msearch/template`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_msearch/template';\n    }\n    return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n}\nexports.default = MsearchTemplateApi;\n//# sourceMappingURL=msearch_template.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function MtermvectorsApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['docs', 'ids'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_mtermvectors`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_mtermvectors';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = MtermvectorsApi;\n//# sourceMappingURL=mtermvectors.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Nodes {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async clearRepositoriesMeteringArchive(params, options) {\n        const acceptedPath = ['node_id', 'max_archive_version'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering/${encodeURIComponent(params.max_archive_version.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRepositoriesMeteringInfo(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/_repositories_metering`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async hotThreads(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/hot_threads`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/hot_threads';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async info(params, options) {\n        const acceptedPath = ['node_id', 'metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async reloadSecureSettings(params, options) {\n        const acceptedPath = ['node_id'];\n        const acceptedBody = ['secure_settings_password'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'POST';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/reload_secure_settings`;\n        }\n        else {\n            method = 'POST';\n            path = '/_nodes/reload_secure_settings';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['node_id', 'metric', 'index_metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null && params.index_metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;\n        }\n        else if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.metric != null && params.index_metric != null) {\n            method = 'GET';\n            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}/${encodeURIComponent(params.index_metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/stats`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async usage(params, options) {\n        const acceptedPath = ['node_id', 'metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null && params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/usage`;\n        }\n        else if (params.metric != null) {\n            method = 'GET';\n            path = `/_nodes/usage/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/usage';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Nodes;\n//# sourceMappingURL=nodes.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function OpenPointInTimeApi(params, options) {\n    const acceptedPath = ['index'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_pit`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = OpenPointInTimeApi;\n//# sourceMappingURL=open_point_in_time.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function PingApi(params, options) {\n    const acceptedPath = [];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'HEAD';\n    const path = '/';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = PingApi;\n//# sourceMappingURL=ping.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function PutScriptApi(params, options) {\n    const acceptedPath = ['id', 'context'];\n    const acceptedBody = ['script'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.id != null && params.context != null) {\n        method = 'PUT';\n        path = `/_scripts/${encodeURIComponent(params.id.toString())}/${encodeURIComponent(params.context.toString())}`;\n    }\n    else {\n        method = 'PUT';\n        path = `/_scripts/${encodeURIComponent(params.id.toString())}`;\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = PutScriptApi;\n//# sourceMappingURL=put_script.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function RankEvalApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['requests', 'metric'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_rank_eval`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_rank_eval';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = RankEvalApi;\n//# sourceMappingURL=rank_eval.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ReindexApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['conflicts', 'dest', 'max_docs', 'script', 'size', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = '/_reindex';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ReindexApi;\n//# sourceMappingURL=reindex.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ReindexRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_reindex/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ReindexRethrottleApi;\n//# sourceMappingURL=reindex_rethrottle.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function RenderSearchTemplateApi(params, options) {\n    const acceptedPath = ['id'];\n    const acceptedBody = ['file', 'params', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.id != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/_render/template/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_render/template';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = RenderSearchTemplateApi;\n//# sourceMappingURL=render_search_template.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Rollup {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getJobs(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_rollup/job/';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRollupCaps(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'GET';\n            path = `/_rollup/data/${encodeURIComponent(params.id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_rollup/data/';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRollupIndexCaps(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_rollup/data`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putJob(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['cron', 'groups', 'index_pattern', 'metrics', 'page_size', 'rollup_index', 'timeout', 'headers'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async rollup(params, options) {\n        var _a;\n        const acceptedPath = ['index', 'rollup_index'];\n        const acceptedBody = ['config'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/${encodeURIComponent(params.index.toString())}/_rollup/${encodeURIComponent(params.rollup_index.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async rollupSearch(params, options) {\n        const acceptedPath = ['index'];\n        const acceptedBody = ['aggregations', 'aggs', 'query', 'size'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = `/${encodeURIComponent(params.index.toString())}/_rollup_search`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async startJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_start`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stopJob(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_rollup/job/${encodeURIComponent(params.id.toString())}/_stop`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Rollup;\n//# sourceMappingURL=rollup.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ScriptsPainlessExecuteApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['context', 'context_setup', 'script'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = '/_scripts/painless/_execute';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ScriptsPainlessExecuteApi;\n//# sourceMappingURL=scripts_painless_execute.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function ScrollApi(params, options) {\n    const acceptedPath = [];\n    const acceptedBody = ['scroll', 'scroll_id'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = '/_search/scroll';\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = ScrollApi;\n//# sourceMappingURL=scroll.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function SearchApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['aggregations', 'aggs', 'collapse', 'explain', 'from', 'highlight', 'track_total_hits', 'indices_boost', 'docvalue_fields', 'min_score', 'post_filter', 'profile', 'query', 'rescore', 'script_fields', 'search_after', 'size', 'slice', 'sort', '_source', 'fields', 'suggest', 'terminate_after', 'timeout', 'track_scores', 'version', 'seq_no_primary_term', 'stored_fields', 'pit', 'runtime_mappings', 'stats'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            if (key === 'sort' && typeof params[key] === 'string' && params[key].includes(':')) {\n                querystring[key] = params[key];\n            }\n            else {\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = SearchApi;\n//# sourceMappingURL=search.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function SearchMvtApi(params, options) {\n    const acceptedPath = ['index', 'field', 'zoom', 'x', 'y'];\n    const acceptedBody = ['aggs', 'exact_bounds', 'extent', 'fields', 'grid_precision', 'grid_type', 'query', 'runtime_mappings', 'size', 'sort', 'track_total_hits'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_mvt/${encodeURIComponent(params.field.toString())}/${encodeURIComponent(params.zoom.toString())}/${encodeURIComponent(params.x.toString())}/${encodeURIComponent(params.y.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = SearchMvtApi;\n//# sourceMappingURL=search_mvt.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function SearchShardsApi(params, options) {\n    const acceptedPath = ['index'];\n    const querystring = {};\n    const body = undefined;\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search_shards`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search_shards';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = SearchShardsApi;\n//# sourceMappingURL=search_shards.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function SearchTemplateApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['explain', 'id', 'params', 'profile', 'source'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    params = params !== null && params !== void 0 ? params : {};\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_search/template`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = '/_search/template';\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = SearchTemplateApi;\n//# sourceMappingURL=search_template.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass SearchableSnapshots {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cacheStats(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_searchable_snapshots/${encodeURIComponent(params.node_id.toString())}/cache/stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_searchable_snapshots/cache/stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCache(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'POST';\n            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/cache/clear`;\n        }\n        else {\n            method = 'POST';\n            path = '/_searchable_snapshots/cache/clear';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async mount(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['index', 'renamed_index', 'index_settings', 'ignore_index_settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_mount`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['index'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.index != null) {\n            method = 'GET';\n            path = `/${encodeURIComponent(params.index.toString())}/_searchable_snapshots/stats`;\n        }\n        else {\n            method = 'GET';\n            path = '/_searchable_snapshots/stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = SearchableSnapshots;\n//# sourceMappingURL=searchable_snapshots.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Security {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async authenticate(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/_authenticate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async changePassword(params, options) {\n        const acceptedPath = ['username'];\n        const acceptedBody = ['password', 'password_hash'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.username != null) {\n            method = 'PUT';\n            path = `/_security/user/${encodeURIComponent(params.username.toString())}/_password`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_security/user/_password';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearApiKeyCache(params, options) {\n        const acceptedPath = ['ids'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/api_key/${encodeURIComponent(params.ids.toString())}/_clear_cache`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCachedPrivileges(params, options) {\n        const acceptedPath = ['application'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/_clear_cache`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCachedRealms(params, options) {\n        const acceptedPath = ['realms'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/realm/${encodeURIComponent(params.realms.toString())}/_clear_cache`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCachedRoles(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}/_clear_cache`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clearCachedServiceTokens(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}/_clear_cache`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async createApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['expiration', 'name', 'role_descriptors', 'metadata'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_security/api_key';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async createServiceToken(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.namespace != null && params.service != null && params.name != null) {\n            method = 'PUT';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'POST';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deletePrivileges(params, options) {\n        const acceptedPath = ['application', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteRole(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteServiceToken(params, options) {\n        const acceptedPath = ['namespace', 'service', 'name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential/token/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async disableUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_disable`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async enableUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}/_enable`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async enrollKibana(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/enroll/kibana';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async enrollNode(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/enroll/node';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getApiKey(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/api_key';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getBuiltinPrivileges(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/privilege/_builtin';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getPrivileges(params, options) {\n        const acceptedPath = ['application', 'name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.application != null && params.name != null) {\n            method = 'GET';\n            path = `/_security/privilege/${encodeURIComponent(params.application.toString())}/${encodeURIComponent(params.name.toString())}`;\n        }\n        else if (params.application != null) {\n            method = 'GET';\n            path = `/_security/privilege/${encodeURIComponent(params.application.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/privilege';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRole(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/role';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/role_mapping';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getServiceAccounts(params, options) {\n        const acceptedPath = ['namespace', 'service'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.namespace != null && params.service != null) {\n            method = 'GET';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}`;\n        }\n        else if (params.namespace != null) {\n            method = 'GET';\n            path = `/_security/service/${encodeURIComponent(params.namespace.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/service';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getServiceCredentials(params, options) {\n        const acceptedPath = ['namespace', 'service'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_security/service/${encodeURIComponent(params.namespace.toString())}/${encodeURIComponent(params.service.toString())}/credential`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getToken(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['grant_type', 'scope', 'password', 'kerberos_ticket', 'refresh_token', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/oauth2/token';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getUser(params, options) {\n        const acceptedPath = ['username'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.username != null) {\n            method = 'GET';\n            path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_security/user';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getUserPrivileges(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_security/user/_privileges';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async grantApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['api_key', 'grant_type', 'access_token', 'username', 'password'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/api_key/grant';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async hasPrivileges(params, options) {\n        const acceptedPath = ['user'];\n        const acceptedBody = ['application', 'cluster', 'index'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.user != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_security/user/${encodeURIComponent(params.user.toString())}/_has_privileges`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_security/user/_has_privileges';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async invalidateApiKey(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['id', 'ids', 'name', 'owner', 'realm_name', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_security/api_key';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async invalidateToken(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['token', 'refresh_token', 'realm_name', 'username'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = '/_security/oauth2/token';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putPrivileges(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['privileges'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = '/_security/privilege/';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putRole(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['applications', 'cluster', 'global', 'indices', 'metadata', 'run_as', 'transient_metadata'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/role/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putRoleMapping(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['enabled', 'metadata', 'roles', 'rules', 'run_as'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/role_mapping/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putUser(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['username', 'email', 'full_name', 'metadata', 'password', 'password_hash', 'roles', 'enabled'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_security/user/${encodeURIComponent(params.username.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async queryApiKeys(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['query', 'from', 'sort', 'size', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_security/_query/api_key';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlAuthenticate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['content', 'ids', 'realm'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/authenticate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlCompleteLogout(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['realm', 'ids', 'query_string', 'content'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/complete_logout';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlInvalidate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['acs', 'query_string', 'realm'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/invalidate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlLogout(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['token', 'refresh_token'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/logout';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlPrepareAuthentication(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['acs', 'realm', 'relay_state'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_security/saml/prepare';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async samlServiceProviderMetadata(params, options) {\n        const acceptedPath = ['realm_name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_security/saml/metadata/${encodeURIComponent(params.realm_name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Security;\n//# sourceMappingURL=security.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Shutdown {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.node_id != null) {\n            method = 'GET';\n            path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        }\n        else {\n            method = 'GET';\n            path = '/_nodes/shutdown';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putNode(params, options) {\n        const acceptedPath = ['node_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_nodes/${encodeURIComponent(params.node_id.toString())}/shutdown`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Shutdown;\n//# sourceMappingURL=shutdown.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Slm {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async executeLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}/_execute`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async executeRetention(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/_execute_retention';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.policy_id != null) {\n            method = 'GET';\n            path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_slm/policy';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getStats(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_slm/stats';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getStatus(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_slm/status';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putLifecycle(params, options) {\n        const acceptedPath = ['policy_id'];\n        const acceptedBody = ['config', 'name', 'repository', 'retention', 'schedule'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_slm/policy/${encodeURIComponent(params.policy_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/start';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_slm/stop';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Slm;\n//# sourceMappingURL=slm.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Snapshot {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cleanupRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_cleanup`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async clone(params, options) {\n        const acceptedPath = ['repository', 'snapshot', 'target_snapshot'];\n        const acceptedBody = ['indices'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_clone/${encodeURIComponent(params.target_snapshot.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async create(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['ignore_unavailable', 'include_global_state', 'indices', 'feature_states', 'metadata', 'partial'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async createRepository(params, options) {\n        const acceptedPath = ['name'];\n        const acceptedBody = ['repository', 'type', 'settings'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async delete(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.name != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.name.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_snapshot';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async repositoryAnalyze(params, options) {\n        const acceptedPath = ['repository'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_analyze`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async restore(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const acceptedBody = ['ignore_index_settings', 'ignore_unavailable', 'include_aliases', 'include_global_state', 'index_settings', 'indices', 'partial', 'rename_pattern', 'rename_replacement'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_restore`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async status(params, options) {\n        const acceptedPath = ['repository', 'snapshot'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.repository != null && params.snapshot != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/${encodeURIComponent(params.snapshot.toString())}/_status`;\n        }\n        else if (params.repository != null) {\n            method = 'GET';\n            path = `/_snapshot/${encodeURIComponent(params.repository.toString())}/_status`;\n        }\n        else {\n            method = 'GET';\n            path = '/_snapshot/_status';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async verifyRepository(params, options) {\n        const acceptedPath = ['name'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_snapshot/${encodeURIComponent(params.name.toString())}/_verify`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Snapshot;\n//# sourceMappingURL=snapshot.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Sql {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async clearCursor(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['cursor'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_sql/close';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteAsync(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_sql/async/delete/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAsync(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_sql/async/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getAsyncStatus(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_sql/async/status/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async query(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['catalog', 'columnar', 'cursor', 'fetch_size', 'filter', 'query', 'request_timeout', 'page_timeout', 'time_zone', 'field_multi_value_leniency', 'runtime_mappings', 'wait_for_completion_timeout', 'params', 'keep_alive', 'keep_on_completion', 'index_using_frozen'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_sql';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async translate(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['fetch_size', 'filter', 'query', 'time_zone'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_sql/translate';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Sql;\n//# sourceMappingURL=sql.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Ssl {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async certificates(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_ssl/certificates';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Ssl;\n//# sourceMappingURL=ssl.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Tasks {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async cancel(params, options) {\n        const acceptedPath = ['task_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.task_id != null) {\n            method = 'POST';\n            path = `/_tasks/${encodeURIComponent(params.task_id.toString())}/_cancel`;\n        }\n        else {\n            method = 'POST';\n            path = '/_tasks/_cancel';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async get(params, options) {\n        const acceptedPath = ['task_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_tasks/${encodeURIComponent(params.task_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async list(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_tasks';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Tasks;\n//# sourceMappingURL=tasks.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function TermsEnumApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['field', 'size', 'timeout', 'case_insensitive', 'index_filter', 'string', 'search_after'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = body != null ? 'POST' : 'GET';\n    const path = `/${encodeURIComponent(params.index.toString())}/_terms_enum`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = TermsEnumApi;\n//# sourceMappingURL=terms_enum.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function TermvectorsApi(params, options) {\n    const acceptedPath = ['index', 'id'];\n    const acceptedBody = ['doc', 'filter', 'per_field_analyzer'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    let method = '';\n    let path = '';\n    if (params.index != null && params.id != null) {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_termvectors/${encodeURIComponent(params.id.toString())}`;\n    }\n    else {\n        method = body != null ? 'POST' : 'GET';\n        path = `/${encodeURIComponent(params.index.toString())}/_termvectors`;\n    }\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = TermvectorsApi;\n//# sourceMappingURL=termvectors.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass TextStructure {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async findStructure(params, options) {\n        var _a;\n        const acceptedPath = [];\n        const acceptedBody = ['text_files'];\n        const querystring = {};\n        // @ts-expect-error\n        let body = (_a = params.body) !== null && _a !== void 0 ? _a : undefined;\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                // @ts-expect-error\n                body = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_text_structure/find_structure';\n        return await this.transport.request({ path, method, querystring, bulkBody: body }, options);\n    }\n}\nexports.default = TextStructure;\n//# sourceMappingURL=text_structure.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Transform {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async deleteTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = 'GET';\n            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_transform';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getTransformStats(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stats`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async previewTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', 'pivot', 'source', 'settings', 'sync', 'retention_policy', 'latest'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.transform_id != null) {\n            method = body != null ? 'POST' : 'GET';\n            path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_preview`;\n        }\n        else {\n            method = body != null ? 'POST' : 'GET';\n            path = '/_transform/_preview';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', 'latest', '_meta', 'pivot', 'retention_policy', 'settings', 'source', 'sync'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async startTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_start`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stopTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_stop`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async updateTransform(params, options) {\n        const acceptedPath = ['transform_id'];\n        const acceptedBody = ['dest', 'description', 'frequency', '_meta', 'source', 'settings', 'sync', 'retention_policy'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = `/_transform/${encodeURIComponent(params.transform_id.toString())}/_update`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async upgradeTransforms(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_transform/_upgrade';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Transform;\n//# sourceMappingURL=transform.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function UpdateApi(params, options) {\n    const acceptedPath = ['id', 'index'];\n    const acceptedBody = ['detect_noop', 'doc', 'doc_as_upsert', 'script', 'scripted_upsert', '_source', 'upsert'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_update/${encodeURIComponent(params.id.toString())}`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = UpdateApi;\n//# sourceMappingURL=update.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function UpdateByQueryApi(params, options) {\n    const acceptedPath = ['index'];\n    const acceptedBody = ['max_docs', 'query', 'script', 'slice', 'conflicts'];\n    const querystring = {};\n    // @ts-expect-error\n    const userBody = params === null || params === void 0 ? void 0 : params.body;\n    let body;\n    if (typeof userBody === 'string') {\n        body = userBody;\n    }\n    else {\n        body = userBody != null ? { ...userBody } : undefined;\n    }\n    for (const key in params) {\n        if (acceptedBody.includes(key)) {\n            body = body !== null && body !== void 0 ? body : {};\n            // @ts-expect-error\n            body[key] = params[key];\n        }\n        else if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/${encodeURIComponent(params.index.toString())}/_update_by_query`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = UpdateByQueryApi;\n//# sourceMappingURL=update_by_query.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nasync function UpdateByQueryRethrottleApi(params, options) {\n    const acceptedPath = ['task_id'];\n    const querystring = {};\n    const body = undefined;\n    for (const key in params) {\n        if (acceptedPath.includes(key)) {\n            continue;\n        }\n        else if (key !== 'body') {\n            // @ts-expect-error\n            querystring[key] = params[key];\n        }\n    }\n    const method = 'POST';\n    const path = `/_update_by_query/${encodeURIComponent(params.task_id.toString())}/_rethrottle`;\n    return await this.transport.request({ path, method, querystring, body }, options);\n}\nexports.default = UpdateByQueryRethrottleApi;\n//# sourceMappingURL=update_by_query_rethrottle.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Watcher {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async ackWatch(params, options) {\n        const acceptedPath = ['watch_id', 'action_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.watch_id != null && params.action_id != null) {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack/${encodeURIComponent(params.action_id.toString())}`;\n        }\n        else {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_ack`;\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async activateWatch(params, options) {\n        const acceptedPath = ['watch_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_activate`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deactivateWatch(params, options) {\n        const acceptedPath = ['watch_id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.watch_id.toString())}/_deactivate`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async deleteWatch(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'DELETE';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async executeWatch(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['action_modes', 'alternative_input', 'ignore_condition', 'record_execution', 'simulated_actions', 'trigger_data', 'watch'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.id != null) {\n            method = 'PUT';\n            path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}/_execute`;\n        }\n        else {\n            method = 'PUT';\n            path = '/_watcher/watch/_execute';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async getWatch(params, options) {\n        const acceptedPath = ['id'];\n        const querystring = {};\n        const body = undefined;\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async putWatch(params, options) {\n        const acceptedPath = ['id'];\n        const acceptedBody = ['actions', 'condition', 'input', 'metadata', 'throttle_period', 'transform', 'trigger'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'PUT';\n        const path = `/_watcher/watch/${encodeURIComponent(params.id.toString())}`;\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async queryWatches(params, options) {\n        const acceptedPath = [];\n        const acceptedBody = ['from', 'size', 'query', 'sort', 'search_after'];\n        const querystring = {};\n        // @ts-expect-error\n        const userBody = params === null || params === void 0 ? void 0 : params.body;\n        let body;\n        if (typeof userBody === 'string') {\n            body = userBody;\n        }\n        else {\n            body = userBody != null ? { ...userBody } : undefined;\n        }\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedBody.includes(key)) {\n                body = body !== null && body !== void 0 ? body : {};\n                // @ts-expect-error\n                body[key] = params[key];\n            }\n            else if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = body != null ? 'POST' : 'GET';\n        const path = '/_watcher/_query/watches';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async start(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_watcher/_start';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stats(params, options) {\n        const acceptedPath = ['metric'];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        let method = '';\n        let path = '';\n        if (params.metric != null) {\n            method = 'GET';\n            path = `/_watcher/stats/${encodeURIComponent(params.metric.toString())}`;\n        }\n        else {\n            method = 'GET';\n            path = '/_watcher/stats';\n        }\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async stop(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'POST';\n        const path = '/_watcher/_stop';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Watcher;\n//# sourceMappingURL=watcher.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass Xpack {\n    constructor(transport) {\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.transport = transport;\n    }\n    async info(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_xpack';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n    async usage(params, options) {\n        const acceptedPath = [];\n        const querystring = {};\n        const body = undefined;\n        params = params !== null && params !== void 0 ? params : {};\n        for (const key in params) {\n            if (acceptedPath.includes(key)) {\n                continue;\n            }\n            else if (key !== 'body') {\n                // @ts-expect-error\n                querystring[key] = params[key];\n            }\n        }\n        const method = 'GET';\n        const path = '/_xpack/usage';\n        return await this.transport.request({ path, method, querystring, body }, options);\n    }\n}\nexports.default = Xpack;\n//# sourceMappingURL=xpack.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7, _8;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\n/* eslint-disable import/export */\n/* eslint-disable @typescript-eslint/no-misused-new */\n/* eslint-disable @typescript-eslint/no-extraneous-class */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n// This file was automatically generated by elastic/elastic-client-generator-js\n// DO NOT MODIFY IT BY HAND. Instead, modify the source open api file,\n// and elastic/elastic-client-generator-js to regenerate this file again.\nconst async_search_1 = (0, tslib_1.__importDefault)(require(\"./api/async_search\"));\nconst autoscaling_1 = (0, tslib_1.__importDefault)(require(\"./api/autoscaling\"));\nconst bulk_1 = (0, tslib_1.__importDefault)(require(\"./api/bulk\"));\nconst cat_1 = (0, tslib_1.__importDefault)(require(\"./api/cat\"));\nconst ccr_1 = (0, tslib_1.__importDefault)(require(\"./api/ccr\"));\nconst clear_scroll_1 = (0, tslib_1.__importDefault)(require(\"./api/clear_scroll\"));\nconst close_point_in_time_1 = (0, tslib_1.__importDefault)(require(\"./api/close_point_in_time\"));\nconst cluster_1 = (0, tslib_1.__importDefault)(require(\"./api/cluster\"));\nconst count_1 = (0, tslib_1.__importDefault)(require(\"./api/count\"));\nconst create_1 = (0, tslib_1.__importDefault)(require(\"./api/create\"));\nconst dangling_indices_1 = (0, tslib_1.__importDefault)(require(\"./api/dangling_indices\"));\nconst delete_1 = (0, tslib_1.__importDefault)(require(\"./api/delete\"));\nconst delete_by_query_1 = (0, tslib_1.__importDefault)(require(\"./api/delete_by_query\"));\nconst delete_by_query_rethrottle_1 = (0, tslib_1.__importDefault)(require(\"./api/delete_by_query_rethrottle\"));\nconst delete_script_1 = (0, tslib_1.__importDefault)(require(\"./api/delete_script\"));\nconst enrich_1 = (0, tslib_1.__importDefault)(require(\"./api/enrich\"));\nconst eql_1 = (0, tslib_1.__importDefault)(require(\"./api/eql\"));\nconst exists_1 = (0, tslib_1.__importDefault)(require(\"./api/exists\"));\nconst exists_source_1 = (0, tslib_1.__importDefault)(require(\"./api/exists_source\"));\nconst explain_1 = (0, tslib_1.__importDefault)(require(\"./api/explain\"));\nconst features_1 = (0, tslib_1.__importDefault)(require(\"./api/features\"));\nconst field_caps_1 = (0, tslib_1.__importDefault)(require(\"./api/field_caps\"));\nconst fleet_1 = (0, tslib_1.__importDefault)(require(\"./api/fleet\"));\nconst get_1 = (0, tslib_1.__importDefault)(require(\"./api/get\"));\nconst get_script_1 = (0, tslib_1.__importDefault)(require(\"./api/get_script\"));\nconst get_script_context_1 = (0, tslib_1.__importDefault)(require(\"./api/get_script_context\"));\nconst get_script_languages_1 = (0, tslib_1.__importDefault)(require(\"./api/get_script_languages\"));\nconst get_source_1 = (0, tslib_1.__importDefault)(require(\"./api/get_source\"));\nconst graph_1 = (0, tslib_1.__importDefault)(require(\"./api/graph\"));\nconst ilm_1 = (0, tslib_1.__importDefault)(require(\"./api/ilm\"));\nconst index_1 = (0, tslib_1.__importDefault)(require(\"./api/index\"));\nconst indices_1 = (0, tslib_1.__importDefault)(require(\"./api/indices\"));\nconst info_1 = (0, tslib_1.__importDefault)(require(\"./api/info\"));\nconst ingest_1 = (0, tslib_1.__importDefault)(require(\"./api/ingest\"));\nconst knn_search_1 = (0, tslib_1.__importDefault)(require(\"./api/knn_search\"));\nconst license_1 = (0, tslib_1.__importDefault)(require(\"./api/license\"));\nconst logstash_1 = (0, tslib_1.__importDefault)(require(\"./api/logstash\"));\nconst mget_1 = (0, tslib_1.__importDefault)(require(\"./api/mget\"));\nconst migration_1 = (0, tslib_1.__importDefault)(require(\"./api/migration\"));\nconst ml_1 = (0, tslib_1.__importDefault)(require(\"./api/ml\"));\nconst monitoring_1 = (0, tslib_1.__importDefault)(require(\"./api/monitoring\"));\nconst msearch_1 = (0, tslib_1.__importDefault)(require(\"./api/msearch\"));\nconst msearch_template_1 = (0, tslib_1.__importDefault)(require(\"./api/msearch_template\"));\nconst mtermvectors_1 = (0, tslib_1.__importDefault)(require(\"./api/mtermvectors\"));\nconst nodes_1 = (0, tslib_1.__importDefault)(require(\"./api/nodes\"));\nconst open_point_in_time_1 = (0, tslib_1.__importDefault)(require(\"./api/open_point_in_time\"));\nconst ping_1 = (0, tslib_1.__importDefault)(require(\"./api/ping\"));\nconst put_script_1 = (0, tslib_1.__importDefault)(require(\"./api/put_script\"));\nconst rank_eval_1 = (0, tslib_1.__importDefault)(require(\"./api/rank_eval\"));\nconst reindex_1 = (0, tslib_1.__importDefault)(require(\"./api/reindex\"));\nconst reindex_rethrottle_1 = (0, tslib_1.__importDefault)(require(\"./api/reindex_rethrottle\"));\nconst render_search_template_1 = (0, tslib_1.__importDefault)(require(\"./api/render_search_template\"));\nconst rollup_1 = (0, tslib_1.__importDefault)(require(\"./api/rollup\"));\nconst scripts_painless_execute_1 = (0, tslib_1.__importDefault)(require(\"./api/scripts_painless_execute\"));\nconst scroll_1 = (0, tslib_1.__importDefault)(require(\"./api/scroll\"));\nconst search_1 = (0, tslib_1.__importDefault)(require(\"./api/search\"));\nconst search_mvt_1 = (0, tslib_1.__importDefault)(require(\"./api/search_mvt\"));\nconst search_shards_1 = (0, tslib_1.__importDefault)(require(\"./api/search_shards\"));\nconst search_template_1 = (0, tslib_1.__importDefault)(require(\"./api/search_template\"));\nconst searchable_snapshots_1 = (0, tslib_1.__importDefault)(require(\"./api/searchable_snapshots\"));\nconst security_1 = (0, tslib_1.__importDefault)(require(\"./api/security\"));\nconst shutdown_1 = (0, tslib_1.__importDefault)(require(\"./api/shutdown\"));\nconst slm_1 = (0, tslib_1.__importDefault)(require(\"./api/slm\"));\nconst snapshot_1 = (0, tslib_1.__importDefault)(require(\"./api/snapshot\"));\nconst sql_1 = (0, tslib_1.__importDefault)(require(\"./api/sql\"));\nconst ssl_1 = (0, tslib_1.__importDefault)(require(\"./api/ssl\"));\nconst tasks_1 = (0, tslib_1.__importDefault)(require(\"./api/tasks\"));\nconst terms_enum_1 = (0, tslib_1.__importDefault)(require(\"./api/terms_enum\"));\nconst termvectors_1 = (0, tslib_1.__importDefault)(require(\"./api/termvectors\"));\nconst text_structure_1 = (0, tslib_1.__importDefault)(require(\"./api/text_structure\"));\nconst transform_1 = (0, tslib_1.__importDefault)(require(\"./api/transform\"));\nconst update_1 = (0, tslib_1.__importDefault)(require(\"./api/update\"));\nconst update_by_query_1 = (0, tslib_1.__importDefault)(require(\"./api/update_by_query\"));\nconst update_by_query_rethrottle_1 = (0, tslib_1.__importDefault)(require(\"./api/update_by_query_rethrottle\"));\nconst watcher_1 = (0, tslib_1.__importDefault)(require(\"./api/watcher\"));\nconst xpack_1 = (0, tslib_1.__importDefault)(require(\"./api/xpack\"));\nconst kAsyncSearch = Symbol('AsyncSearch');\nconst kAutoscaling = Symbol('Autoscaling');\nconst kCat = Symbol('Cat');\nconst kCcr = Symbol('Ccr');\nconst kCluster = Symbol('Cluster');\nconst kDanglingIndices = Symbol('DanglingIndices');\nconst kEnrich = Symbol('Enrich');\nconst kEql = Symbol('Eql');\nconst kFeatures = Symbol('Features');\nconst kFleet = Symbol('Fleet');\nconst kGraph = Symbol('Graph');\nconst kIlm = Symbol('Ilm');\nconst kIndices = Symbol('Indices');\nconst kIngest = Symbol('Ingest');\nconst kLicense = Symbol('License');\nconst kLogstash = Symbol('Logstash');\nconst kMigration = Symbol('Migration');\nconst kMl = Symbol('Ml');\nconst kMonitoring = Symbol('Monitoring');\nconst kNodes = Symbol('Nodes');\nconst kRollup = Symbol('Rollup');\nconst kSearchableSnapshots = Symbol('SearchableSnapshots');\nconst kSecurity = Symbol('Security');\nconst kShutdown = Symbol('Shutdown');\nconst kSlm = Symbol('Slm');\nconst kSnapshot = Symbol('Snapshot');\nconst kSql = Symbol('Sql');\nconst kSsl = Symbol('Ssl');\nconst kTasks = Symbol('Tasks');\nconst kTextStructure = Symbol('TextStructure');\nconst kTransform = Symbol('Transform');\nconst kWatcher = Symbol('Watcher');\nconst kXpack = Symbol('Xpack');\nclass API {\n    constructor() {\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _d, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _e, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _f, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _g, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _h, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _j, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _k, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _l, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _m, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _o, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _p, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _q, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _r, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _s, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _t, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _u, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _v, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _w, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _x, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _y, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _z, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _0, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _1, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _2, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _3, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _4, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _5, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _6, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _7, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _8, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[kAsyncSearch] = null;\n        this[kAutoscaling] = null;\n        this[kCat] = null;\n        this[kCcr] = null;\n        this[kCluster] = null;\n        this[kDanglingIndices] = null;\n        this[kEnrich] = null;\n        this[kEql] = null;\n        this[kFeatures] = null;\n        this[kFleet] = null;\n        this[kGraph] = null;\n        this[kIlm] = null;\n        this[kIndices] = null;\n        this[kIngest] = null;\n        this[kLicense] = null;\n        this[kLogstash] = null;\n        this[kMigration] = null;\n        this[kMl] = null;\n        this[kMonitoring] = null;\n        this[kNodes] = null;\n        this[kRollup] = null;\n        this[kSearchableSnapshots] = null;\n        this[kSecurity] = null;\n        this[kShutdown] = null;\n        this[kSlm] = null;\n        this[kSnapshot] = null;\n        this[kSql] = null;\n        this[kSsl] = null;\n        this[kTasks] = null;\n        this[kTextStructure] = null;\n        this[kTransform] = null;\n        this[kWatcher] = null;\n        this[kXpack] = null;\n    }\n}\nexports.default = API;\n_a = kAsyncSearch, _b = kAutoscaling, _c = kCat, _d = kCcr, _e = kCluster, _f = kDanglingIndices, _g = kEnrich, _h = kEql, _j = kFeatures, _k = kFleet, _l = kGraph, _m = kIlm, _o = kIndices, _p = kIngest, _q = kLicense, _r = kLogstash, _s = kMigration, _t = kMl, _u = kMonitoring, _v = kNodes, _w = kRollup, _x = kSearchableSnapshots, _y = kSecurity, _z = kShutdown, _0 = kSlm, _1 = kSnapshot, _2 = kSql, _3 = kSsl, _4 = kTasks, _5 = kTextStructure, _6 = kTransform, _7 = kWatcher, _8 = kXpack;\nAPI.prototype.bulk = bulk_1.default;\nAPI.prototype.clearScroll = clear_scroll_1.default;\nAPI.prototype.closePointInTime = close_point_in_time_1.default;\nAPI.prototype.count = count_1.default;\nAPI.prototype.create = create_1.default;\nAPI.prototype.delete = delete_1.default;\nAPI.prototype.deleteByQuery = delete_by_query_1.default;\nAPI.prototype.deleteByQueryRethrottle = delete_by_query_rethrottle_1.default;\nAPI.prototype.deleteScript = delete_script_1.default;\nAPI.prototype.exists = exists_1.default;\nAPI.prototype.existsSource = exists_source_1.default;\nAPI.prototype.explain = explain_1.default;\nAPI.prototype.fieldCaps = field_caps_1.default;\nAPI.prototype.get = get_1.default;\nAPI.prototype.getScript = get_script_1.default;\nAPI.prototype.getScriptContext = get_script_context_1.default;\nAPI.prototype.getScriptLanguages = get_script_languages_1.default;\nAPI.prototype.getSource = get_source_1.default;\nAPI.prototype.index = index_1.default;\nAPI.prototype.info = info_1.default;\nAPI.prototype.knnSearch = knn_search_1.default;\nAPI.prototype.mget = mget_1.default;\nAPI.prototype.msearch = msearch_1.default;\nAPI.prototype.msearchTemplate = msearch_template_1.default;\nAPI.prototype.mtermvectors = mtermvectors_1.default;\nAPI.prototype.openPointInTime = open_point_in_time_1.default;\nAPI.prototype.ping = ping_1.default;\nAPI.prototype.putScript = put_script_1.default;\nAPI.prototype.rankEval = rank_eval_1.default;\nAPI.prototype.reindex = reindex_1.default;\nAPI.prototype.reindexRethrottle = reindex_rethrottle_1.default;\nAPI.prototype.renderSearchTemplate = render_search_template_1.default;\nAPI.prototype.scriptsPainlessExecute = scripts_painless_execute_1.default;\nAPI.prototype.scroll = scroll_1.default;\nAPI.prototype.search = search_1.default;\nAPI.prototype.searchMvt = search_mvt_1.default;\nAPI.prototype.searchShards = search_shards_1.default;\nAPI.prototype.searchTemplate = search_template_1.default;\nAPI.prototype.termsEnum = terms_enum_1.default;\nAPI.prototype.termvectors = termvectors_1.default;\nAPI.prototype.update = update_1.default;\nAPI.prototype.updateByQuery = update_by_query_1.default;\nAPI.prototype.updateByQueryRethrottle = update_by_query_rethrottle_1.default;\nObject.defineProperties(API.prototype, {\n    asyncSearch: {\n        get() { return this[kAsyncSearch] === null ? (this[kAsyncSearch] = new async_search_1.default(this.transport)) : this[kAsyncSearch]; }\n    },\n    autoscaling: {\n        get() { return this[kAutoscaling] === null ? (this[kAutoscaling] = new autoscaling_1.default(this.transport)) : this[kAutoscaling]; }\n    },\n    cat: {\n        get() { return this[kCat] === null ? (this[kCat] = new cat_1.default(this.transport)) : this[kCat]; }\n    },\n    ccr: {\n        get() { return this[kCcr] === null ? (this[kCcr] = new ccr_1.default(this.transport)) : this[kCcr]; }\n    },\n    cluster: {\n        get() { return this[kCluster] === null ? (this[kCluster] = new cluster_1.default(this.transport)) : this[kCluster]; }\n    },\n    danglingIndices: {\n        get() { return this[kDanglingIndices] === null ? (this[kDanglingIndices] = new dangling_indices_1.default(this.transport)) : this[kDanglingIndices]; }\n    },\n    enrich: {\n        get() { return this[kEnrich] === null ? (this[kEnrich] = new enrich_1.default(this.transport)) : this[kEnrich]; }\n    },\n    eql: {\n        get() { return this[kEql] === null ? (this[kEql] = new eql_1.default(this.transport)) : this[kEql]; }\n    },\n    features: {\n        get() { return this[kFeatures] === null ? (this[kFeatures] = new features_1.default(this.transport)) : this[kFeatures]; }\n    },\n    fleet: {\n        get() { return this[kFleet] === null ? (this[kFleet] = new fleet_1.default(this.transport)) : this[kFleet]; }\n    },\n    graph: {\n        get() { return this[kGraph] === null ? (this[kGraph] = new graph_1.default(this.transport)) : this[kGraph]; }\n    },\n    ilm: {\n        get() { return this[kIlm] === null ? (this[kIlm] = new ilm_1.default(this.transport)) : this[kIlm]; }\n    },\n    indices: {\n        get() { return this[kIndices] === null ? (this[kIndices] = new indices_1.default(this.transport)) : this[kIndices]; }\n    },\n    ingest: {\n        get() { return this[kIngest] === null ? (this[kIngest] = new ingest_1.default(this.transport)) : this[kIngest]; }\n    },\n    license: {\n        get() { return this[kLicense] === null ? (this[kLicense] = new license_1.default(this.transport)) : this[kLicense]; }\n    },\n    logstash: {\n        get() { return this[kLogstash] === null ? (this[kLogstash] = new logstash_1.default(this.transport)) : this[kLogstash]; }\n    },\n    migration: {\n        get() { return this[kMigration] === null ? (this[kMigration] = new migration_1.default(this.transport)) : this[kMigration]; }\n    },\n    ml: {\n        get() { return this[kMl] === null ? (this[kMl] = new ml_1.default(this.transport)) : this[kMl]; }\n    },\n    monitoring: {\n        get() { return this[kMonitoring] === null ? (this[kMonitoring] = new monitoring_1.default(this.transport)) : this[kMonitoring]; }\n    },\n    nodes: {\n        get() { return this[kNodes] === null ? (this[kNodes] = new nodes_1.default(this.transport)) : this[kNodes]; }\n    },\n    rollup: {\n        get() { return this[kRollup] === null ? (this[kRollup] = new rollup_1.default(this.transport)) : this[kRollup]; }\n    },\n    searchableSnapshots: {\n        get() { return this[kSearchableSnapshots] === null ? (this[kSearchableSnapshots] = new searchable_snapshots_1.default(this.transport)) : this[kSearchableSnapshots]; }\n    },\n    security: {\n        get() { return this[kSecurity] === null ? (this[kSecurity] = new security_1.default(this.transport)) : this[kSecurity]; }\n    },\n    shutdown: {\n        get() { return this[kShutdown] === null ? (this[kShutdown] = new shutdown_1.default(this.transport)) : this[kShutdown]; }\n    },\n    slm: {\n        get() { return this[kSlm] === null ? (this[kSlm] = new slm_1.default(this.transport)) : this[kSlm]; }\n    },\n    snapshot: {\n        get() { return this[kSnapshot] === null ? (this[kSnapshot] = new snapshot_1.default(this.transport)) : this[kSnapshot]; }\n    },\n    sql: {\n        get() { return this[kSql] === null ? (this[kSql] = new sql_1.default(this.transport)) : this[kSql]; }\n    },\n    ssl: {\n        get() { return this[kSsl] === null ? (this[kSsl] = new ssl_1.default(this.transport)) : this[kSsl]; }\n    },\n    tasks: {\n        get() { return this[kTasks] === null ? (this[kTasks] = new tasks_1.default(this.transport)) : this[kTasks]; }\n    },\n    textStructure: {\n        get() { return this[kTextStructure] === null ? (this[kTextStructure] = new text_structure_1.default(this.transport)) : this[kTextStructure]; }\n    },\n    transform: {\n        get() { return this[kTransform] === null ? (this[kTransform] = new transform_1.default(this.transport)) : this[kTransform]; }\n    },\n    watcher: {\n        get() { return this[kWatcher] === null ? (this[kWatcher] = new watcher_1.default(this.transport)) : this[kWatcher]; }\n    },\n    xpack: {\n        get() { return this[kXpack] === null ? (this[kXpack] = new xpack_1.default(this.transport)) : this[kXpack]; }\n    }\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst url_1 = require(\"url\");\nconst buffer_1 = (0, tslib_1.__importDefault)(require(\"buffer\"));\nconst transport_1 = require(\"@elastic/transport\");\nconst BaseConnection_1 = require(\"@elastic/transport/lib/connection/BaseConnection\");\nconst sniffingTransport_1 = (0, tslib_1.__importDefault)(require(\"./sniffingTransport\"));\nconst helpers_1 = (0, tslib_1.__importDefault)(require(\"./helpers\"));\nconst api_1 = (0, tslib_1.__importDefault)(require(\"./api\"));\nconst kChild = Symbol('elasticsearchjs-child');\nconst kInitialOptions = Symbol('elasticsearchjs-initial-options');\nlet clientVersion = require('../package.json').version; // eslint-disable-line\n/* istanbul ignore next */\nif (clientVersion.includes('-')) {\n    // clean prerelease\n    clientVersion = clientVersion.slice(0, clientVersion.indexOf('-')) + 'p';\n}\nlet transportVersion = require('@elastic/transport/package.json').version; // eslint-disable-line\n/* istanbul ignore next */\nif (transportVersion.includes('-')) {\n    // clean prerelease\n    transportVersion = transportVersion.slice(0, transportVersion.indexOf('-')) + 'p';\n}\nconst nodeVersion = process.versions.node;\nclass Client extends api_1.default {\n    constructor(opts) {\n        var _a, _b, _c, _d;\n        super();\n        Object.defineProperty(this, \"diagnostic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"connectionPool\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"transport\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"serializer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"helpers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // @ts-expect-error kChild symbol is for internal use only\n        if ((opts.cloud != null) && opts[kChild] === undefined) {\n            const { id } = opts.cloud;\n            // the cloud id is `cluster-name:base64encodedurl`\n            // the url is a string divided by two '$', the first is the cloud url\n            // the second the elasticsearch instance, the third the kibana instance\n            const cloudUrls = Buffer.from(id.split(':')[1], 'base64').toString().split('$');\n            opts.node = `https://${cloudUrls[1]}.${cloudUrls[0]}`;\n            // Cloud has better performances with compression enabled\n            // see https://github.com/elastic/elasticsearch-py/pull/704.\n            // So unless the user specifies otherwise, we enable compression.\n            if (opts.compression == null)\n                opts.compression = true;\n            if (opts.tls == null ||\n                (opts.tls != null && opts.tls.secureProtocol == null)) {\n                opts.tls = (_a = opts.tls) !== null && _a !== void 0 ? _a : {};\n                opts.tls.secureProtocol = 'TLSv1_2_method';\n            }\n        }\n        if (opts.node == null && opts.nodes == null) {\n            throw new transport_1.errors.ConfigurationError('Missing node(s) option');\n        }\n        // @ts-expect-error kChild symbol is for internal use only\n        if (opts[kChild] === undefined) {\n            const checkAuth = getAuth((_b = opts.node) !== null && _b !== void 0 ? _b : opts.nodes);\n            if ((checkAuth != null) && checkAuth.username !== '' && checkAuth.password !== '') {\n                opts.auth = Object.assign({}, opts.auth, { username: checkAuth.username, password: checkAuth.password });\n            }\n        }\n        const options = Object.assign({}, {\n            Connection: transport_1.UndiciConnection,\n            Transport: sniffingTransport_1.default,\n            Serializer: transport_1.Serializer,\n            ConnectionPool: (opts.cloud != null) ? transport_1.CloudConnectionPool : transport_1.WeightedConnectionPool,\n            maxRetries: 3,\n            requestTimeout: 30000,\n            pingTimeout: 3000,\n            sniffInterval: false,\n            sniffOnStart: false,\n            sniffEndpoint: '_nodes/_all/http',\n            sniffOnConnectionFault: false,\n            resurrectStrategy: 'ping',\n            compression: false,\n            tls: null,\n            caFingerprint: null,\n            agent: null,\n            headers: {},\n            nodeFilter: null,\n            generateRequestId: null,\n            name: 'elasticsearch-js',\n            auth: null,\n            opaqueIdPrefix: null,\n            context: null,\n            proxy: null,\n            enableMetaHeader: true,\n            maxResponseSize: null,\n            maxCompressedResponseSize: null\n        }, opts);\n        if (options.caFingerprint !== null && isHttpConnection((_c = opts.node) !== null && _c !== void 0 ? _c : opts.nodes)) {\n            throw new transport_1.errors.ConfigurationError('You can\\'t configure the caFingerprint with a http connection');\n        }\n        if (options.maxResponseSize !== null && options.maxResponseSize > buffer_1.default.constants.MAX_STRING_LENGTH) {\n            throw new transport_1.errors.ConfigurationError(`The maxResponseSize cannot be bigger than ${buffer_1.default.constants.MAX_STRING_LENGTH}`);\n        }\n        if (options.maxCompressedResponseSize !== null && options.maxCompressedResponseSize > buffer_1.default.constants.MAX_LENGTH) {\n            throw new transport_1.errors.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${buffer_1.default.constants.MAX_LENGTH}`);\n        }\n        if (options.enableMetaHeader) {\n            options.headers['x-elastic-client-meta'] = `es=${clientVersion},js=${nodeVersion},t=${transportVersion},hc=${nodeVersion}`;\n        }\n        this.name = options.name;\n        // @ts-expect-error kInitialOptions symbol is for internal use only\n        this[kInitialOptions] = options;\n        // @ts-expect-error kChild symbol is for internal use only\n        if (opts[kChild] !== undefined) {\n            // @ts-expect-error kChild symbol is for internal use only\n            this.serializer = opts[kChild].serializer;\n            // @ts-expect-error kChild symbol is for internal use only\n            this.connectionPool = opts[kChild].connectionPool;\n            // @ts-expect-error kChild symbol is for internal use only\n            this.diagnostic = opts[kChild].diagnostic;\n        }\n        else {\n            this.diagnostic = new transport_1.Diagnostic();\n            this.serializer = new options.Serializer();\n            this.connectionPool = new options.ConnectionPool({\n                pingTimeout: options.pingTimeout,\n                resurrectStrategy: options.resurrectStrategy,\n                tls: options.tls,\n                agent: options.agent,\n                proxy: options.proxy,\n                Connection: options.Connection,\n                auth: options.auth,\n                diagnostic: this.diagnostic,\n                caFingerprint: options.caFingerprint\n            });\n            this.connectionPool.addConnection((_d = options.node) !== null && _d !== void 0 ? _d : options.nodes);\n        }\n        this.transport = new options.Transport({\n            diagnostic: this.diagnostic,\n            connectionPool: this.connectionPool,\n            serializer: this.serializer,\n            maxRetries: options.maxRetries,\n            requestTimeout: options.requestTimeout,\n            sniffInterval: options.sniffInterval,\n            sniffOnStart: options.sniffOnStart,\n            sniffOnConnectionFault: options.sniffOnConnectionFault,\n            sniffEndpoint: options.sniffEndpoint,\n            compression: options.compression,\n            headers: options.headers,\n            nodeFilter: options.nodeFilter,\n            nodeSelector: options.nodeSelector,\n            generateRequestId: options.generateRequestId,\n            name: options.name,\n            opaqueIdPrefix: options.opaqueIdPrefix,\n            context: options.context,\n            productCheck: 'Elasticsearch',\n            maxResponseSize: options.maxResponseSize,\n            maxCompressedResponseSize: options.maxCompressedResponseSize,\n            vendoredHeaders: {\n                jsonContentType: 'application/vnd.elasticsearch+json; compatible-with=8',\n                ndjsonContentType: 'application/vnd.elasticsearch+x-ndjson; compatible-with=8',\n                accept: 'application/vnd.elasticsearch+json; compatible-with=8,text/plain'\n            }\n        });\n        this.helpers = new helpers_1.default({\n            client: this,\n            metaHeader: options.enableMetaHeader\n                ? `es=${clientVersion},js=${nodeVersion},t=${transportVersion},hc=${nodeVersion}`\n                : null,\n            maxRetries: options.maxRetries\n        });\n    }\n    child(opts) {\n        // Merge the new options with the initial ones\n        // @ts-expect-error kChild symbol is for internal use only\n        const options = Object.assign({}, this[kInitialOptions], opts);\n        // Pass to the child client the parent instances that cannot be overriden\n        // @ts-expect-error kInitialOptions symbol is for internal use only\n        options[kChild] = {\n            connectionPool: this.connectionPool,\n            serializer: this.serializer,\n            diagnostic: this.diagnostic,\n            initialOptions: options\n        };\n        /* istanbul ignore else */\n        if (options.auth !== undefined) {\n            options.headers = (0, BaseConnection_1.prepareHeaders)(options.headers, options.auth);\n        }\n        return new Client(options);\n    }\n    async close() {\n        return await this.connectionPool.empty();\n    }\n}\nexports.default = Client;\nfunction isHttpConnection(node) {\n    if (Array.isArray(node)) {\n        return node.some((n) => (typeof n === 'string' ? new url_1.URL(n).protocol : n.url.protocol) === 'http:');\n    }\n    else {\n        if (node == null)\n            return false;\n        return (typeof node === 'string' ? new url_1.URL(node).protocol : node.url.protocol) === 'http:';\n    }\n}\nfunction getAuth(node) {\n    if (Array.isArray(node)) {\n        for (const url of node) {\n            const auth = getUsernameAndPassword(url);\n            if (auth != null && auth.username !== '' && auth.password !== '') {\n                return auth;\n            }\n        }\n        return null;\n    }\n    else {\n        const auth = getUsernameAndPassword(node);\n        if (auth != null && auth.username !== '' && auth.password !== '') {\n            return auth;\n        }\n        return null;\n    }\n    function getUsernameAndPassword(node) {\n        /* istanbul ignore else */\n        if (typeof node === 'string') {\n            const { username, password } = new url_1.URL(node);\n            return {\n                username: decodeURIComponent(username),\n                password: decodeURIComponent(password)\n            };\n        }\n        else if (node != null && node.url instanceof url_1.URL) {\n            return {\n                username: decodeURIComponent(node.url.username),\n                password: decodeURIComponent(node.url.password)\n            };\n        }\n        else {\n            return null;\n        }\n    }\n}\n//# sourceMappingURL=client.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\n/* eslint-disable @typescript-eslint/naming-convention */\n/* eslint-disable @typescript-eslint/promise-function-async */\nconst assert_1 = (0, tslib_1.__importDefault)(require(\"assert\"));\nconst util_1 = require(\"util\");\nconst stream_1 = require(\"stream\");\nconst transport_1 = require(\"@elastic/transport\");\nconst { ResponseError, ConfigurationError } = transport_1.errors;\nconst sleep = (0, util_1.promisify)(setTimeout);\nconst pImmediate = (0, util_1.promisify)(setImmediate);\n/* istanbul ignore next */\nconst noop = () => { };\nconst kClient = Symbol('elasticsearch-client');\nconst kMetaHeader = Symbol('meta header');\nconst kMaxRetries = Symbol('max retries');\nclass Helpers {\n    constructor(opts) {\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this[kClient] = opts.client;\n        this[kMetaHeader] = opts.metaHeader;\n        this[kMaxRetries] = opts.maxRetries;\n    }\n    /**\n     * Runs a search operation. The only difference between client.search and this utility,\n     * is that we are only returning the hits to the user and not the full ES response.\n     * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n     * as it will only need the documents source.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {array} The documents that matched the request.\n     */\n    async search(params, options = {}) {\n        var _d;\n        appendFilterPath('hits.hits._source', params, true);\n        options.meta = true;\n        const { body: result } = await this[kClient].search(params, options);\n        if (((_d = result.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {\n            return result.hits.hits.map(d => d._source);\n        }\n        return [];\n    }\n    /**\n     * Runs a scroll search operation. This function returns an async iterator, allowing\n     * the user to use a for await loop to get all the results of a given search.\n     * ```js\n     * for await (const result of client.helpers.scrollSearch({ params })) {\n     *   console.log(result)\n     * }\n     * ```\n     * Each result represents the entire body of a single scroll search request,\n     * if you just need to scroll the results, use scrollDocuments.\n     * This function handles automatically retries on 429 status code.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {iterator} the async iterator\n     */\n    async *scrollSearch(params, options = {}) {\n        var _d, _e, _f, _g;\n        options.meta = true;\n        if (this[kMetaHeader] !== null) {\n            options.headers = (_d = options.headers) !== null && _d !== void 0 ? _d : {};\n            options.headers['x-elastic-client-meta'] = `${this[kMetaHeader]},h=s`;\n        }\n        const wait = (_e = options.wait) !== null && _e !== void 0 ? _e : 5000;\n        const maxRetries = (_f = options.maxRetries) !== null && _f !== void 0 ? _f : this[kMaxRetries];\n        if (Array.isArray(options.ignore)) {\n            options.ignore.push(429);\n        }\n        else {\n            options.ignore = [429];\n        }\n        params.scroll = (_g = params.scroll) !== null && _g !== void 0 ? _g : '1m';\n        appendFilterPath('_scroll_id', params, false);\n        let response;\n        for (let i = 0; i <= maxRetries; i++) {\n            response = await this[kClient].search(params, options);\n            if (response.statusCode !== 429)\n                break;\n            await sleep(wait);\n        }\n        (0, assert_1.default)(response !== undefined, 'The response is undefined, please file a bug report');\n        if (response.statusCode === 429) {\n            throw new ResponseError(response);\n        }\n        let scroll_id = response.body._scroll_id;\n        let stop = false;\n        const clear = async () => {\n            stop = true;\n            await this[kClient].clearScroll({ scroll_id }, { ignore: [400], ...options });\n        };\n        while (response.body.hits != null && response.body.hits.hits.length > 0) {\n            // scroll id is always present in the response, but it might\n            // change over time based on the number of shards\n            scroll_id = response.body._scroll_id;\n            // @ts-expect-error\n            response.clear = clear;\n            addDocumentsGetter(response);\n            // @ts-expect-error\n            yield response;\n            if (stop) {\n                break;\n            }\n            for (let i = 0; i <= maxRetries; i++) {\n                const r = await this[kClient].scroll({\n                    scroll: params.scroll,\n                    rest_total_hits_as_int: params.rest_total_hits_as_int,\n                    scroll_id\n                }, options);\n                response = r;\n                (0, assert_1.default)(response !== undefined, 'The response is undefined, please file a bug report');\n                if (response.statusCode !== 429)\n                    break;\n                await sleep(wait);\n            }\n            if (response.statusCode === 429) {\n                throw new ResponseError(response);\n            }\n        }\n        if (!stop) {\n            await clear();\n        }\n    }\n    /**\n     * Runs a scroll search operation. This function returns an async iterator, allowing\n     * the user to use a for await loop to get all the documents of a given search.\n     * ```js\n     * for await (const document of client.helpers.scrollSearch({ params })) {\n     *   console.log(document)\n     * }\n     * ```\n     * Each document is what you will find by running a scrollSearch and iterating on the hits array.\n     * This helper automatically adds `filter_path=hits.hits._source` to the querystring,\n     * as it will only need the documents source.\n     * @param {object} params - The Elasticsearch's search parameters.\n     * @param {object} options - The client optional configuration for this request.\n     * @return {iterator} the async iterator\n     */\n    async *scrollDocuments(params, options = {}) {\n        appendFilterPath('hits.hits._source', params, true);\n        for await (const { documents } of this.scrollSearch(params, options)) {\n            for (const document of documents) {\n                yield document;\n            }\n        }\n    }\n    /**\n     * Creates a msearch helper instance. Once you configure it, you can use the provided\n     * `search` method to add new searches in the queue.\n     * @param {object} options - The configuration of the msearch operations.\n     * @param {object} reqOptions - The client optional configuration for this request.\n     * @return {object} The possible operations to run.\n     */\n    msearch(options = {}, reqOptions = {}) {\n        const client = this[kClient];\n        const { operations = 5, concurrency = 5, flushInterval = 500, retries = this[kMaxRetries], wait = 5000, ...msearchOptions } = options;\n        reqOptions.meta = true;\n        let stopReading = false;\n        let stopError = null;\n        let timeoutRef = null;\n        const operationsStream = new stream_1.Readable({\n            objectMode: true,\n            read(size) { }\n        });\n        const p = iterate();\n        const helper = {\n            [Symbol.toStringTag]: 'Promise',\n            then(onFulfilled, onRejected) {\n                return p.then(onFulfilled, onRejected);\n            },\n            catch(onRejected) {\n                return p.catch(onRejected);\n            },\n            finally(onFinally) {\n                return p.finally(onFinally);\n            },\n            stop(error = null) {\n                if (stopReading)\n                    return;\n                stopReading = true;\n                stopError = error;\n                operationsStream.push(null);\n            },\n            // TODO: support abort a single search?\n            // NOTE: the validation checks are synchronous and the callback/promise will\n            //       be resolved in the same tick. We might want to fix this in the future.\n            search(header, body) {\n                if (stopReading) {\n                    const error = stopError === null\n                        ? new ConfigurationError('The msearch processor has been stopped')\n                        : stopError;\n                    return Promise.reject(error);\n                }\n                if (!(typeof header === 'object' && header !== null && !Array.isArray(header))) {\n                    return Promise.reject(new ConfigurationError('The header should be an object'));\n                }\n                if (!(typeof body === 'object' && body !== null && !Array.isArray(body))) {\n                    return Promise.reject(new ConfigurationError('The body should be an object'));\n                }\n                let onFulfilled = null;\n                let onRejected = null;\n                const promise = new Promise((resolve, reject) => {\n                    onFulfilled = resolve;\n                    onRejected = reject;\n                });\n                const callback = function callback(err, result) {\n                    err !== null ? onRejected(err) : onFulfilled(result);\n                };\n                operationsStream.push([header, body, callback]);\n                return promise;\n            }\n        };\n        return helper;\n        async function iterate() {\n            const { semaphore, finish } = buildSemaphore();\n            const msearchBody = [];\n            const callbacks = [];\n            let loadedOperations = 0;\n            timeoutRef = setTimeout(onFlushTimeout, flushInterval); // eslint-disable-line\n            for await (const operation of operationsStream) {\n                timeoutRef.refresh();\n                loadedOperations += 1;\n                msearchBody.push(operation[0], operation[1]);\n                callbacks.push(operation[2]);\n                if (loadedOperations >= operations) {\n                    const send = await semaphore();\n                    send(msearchBody.slice(), callbacks.slice());\n                    msearchBody.length = 0;\n                    callbacks.length = 0;\n                    loadedOperations = 0;\n                }\n            }\n            clearTimeout(timeoutRef);\n            // In some cases the previos http call does not have finished,\n            // or we didn't reach the flush bytes threshold, so we force one last operation.\n            if (loadedOperations > 0) {\n                const send = await semaphore();\n                send(msearchBody, callbacks);\n            }\n            await finish();\n            if (stopError !== null) {\n                throw stopError;\n            }\n            async function onFlushTimeout() {\n                if (loadedOperations === 0)\n                    return;\n                const msearchBodyCopy = msearchBody.slice();\n                const callbacksCopy = callbacks.slice();\n                msearchBody.length = 0;\n                callbacks.length = 0;\n                loadedOperations = 0;\n                try {\n                    const send = await semaphore();\n                    send(msearchBodyCopy, callbacksCopy);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    // @ts-expect-error\n                    helper.stop(err);\n                }\n            }\n        }\n        // This function builds a semaphore using the concurrency\n        // options of the msearch helper. It is used inside the iterator\n        // to guarantee that no more than the number of operations\n        // allowed to run at the same time are executed.\n        // It returns a semaphore function which resolves in the next tick\n        // if we didn't reach the maximim concurrency yet, otherwise it returns\n        // a promise that resolves as soon as one of the running request has finshed.\n        // The semaphore function resolves a send function, which will be used\n        // to send the actual msearch request.\n        // It also returns a finish function, which returns a promise that is resolved\n        // when there are no longer request running.\n        function buildSemaphore() {\n            let resolveSemaphore = null;\n            let resolveFinish = null;\n            let running = 0;\n            return { semaphore, finish };\n            function finish() {\n                return new Promise((resolve, reject) => {\n                    if (running === 0) {\n                        resolve();\n                    }\n                    else {\n                        resolveFinish = resolve;\n                    }\n                });\n            }\n            function semaphore() {\n                if (running < concurrency) {\n                    running += 1;\n                    return pImmediate(send);\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        resolveSemaphore = resolve;\n                    });\n                }\n            }\n            function send(msearchBody, callbacks) {\n                /* istanbul ignore if */\n                if (running > concurrency) {\n                    throw new Error('Max concurrency reached');\n                }\n                msearchOperation(msearchBody, callbacks, () => {\n                    running -= 1;\n                    if (resolveSemaphore !== null) {\n                        running += 1;\n                        resolveSemaphore(send);\n                        resolveSemaphore = null;\n                    }\n                    else if (resolveFinish != null && running === 0) {\n                        resolveFinish();\n                    }\n                });\n            }\n        }\n        function msearchOperation(msearchBody, callbacks, done) {\n            let retryCount = retries;\n            // Instead of going full on async-await, which would make the code easier to read,\n            // we have decided to use callback style instead.\n            // This because every time we use async await, V8 will create multiple promises\n            // behind the scenes, making the code slightly slower.\n            tryMsearch(msearchBody, callbacks, retrySearch);\n            function retrySearch(msearchBody, callbacks) {\n                if (msearchBody.length > 0 && retryCount > 0) {\n                    retryCount -= 1;\n                    setTimeout(tryMsearch, wait, msearchBody, callbacks, retrySearch);\n                    return;\n                }\n                done();\n            }\n            // This function never returns an error, if the msearch operation fails,\n            // the error is dispatched to all search executors.\n            function tryMsearch(msearchBody, callbacks, done) {\n                client.msearch(Object.assign({}, msearchOptions, { body: msearchBody }), reqOptions)\n                    .then(results => {\n                    const retryBody = [];\n                    const retryCallbacks = [];\n                    const { responses } = results.body;\n                    for (let i = 0, len = responses.length; i < len; i++) {\n                        const response = responses[i];\n                        if (response.status === 429 && retryCount > 0) {\n                            retryBody.push(msearchBody[i * 2]);\n                            retryBody.push(msearchBody[(i * 2) + 1]);\n                            retryCallbacks.push(callbacks[i]);\n                            continue;\n                        }\n                        const result = { ...results, body: response };\n                        // @ts-expect-error\n                        addDocumentsGetter(result);\n                        if (response.status != null && response.status >= 400) {\n                            callbacks[i](new ResponseError(result), result);\n                        }\n                        else {\n                            callbacks[i](null, result);\n                        }\n                    }\n                    done(retryBody, retryCallbacks);\n                })\n                    .catch(err => {\n                    for (const callback of callbacks) {\n                        callback(err, null);\n                    }\n                    return done([], []);\n                });\n            }\n        }\n    }\n    /**\n     * Creates a bulk helper instance. Once you configure it, you can pick which operation\n     * to execute with the given dataset, index, create, update, and delete.\n     * @param {object} options - The configuration of the bulk operation.\n     * @param {object} reqOptions - The client optional configuration for this request.\n     * @return {object} The possible operations to run with the datasource.\n     */\n    bulk(options, reqOptions = {}) {\n        var _d;\n        const client = this[kClient];\n        const { serializer } = client;\n        if (this[kMetaHeader] !== null) {\n            reqOptions.headers = (_d = reqOptions.headers) !== null && _d !== void 0 ? _d : {};\n            reqOptions.headers['x-elastic-client-meta'] = `${this[kMetaHeader]},h=bp`;\n        }\n        reqOptions.meta = true;\n        const { datasource, onDocument, flushBytes = 5000000, flushInterval = 30000, concurrency = 5, retries = this[kMaxRetries], wait = 5000, onDrop = noop, refreshOnCompletion = false, ...bulkOptions } = options;\n        if (datasource === undefined) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the datasource is required'));\n        }\n        if (!(Array.isArray(datasource) || Buffer.isBuffer(datasource) || isReadableStream(datasource) || isAsyncIterator(datasource))) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the datasource must be an array or a buffer or a readable stream or an async generator'));\n        }\n        if (onDocument === undefined) {\n            // @ts-expect-error\n            return Promise.reject(new ConfigurationError('bulk helper: the onDocument callback is required'));\n        }\n        let shouldAbort = false;\n        let timeoutRef = null;\n        const stats = {\n            total: 0,\n            failed: 0,\n            retry: 0,\n            successful: 0,\n            noop: 0,\n            time: 0,\n            bytes: 0,\n            aborted: false\n        };\n        const p = iterate();\n        const helper = {\n            [Symbol.toStringTag]: 'Promise',\n            then(onFulfilled, onRejected) {\n                return p.then(onFulfilled, onRejected);\n            },\n            catch(onRejected) {\n                return p.catch(onRejected);\n            },\n            finally(onFinally) {\n                return p.finally(onFinally);\n            },\n            get stats() {\n                return stats;\n            },\n            abort() {\n                clearTimeout(timeoutRef);\n                shouldAbort = true;\n                stats.aborted = true;\n                return this;\n            }\n        };\n        return helper;\n        /**\n         * Function that iterates over the given datasource and start a bulk operation as soon\n         * as it reaches the configured bulk size. It's designed to use the Node.js asynchronous\n         * model at this maximum capacity, as it will collect the next body to send while there is\n         * a running http call. In this way, the CPU time will be used carefully.\n         * The objects will be serialized right away, to approximate the byte length of the body.\n         * It creates an array of strings instead of a ndjson string because the bulkOperation\n         * will navigate the body for matching failed operations with the original document.\n         */\n        async function iterate() {\n            const { semaphore, finish } = buildSemaphore();\n            const startTime = Date.now();\n            const bulkBody = [];\n            let actionBody = '';\n            let payloadBody = '';\n            let chunkBytes = 0;\n            timeoutRef = setTimeout(onFlushTimeout, flushInterval); // eslint-disable-line\n            // @ts-expect-error datasoruce is an iterable\n            for await (const chunk of datasource) {\n                if (shouldAbort)\n                    break;\n                timeoutRef.refresh();\n                const action = onDocument(chunk);\n                const operation = Array.isArray(action)\n                    ? Object.keys(action[0])[0]\n                    : Object.keys(action)[0];\n                if (operation === 'index' || operation === 'create') {\n                    actionBody = serializer.serialize(action);\n                    payloadBody = typeof chunk === 'string' ? chunk : serializer.serialize(chunk);\n                    chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n                    bulkBody.push(actionBody, payloadBody);\n                }\n                else if (operation === 'update') {\n                    // @ts-expect-error in case of update action is an array\n                    actionBody = serializer.serialize(action[0]);\n                    payloadBody = typeof chunk === 'string'\n                        ? `{\"doc\":${chunk}}`\n                        // @ts-expect-error in case of update action is an array\n                        : serializer.serialize({ doc: chunk, ...action[1] });\n                    chunkBytes += Buffer.byteLength(actionBody) + Buffer.byteLength(payloadBody);\n                    bulkBody.push(actionBody, payloadBody);\n                }\n                else if (operation === 'delete') {\n                    actionBody = serializer.serialize(action);\n                    chunkBytes += Buffer.byteLength(actionBody);\n                    bulkBody.push(actionBody);\n                }\n                else {\n                    clearTimeout(timeoutRef);\n                    throw new ConfigurationError(`Bulk helper invalid action: '${operation}'`);\n                }\n                if (chunkBytes >= flushBytes) {\n                    stats.bytes += chunkBytes;\n                    const send = await semaphore();\n                    send(bulkBody.slice());\n                    bulkBody.length = 0;\n                    chunkBytes = 0;\n                }\n            }\n            clearTimeout(timeoutRef);\n            // In some cases the previos http call does not have finished,\n            // or we didn't reach the flush bytes threshold, so we force one last operation.\n            if (!shouldAbort && chunkBytes > 0) {\n                const send = await semaphore();\n                stats.bytes += chunkBytes;\n                send(bulkBody);\n            }\n            await finish();\n            if (refreshOnCompletion !== false) {\n                await client.indices.refresh({\n                    index: typeof refreshOnCompletion === 'string'\n                        ? refreshOnCompletion\n                        : '_all'\n                }, reqOptions);\n            }\n            stats.time = Date.now() - startTime;\n            stats.total = stats.successful + stats.failed;\n            return stats;\n            async function onFlushTimeout() {\n                if (chunkBytes === 0)\n                    return;\n                stats.bytes += chunkBytes;\n                const bulkBodyCopy = bulkBody.slice();\n                bulkBody.length = 0;\n                chunkBytes = 0;\n                try {\n                    const send = await semaphore();\n                    send(bulkBodyCopy);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    helper.abort(); // eslint-disable-line\n                }\n            }\n        }\n        // This function builds a semaphore using the concurrency\n        // options of the bulk helper. It is used inside the iterator\n        // to guarantee that no more than the number of operations\n        // allowed to run at the same time are executed.\n        // It returns a semaphore function which resolves in the next tick\n        // if we didn't reach the maximim concurrency yet, otherwise it returns\n        // a promise that resolves as soon as one of the running request has finshed.\n        // The semaphore function resolves a send function, which will be used\n        // to send the actual bulk request.\n        // It also returns a finish function, which returns a promise that is resolved\n        // when there are no longer request running. It rejects an error if one\n        // of the request has failed for some reason.\n        function buildSemaphore() {\n            let resolveSemaphore = null;\n            let resolveFinish = null;\n            let rejectFinish = null;\n            let error = null;\n            let running = 0;\n            return { semaphore, finish };\n            function finish() {\n                return new Promise((resolve, reject) => {\n                    if (running === 0) {\n                        if (error !== null) {\n                            reject(error);\n                        }\n                        else {\n                            resolve();\n                        }\n                    }\n                    else {\n                        resolveFinish = resolve;\n                        rejectFinish = reject;\n                    }\n                });\n            }\n            function semaphore() {\n                if (running < concurrency) {\n                    running += 1;\n                    return pImmediate(send);\n                }\n                else {\n                    return new Promise((resolve, reject) => {\n                        resolveSemaphore = resolve;\n                    });\n                }\n            }\n            function send(bulkBody) {\n                /* istanbul ignore if */\n                if (running > concurrency) {\n                    throw new Error('Max concurrency reached');\n                }\n                bulkOperation(bulkBody, err => {\n                    running -= 1;\n                    if (err != null) {\n                        shouldAbort = true;\n                        error = err;\n                    }\n                    if (resolveSemaphore !== null) {\n                        running += 1;\n                        resolveSemaphore(send);\n                        resolveSemaphore = null;\n                    }\n                    else if (resolveFinish != null && rejectFinish != null && running === 0) {\n                        if (error != null) {\n                            rejectFinish(error);\n                        }\n                        else {\n                            resolveFinish();\n                        }\n                    }\n                });\n            }\n        }\n        function bulkOperation(bulkBody, callback) {\n            let retryCount = retries;\n            let isRetrying = false;\n            // Instead of going full on async-await, which would make the code easier to read,\n            // we have decided to use callback style instead.\n            // This because every time we use async await, V8 will create multiple promises\n            // behind the scenes, making the code slightly slower.\n            tryBulk(bulkBody, retryDocuments);\n            function retryDocuments(err, bulkBody) {\n                if (err != null)\n                    return callback(err);\n                if (shouldAbort)\n                    return callback();\n                if (bulkBody.length > 0) {\n                    if (retryCount > 0) {\n                        isRetrying = true;\n                        retryCount -= 1;\n                        stats.retry += bulkBody.length;\n                        setTimeout(tryBulk, wait, bulkBody, retryDocuments);\n                        return;\n                    }\n                    for (let i = 0, len = bulkBody.length; i < len; i = i + 2) {\n                        const operation = Object.keys(serializer.deserialize(bulkBody[i]))[0];\n                        onDrop({\n                            status: 429,\n                            error: null,\n                            operation: serializer.deserialize(bulkBody[i]),\n                            document: operation !== 'delete'\n                                ? serializer.deserialize(bulkBody[i + 1])\n                                /* istanbul ignore next */\n                                : null,\n                            retried: isRetrying\n                        });\n                        stats.failed += 1;\n                    }\n                }\n                callback();\n            }\n            function tryBulk(bulkBody, callback) {\n                if (shouldAbort)\n                    return callback(null, []);\n                client.bulk(Object.assign({}, bulkOptions, { body: bulkBody }), reqOptions)\n                    .then(response => {\n                    var _d, _e;\n                    const result = response.body;\n                    if (!result.errors) {\n                        stats.successful += result.items.length;\n                        for (const item of result.items) {\n                            if (((_d = item.update) === null || _d === void 0 ? void 0 : _d.result) === 'noop') {\n                                stats.noop++;\n                            }\n                        }\n                        return callback(null, []);\n                    }\n                    const retry = [];\n                    const { items } = result;\n                    for (let i = 0, len = items.length; i < len; i++) {\n                        const action = items[i];\n                        const operation = Object.keys(action)[0];\n                        // @ts-expect-error\n                        const responseItem = action[operation];\n                        (0, assert_1.default)(responseItem !== undefined, 'The responseItem is undefined, please file a bug report');\n                        const indexSlice = operation !== 'delete' ? i * 2 : i;\n                        if (responseItem.status >= 400) {\n                            // 429 is the only staus code where we might want to retry\n                            // a document, because it was not an error in the document itself,\n                            // but the ES node were handling too many operations.\n                            if (responseItem.status === 429) {\n                                retry.push(bulkBody[indexSlice]);\n                                /* istanbul ignore next */\n                                if (operation !== 'delete') {\n                                    retry.push(bulkBody[indexSlice + 1]);\n                                }\n                            }\n                            else {\n                                onDrop({\n                                    status: responseItem.status,\n                                    error: (_e = responseItem.error) !== null && _e !== void 0 ? _e : null,\n                                    operation: serializer.deserialize(bulkBody[indexSlice]),\n                                    document: operation !== 'delete'\n                                        ? serializer.deserialize(bulkBody[indexSlice + 1])\n                                        : null,\n                                    retried: isRetrying\n                                });\n                                stats.failed += 1;\n                            }\n                        }\n                        else {\n                            stats.successful += 1;\n                        }\n                    }\n                    callback(null, retry);\n                })\n                    .catch(err => {\n                    callback(err, []);\n                });\n            }\n        }\n    }\n}\nexports.default = Helpers;\n_a = kClient, _b = kMetaHeader, _c = kMaxRetries;\n// Using a getter will improve the overall performances of the code,\n// as we will reed the documents only if needed.\nfunction addDocumentsGetter(result) {\n    Object.defineProperty(result, 'documents', {\n        get() {\n            var _d;\n            if (((_d = this.body.hits) === null || _d === void 0 ? void 0 : _d.hits) != null) {\n                // @ts-expect-error\n                return this.body.hits.hits.map(d => d._source);\n            }\n            return [];\n        }\n    });\n}\nfunction appendFilterPath(filter, params, force) {\n    if (params.filter_path !== undefined) {\n        params.filter_path += ',' + filter; // eslint-disable-line\n    }\n    else if (force) {\n        params.filter_path = filter;\n    }\n}\nfunction isReadableStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction isAsyncIterator(obj) {\n    return (obj === null || obj === void 0 ? void 0 : obj[Symbol.asyncIterator]) != null;\n}\n//# sourceMappingURL=helpers.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\") you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst assert_1 = (0, tslib_1.__importDefault)(require(\"assert\"));\nconst transport_1 = require(\"@elastic/transport\");\nclass SniffingTransport extends transport_1.Transport {\n    sniff(opts) {\n        var _a;\n        if (this.isSniffing)\n            return;\n        this.isSniffing = true;\n        const request = {\n            method: 'GET',\n            path: (_a = this.sniffEndpoint) !== null && _a !== void 0 ? _a : '/_nodes/_all/http'\n        };\n        this.request(request, { id: opts.requestId, meta: true })\n            .then(result => {\n            var _a, _b;\n            (0, assert_1.default)(isObject(result.body), 'The body should be an object');\n            this.isSniffing = false;\n            const protocol = (_b = (_a = result.meta.connection) === null || _a === void 0 ? void 0 : _a.url.protocol) !== null && _b !== void 0 ? _b : 'http:';\n            const hosts = this.connectionPool.nodesToHost(result.body.nodes, protocol);\n            this.connectionPool.update(hosts);\n            result.meta.sniff = { hosts, reason: opts.reason };\n            this.diagnostic.emit('sniff', null, result);\n        })\n            .catch(err => {\n            this.isSniffing = false;\n            err.meta.sniff = { hosts: [], reason: opts.reason };\n            this.diagnostic.emit('sniff', err, null);\n        });\n    }\n}\nexports.default = SniffingTransport;\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\n//# sourceMappingURL=sniffingTransport.js.map","/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n'use strict'\n\nconst { default: Diagnostic, events } = require('./lib/Diagnostic')\nconst Transport = require('./lib/Transport').default\nconst {\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection\n} = require('./lib/connection')\nconst {\n  BaseConnectionPool,\n  ClusterConnectionPool,\n  CloudConnectionPool,\n  WeightedConnectionPool\n} = require('./lib/pool')\nconst Serializer = require('./lib/Serializer').default\nconst errors = require('./lib/errors')\n\nmodule.exports = {\n  Diagnostic,\n  Transport,\n  BaseConnection,\n  HttpConnection,\n  UndiciConnection,\n  BaseConnectionPool,\n  ClusterConnectionPool,\n  CloudConnectionPool,\n  WeightedConnectionPool,\n  Serializer,\n  errors,\n  events\n}\n","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.events = void 0;\nconst events_1 = require(\"events\");\nconst errors_1 = require(\"./errors\");\nvar events;\n(function (events) {\n    events[\"RESPONSE\"] = \"response\";\n    events[\"REQUEST\"] = \"request\";\n    events[\"SNIFF\"] = \"sniff\";\n    events[\"RESURRECT\"] = \"resurrect\";\n    events[\"SERIALIZATION\"] = \"serialization\";\n    events[\"DESERIALIZATION\"] = \"deserialization\";\n})(events = exports.events || (exports.events = {}));\nclass Diagnostic extends events_1.EventEmitter {\n    on(event, listener) {\n        assertSupportedEvent(event);\n        super.on(event, listener);\n        return this;\n    }\n    once(event, listener) {\n        assertSupportedEvent(event);\n        super.once(event, listener);\n        return this;\n    }\n    off(event, listener) {\n        assertSupportedEvent(event);\n        super.off(event, listener);\n        return this;\n    }\n}\nexports.default = Diagnostic;\nfunction assertSupportedEvent(event) {\n    if (!supportedEvents.includes(event)) {\n        throw new errors_1.ConfigurationError(`The event '${event}' is not supported.`);\n    }\n}\n// @ts-expect-error\nconst supportedEvents = Object.keys(events).map(key => events[key]);\n//# sourceMappingURL=Diagnostic.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst querystring_1 = require(\"querystring\");\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst secure_json_parse_1 = (0, tslib_1.__importDefault)(require(\"secure-json-parse\"));\nconst errors_1 = require(\"./errors\");\nconst symbols_1 = require(\"./symbols\");\nconst debug = (0, debug_1.default)('elasticsearch');\nclass Serializer {\n    constructor(opts = {}) {\n        var _b;\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        const enabled = (_b = opts.enablePrototypePoisoningProtection) !== null && _b !== void 0 ? _b : false;\n        this[symbols_1.kJsonOptions] = {\n            protoAction: enabled === true || enabled === 'proto' ? 'error' : 'ignore',\n            constructorAction: enabled === true || enabled === 'constructor' ? 'error' : 'ignore'\n        };\n    }\n    serialize(object) {\n        debug('Serializing', object);\n        let json;\n        try {\n            json = JSON.stringify(object);\n        }\n        catch (err) {\n            throw new errors_1.SerializationError(err.message, object);\n        }\n        return json;\n    }\n    deserialize(json) {\n        debug('Deserializing', json);\n        let object;\n        try {\n            // @ts-expect-error\n            object = secure_json_parse_1.default.parse(json, this[symbols_1.kJsonOptions]);\n        }\n        catch (err) {\n            throw new errors_1.DeserializationError(err.message, json);\n        }\n        return object;\n    }\n    ndserialize(array) {\n        debug('ndserialize', array);\n        if (!Array.isArray(array)) {\n            throw new errors_1.SerializationError('The argument provided is not an array', array);\n        }\n        let ndjson = '';\n        for (let i = 0, len = array.length; i < len; i++) {\n            if (typeof array[i] === 'string') {\n                ndjson += array[i] + '\\n'; // eslint-disable-line\n            }\n            else {\n                // @ts-expect-error\n                ndjson += this.serialize(array[i]) + '\\n'; // eslint-disable-line\n            }\n        }\n        return ndjson;\n    }\n    qserialize(object) {\n        debug('qserialize', object);\n        if (object == null)\n            return '';\n        if (typeof object === 'string')\n            return object;\n        // arrays should be serialized as comma separated list\n        const keys = Object.keys(object);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const key = keys[i];\n            // elasticsearch will complain for keys without a value\n            if (object[key] === undefined) {\n                delete object[key]; // eslint-disable-line\n            }\n            else if (Array.isArray(object[key])) {\n                object[key] = object[key].join(',');\n            }\n        }\n        return (0, querystring_1.stringify)(object);\n    }\n}\nexports.default = Serializer;\n_a = symbols_1.kJsonOptions;\n//# sourceMappingURL=Serializer.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lowerCaseHeaders = exports.generateRequestId = void 0;\nconst tslib_1 = require(\"tslib\");\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst os_1 = (0, tslib_1.__importDefault)(require(\"os\"));\nconst zlib_1 = (0, tslib_1.__importDefault)(require(\"zlib\"));\nconst buffer_1 = (0, tslib_1.__importDefault)(require(\"buffer\"));\nconst util_1 = require(\"util\");\nconst ms_1 = (0, tslib_1.__importDefault)(require(\"ms\"));\nconst errors_1 = require(\"./errors\");\nconst Diagnostic_1 = (0, tslib_1.__importDefault)(require(\"./Diagnostic\"));\nconst Serializer_1 = (0, tslib_1.__importDefault)(require(\"./Serializer\"));\nconst symbols_1 = require(\"./symbols\");\nconst { version: clientVersion } = require('../package.json'); // eslint-disable-line\nconst debug = (0, debug_1.default)('elasticsearch');\nconst gzip = (0, util_1.promisify)(zlib_1.default.gzip);\nconst unzip = (0, util_1.promisify)(zlib_1.default.unzip);\nconst { createGzip } = zlib_1.default;\nconst userAgent = `elastic-transport-js/${clientVersion} (${os_1.default.platform()} ${os_1.default.release()}-${os_1.default.arch()}; Node.js ${process.version})`; // eslint-disable-line\nclass Transport {\n    constructor(opts) {\n        var _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16, _17, _18, _19, _20;\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _d, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _e, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _f, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _g, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _h, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _j, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _k, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _l, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _m, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _o, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _p, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _q, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _r, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _s, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _t, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _u, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _v, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _w, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _x, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _y, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _z, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _0, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (opts.connectionPool == null) {\n            throw new errors_1.ConfigurationError('The Connection Pool option is not defined');\n        }\n        if (typeof opts.maxRetries === 'number' && opts.maxRetries < 0 && Number.isInteger(opts.maxRetries)) {\n            throw new errors_1.ConfigurationError('The maxRetries option must be a positive integer or zero');\n        }\n        if (opts.sniffInterval === true ||\n            (typeof opts.sniffInterval === 'number' && opts.sniffInterval < 0 && Number.isInteger(opts.sniffInterval))) {\n            throw new errors_1.ConfigurationError('The sniffInterval option must be false or a positive integer');\n        }\n        if (opts.maxResponseSize != null && opts.maxResponseSize > buffer_1.default.constants.MAX_STRING_LENGTH) {\n            throw new errors_1.ConfigurationError(`The maxResponseSize cannot be bigger than ${buffer_1.default.constants.MAX_STRING_LENGTH}`);\n        }\n        if (opts.maxCompressedResponseSize != null && opts.maxCompressedResponseSize > buffer_1.default.constants.MAX_LENGTH) {\n            throw new errors_1.ConfigurationError(`The maxCompressedResponseSize cannot be bigger than ${buffer_1.default.constants.MAX_LENGTH}`);\n        }\n        this[symbols_1.kNodeFilter] = (_1 = opts.nodeFilter) !== null && _1 !== void 0 ? _1 : defaultNodeFilter;\n        this[symbols_1.kNodeSelector] = (_2 = opts.nodeSelector) !== null && _2 !== void 0 ? _2 : roundRobinSelector();\n        this[symbols_1.kHeaders] = Object.assign({}, { 'user-agent': userAgent }, opts.compression === true ? { 'accept-encoding': 'gzip,deflate' } : null, lowerCaseHeaders(opts.headers));\n        this[symbols_1.kDiagnostic] = (_3 = opts.diagnostic) !== null && _3 !== void 0 ? _3 : new Diagnostic_1.default();\n        this[symbols_1.kConnectionPool] = opts.connectionPool;\n        this[symbols_1.kSerializer] = (_4 = opts.serializer) !== null && _4 !== void 0 ? _4 : new Serializer_1.default();\n        this[symbols_1.kContext] = (_5 = opts.context) !== null && _5 !== void 0 ? _5 : null;\n        this[symbols_1.kGenerateRequestId] = (_6 = opts.generateRequestId) !== null && _6 !== void 0 ? _6 : generateRequestId();\n        this[symbols_1.kOpaqueIdPrefix] = (_7 = opts.opaqueIdPrefix) !== null && _7 !== void 0 ? _7 : null;\n        this[symbols_1.kName] = (_8 = opts.name) !== null && _8 !== void 0 ? _8 : 'elastic-transport-js';\n        this[symbols_1.kMaxRetries] = typeof opts.maxRetries === 'number' ? opts.maxRetries : 3;\n        this[symbols_1.kCompression] = opts.compression === true;\n        this[symbols_1.kRequestTimeout] = opts.requestTimeout != null ? toMs(opts.requestTimeout) : 30000;\n        this[symbols_1.kSniffInterval] = (_9 = opts.sniffInterval) !== null && _9 !== void 0 ? _9 : false;\n        this[symbols_1.kSniffEnabled] = typeof this[symbols_1.kSniffInterval] === 'number';\n        this[symbols_1.kNextSniff] = this[symbols_1.kSniffEnabled] ? (Date.now() + this[symbols_1.kSniffInterval]) : 0;\n        this[symbols_1.kIsSniffing] = false;\n        this[symbols_1.kSniffOnConnectionFault] = (_10 = opts.sniffOnConnectionFault) !== null && _10 !== void 0 ? _10 : false;\n        this[symbols_1.kSniffEndpoint] = (_11 = opts.sniffEndpoint) !== null && _11 !== void 0 ? _11 : null;\n        this[symbols_1.kProductCheck] = (_12 = opts.productCheck) !== null && _12 !== void 0 ? _12 : null;\n        this[symbols_1.kMaxResponseSize] = (_13 = opts.maxResponseSize) !== null && _13 !== void 0 ? _13 : buffer_1.default.constants.MAX_STRING_LENGTH;\n        this[symbols_1.kMaxCompressedResponseSize] = (_14 = opts.maxCompressedResponseSize) !== null && _14 !== void 0 ? _14 : buffer_1.default.constants.MAX_LENGTH;\n        this[symbols_1.kJsonContentType] = (_16 = (_15 = opts.vendoredHeaders) === null || _15 === void 0 ? void 0 : _15.jsonContentType) !== null && _16 !== void 0 ? _16 : 'application/json';\n        this[symbols_1.kNdjsonContentType] = (_18 = (_17 = opts.vendoredHeaders) === null || _17 === void 0 ? void 0 : _17.ndjsonContentType) !== null && _18 !== void 0 ? _18 : 'application/x-ndjson';\n        this[symbols_1.kAcceptHeader] = (_20 = (_19 = opts.vendoredHeaders) === null || _19 === void 0 ? void 0 : _19.accept) !== null && _20 !== void 0 ? _20 : 'application/json, text/plain';\n        if (opts.sniffOnStart === true) {\n            this.sniff({\n                reason: Transport.sniffReasons.SNIFF_ON_START,\n                requestId: this[symbols_1.kGenerateRequestId]({ method: 'GET', path: this[symbols_1.kSniffEndpoint] }, { context: this[symbols_1.kContext] }),\n                context: this[symbols_1.kContext]\n            });\n        }\n    }\n    get connectionPool() {\n        return this[symbols_1.kConnectionPool];\n    }\n    get sniffEnabled() {\n        return this[symbols_1.kSniffEnabled];\n    }\n    get nextSniff() {\n        return this[symbols_1.kNextSniff];\n    }\n    get sniffEndpoint() {\n        return this[symbols_1.kSniffEndpoint];\n    }\n    get isSniffing() {\n        return this[symbols_1.kIsSniffing];\n    }\n    set isSniffing(val) {\n        if (typeof val !== 'boolean') {\n            throw new errors_1.ConfigurationError(`isSniffing must be a boolean, instead got ${typeof val}`);\n        }\n        this[symbols_1.kIsSniffing] = val;\n    }\n    get diagnostic() {\n        return this[symbols_1.kDiagnostic];\n    }\n    async request(params, options = {}) {\n        var _1, _2, _3, _4, _5, _6, _7, _8, _9, _10, _11, _12, _13, _14, _15, _16;\n        const connectionParams = {\n            method: params.method,\n            path: params.path\n        };\n        const meta = {\n            context: null,\n            request: {\n                params: connectionParams,\n                options: options,\n                id: (_1 = options.id) !== null && _1 !== void 0 ? _1 : this[symbols_1.kGenerateRequestId](params, options)\n            },\n            name: this[symbols_1.kName],\n            connection: null,\n            attempts: 0,\n            aborted: false\n        };\n        const returnMeta = (_2 = options.meta) !== null && _2 !== void 0 ? _2 : false;\n        if (this[symbols_1.kContext] != null && options.context != null) {\n            meta.context = Object.assign({}, this[symbols_1.kContext], options.context);\n        }\n        else if (this[symbols_1.kContext] !== null) {\n            meta.context = this[symbols_1.kContext];\n        }\n        else if (options.context != null) {\n            meta.context = options.context;\n        }\n        const result = {\n            // the default body value can't be `null`\n            // as it's a valid JSON value\n            body: undefined,\n            statusCode: 0,\n            headers: {},\n            meta,\n            get warnings() {\n                var _1;\n                return ((_1 = this.headers) === null || _1 === void 0 ? void 0 : _1.warning) != null\n                    ? this.headers.warning.split(/(?!\\B\"[^\"]*),(?![^\"]*\"\\B)/)\n                    : null;\n            }\n        };\n        // We should not retry if we are sending a stream body, because we should store in memory\n        // a copy of the stream to be able to send it again, but since we don't know in advance\n        // the size of the stream, we risk to take too much memory.\n        // Furthermore, copying everytime the stream is very a expensive operation.\n        const maxRetries = isStream((_3 = params.body) !== null && _3 !== void 0 ? _3 : params.bulkBody) ? 0 : (typeof options.maxRetries === 'number' ? options.maxRetries : this[symbols_1.kMaxRetries]);\n        const compression = typeof options.compression === 'boolean' ? options.compression : this[symbols_1.kCompression];\n        const signal = options.signal;\n        const maxResponseSize = (_4 = options.maxResponseSize) !== null && _4 !== void 0 ? _4 : this[symbols_1.kMaxResponseSize];\n        const maxCompressedResponseSize = (_5 = options.maxCompressedResponseSize) !== null && _5 !== void 0 ? _5 : this[symbols_1.kMaxCompressedResponseSize];\n        this[symbols_1.kDiagnostic].emit('serialization', null, result);\n        const headers = Object.assign({}, this[symbols_1.kHeaders], lowerCaseHeaders(options.headers));\n        if (options.opaqueId !== undefined) {\n            headers['x-opaque-id'] = typeof this[symbols_1.kOpaqueIdPrefix] === 'string'\n                ? this[symbols_1.kOpaqueIdPrefix] + options.opaqueId // eslint-disable-line\n                : options.opaqueId;\n        }\n        // handle json body\n        if (params.body != null) {\n            if (shouldSerialize(params.body)) {\n                try {\n                    connectionParams.body = this[symbols_1.kSerializer].serialize(params.body);\n                }\n                catch (err) {\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    throw err;\n                }\n                headers['content-type'] = (_6 = headers['content-type']) !== null && _6 !== void 0 ? _6 : this[symbols_1.kJsonContentType];\n                headers.accept = (_7 = headers.accept) !== null && _7 !== void 0 ? _7 : this[symbols_1.kJsonContentType];\n            }\n            else {\n                if (params.body !== '') {\n                    headers['content-type'] = (_8 = headers['content-type']) !== null && _8 !== void 0 ? _8 : 'text/plain';\n                    headers.accept = (_9 = headers.accept) !== null && _9 !== void 0 ? _9 : this[symbols_1.kAcceptHeader];\n                }\n                connectionParams.body = params.body;\n            }\n            // handle ndjson body\n        }\n        else if (params.bulkBody != null) {\n            if (shouldSerialize(params.bulkBody)) {\n                try {\n                    connectionParams.body = this[symbols_1.kSerializer].ndserialize(params.bulkBody);\n                }\n                catch (err) {\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    throw err;\n                }\n            }\n            else {\n                connectionParams.body = params.bulkBody;\n            }\n            if (connectionParams.body !== '') {\n                headers['content-type'] = (_10 = headers['content-type']) !== null && _10 !== void 0 ? _10 : this[symbols_1.kNdjsonContentType];\n                headers.accept = (_11 = headers.accept) !== null && _11 !== void 0 ? _11 : this[symbols_1.kJsonContentType];\n            }\n        }\n        // serializes the querystring\n        if (options.querystring == null) {\n            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(params.querystring);\n        }\n        else {\n            connectionParams.querystring = this[symbols_1.kSerializer].qserialize(Object.assign({}, params.querystring, options.querystring));\n        }\n        // handle compression\n        if (connectionParams.body !== '' && connectionParams.body != null) {\n            if (isStream(connectionParams.body)) {\n                if (compression) {\n                    headers['content-encoding'] = 'gzip';\n                    connectionParams.body = connectionParams.body.pipe(createGzip());\n                }\n            }\n            else if (compression) {\n                try {\n                    connectionParams.body = await gzip(connectionParams.body);\n                }\n                catch (err) {\n                    /* istanbul ignore next */\n                    this[symbols_1.kDiagnostic].emit('request', err, result);\n                    /* istanbul ignore next */\n                    throw err;\n                }\n                headers['content-encoding'] = 'gzip';\n                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line\n            }\n            else {\n                headers['content-length'] = '' + Buffer.byteLength(connectionParams.body); // eslint-disable-line\n            }\n        }\n        headers.accept = (_12 = headers.accept) !== null && _12 !== void 0 ? _12 : this[symbols_1.kAcceptHeader];\n        connectionParams.headers = headers;\n        while (meta.attempts <= maxRetries) {\n            try {\n                if (signal === null || signal === void 0 ? void 0 : signal.aborted) { // eslint-disable-line\n                    throw new errors_1.RequestAbortedError('Request has been aborted by the user', result);\n                }\n                meta.connection = this.getConnection({\n                    requestId: meta.request.id,\n                    context: meta.context\n                });\n                if (meta.connection === null) {\n                    throw new errors_1.NoLivingConnectionsError('There are no living connections', result);\n                }\n                this[symbols_1.kDiagnostic].emit('request', null, result);\n                // perform the actual http request\n                let { statusCode, headers, body } = await meta.connection.request(connectionParams, {\n                    requestId: meta.request.id,\n                    name: this[symbols_1.kName],\n                    context: meta.context,\n                    maxResponseSize,\n                    maxCompressedResponseSize,\n                    signal,\n                    timeout: toMs(options.requestTimeout != null ? options.requestTimeout : this[symbols_1.kRequestTimeout]),\n                    ...(options.asStream === true ? { asStream: true } : null)\n                });\n                result.statusCode = statusCode;\n                result.headers = headers;\n                if (this[symbols_1.kProductCheck] != null && headers['x-elastic-product'] !== this[symbols_1.kProductCheck] && statusCode >= 200 && statusCode < 300) {\n                    throw new errors_1.ProductNotSupportedError(this[symbols_1.kProductCheck], result);\n                }\n                if (options.asStream === true) {\n                    result.body = body;\n                    this[symbols_1.kDiagnostic].emit('response', null, result);\n                    return returnMeta ? result : body;\n                }\n                const contentEncoding = ((_13 = headers['content-encoding']) !== null && _13 !== void 0 ? _13 : '').toLowerCase();\n                if (contentEncoding.includes('gzip') || contentEncoding.includes('deflate')) {\n                    body = await unzip(body);\n                }\n                const isVectorTile = ((_14 = headers['content-type']) !== null && _14 !== void 0 ? _14 : '').includes('application/vnd.mapbox-vector-tile');\n                if (Buffer.isBuffer(body) && !isVectorTile) {\n                    body = body.toString();\n                }\n                const isHead = params.method === 'HEAD';\n                // we should attempt the payload deserialization only if:\n                //    - a `content-type` is defined and is equal to `application/json`\n                //    - the request is not a HEAD request\n                //    - the payload is not an empty string\n                if (headers['content-type'] !== undefined &&\n                    (((_15 = headers['content-type']) === null || _15 === void 0 ? void 0 : _15.includes('application/json')) ||\n                        ((_16 = headers['content-type']) === null || _16 === void 0 ? void 0 : _16.includes('application/vnd.elasticsearch+json'))) &&\n                    !isHead && body !== '') { // eslint-disable-line\n                    result.body = this[symbols_1.kSerializer].deserialize(body);\n                }\n                else {\n                    // cast to boolean if the request method was HEAD and there was no error\n                    result.body = isHead && statusCode < 400 ? true : body;\n                }\n                // we should ignore the statusCode if the user has configured the `ignore` field with\n                // the statusCode we just got or if the request method is HEAD and the statusCode is 404\n                const ignoreStatusCode = (Array.isArray(options.ignore) && options.ignore.includes(statusCode)) ||\n                    (isHead && statusCode === 404);\n                if (!ignoreStatusCode && (statusCode === 502 || statusCode === 503 || statusCode === 504)) {\n                    // if the statusCode is 502/3/4 we should run our retry strategy\n                    // and mark the connection as dead\n                    this[symbols_1.kConnectionPool].markDead(meta.connection);\n                    // retry logic\n                    if (meta.attempts < maxRetries) {\n                        meta.attempts++;\n                        debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n                        continue;\n                    }\n                }\n                else {\n                    // everything has worked as expected, let's mark\n                    // the connection as alive (or confirm it)\n                    this[symbols_1.kConnectionPool].markAlive(meta.connection);\n                }\n                if (!ignoreStatusCode && statusCode >= 400) {\n                    throw new errors_1.ResponseError(result);\n                }\n                else {\n                    // cast to boolean if the request method was HEAD\n                    if (isHead && statusCode === 404) {\n                        result.body = false;\n                    }\n                    this[symbols_1.kDiagnostic].emit('response', null, result);\n                    return returnMeta ? result : result.body;\n                }\n            }\n            catch (error) {\n                switch (error.name) {\n                    // should not retry\n                    case 'ProductNotSupportedError':\n                    case 'NoLivingConnectionsError':\n                    case 'DeserializationError':\n                    case 'ResponseError':\n                        this[symbols_1.kDiagnostic].emit('response', error, result);\n                        throw error;\n                    case 'RequestAbortedError': {\n                        meta.aborted = true;\n                        // Wrap the error to get a clean stack trace\n                        const wrappedError = new errors_1.RequestAbortedError(error.message, result);\n                        this[symbols_1.kDiagnostic].emit('response', wrappedError, result);\n                        throw wrappedError;\n                    }\n                    // should retry\n                    case 'TimeoutError':\n                    case 'ConnectionError': {\n                        // if there is an error in the connection\n                        // let's mark the connection as dead\n                        this[symbols_1.kConnectionPool].markDead(meta.connection);\n                        if (this[symbols_1.kSniffOnConnectionFault]) {\n                            this.sniff({\n                                reason: Transport.sniffReasons.SNIFF_ON_CONNECTION_FAULT,\n                                requestId: meta.request.id,\n                                context: meta.context\n                            });\n                        }\n                        // retry logic\n                        if (meta.attempts < maxRetries) {\n                            meta.attempts++;\n                            debug(`Retrying request, there are still ${maxRetries - meta.attempts} attempts`, params);\n                            continue;\n                        }\n                        // Wrap the error to get a clean stack trace\n                        const wrappedError = error.name === 'TimeoutError'\n                            ? new errors_1.TimeoutError(error.message, result)\n                            : new errors_1.ConnectionError(error.message, result);\n                        this[symbols_1.kDiagnostic].emit('response', wrappedError, result);\n                        throw wrappedError;\n                    }\n                    // edge cases, such as bad compression\n                    default:\n                        this[symbols_1.kDiagnostic].emit('response', error, result);\n                        throw error;\n                }\n            }\n        }\n        return returnMeta ? result : result.body;\n    }\n    getConnection(opts) {\n        const now = Date.now();\n        if (this[symbols_1.kSniffEnabled] && now > this[symbols_1.kNextSniff]) {\n            this[symbols_1.kNextSniff] = now + this[symbols_1.kSniffInterval];\n            this.sniff({\n                reason: Transport.sniffReasons.SNIFF_INTERVAL,\n                requestId: opts.requestId,\n                context: opts.context\n            });\n        }\n        return this[symbols_1.kConnectionPool].getConnection({\n            filter: this[symbols_1.kNodeFilter],\n            selector: this[symbols_1.kNodeSelector],\n            requestId: opts.requestId,\n            name: this[symbols_1.kName],\n            context: opts.context,\n            now\n        });\n    }\n    /* istanbul ignore next */\n    sniff(opts) { }\n}\nexports.default = Transport;\n_a = symbols_1.kNodeFilter, _b = symbols_1.kNodeSelector, _c = symbols_1.kHeaders, _d = symbols_1.kDiagnostic, _e = symbols_1.kConnectionPool, _f = symbols_1.kSerializer, _g = symbols_1.kContext, _h = symbols_1.kGenerateRequestId, _j = symbols_1.kOpaqueIdPrefix, _k = symbols_1.kName, _l = symbols_1.kMaxRetries, _m = symbols_1.kCompression, _o = symbols_1.kRequestTimeout, _p = symbols_1.kSniffEnabled, _q = symbols_1.kNextSniff, _r = symbols_1.kIsSniffing, _s = symbols_1.kSniffInterval, _t = symbols_1.kSniffOnConnectionFault, _u = symbols_1.kSniffEndpoint, _v = symbols_1.kProductCheck, _w = symbols_1.kMaxResponseSize, _x = symbols_1.kMaxCompressedResponseSize, _y = symbols_1.kJsonContentType, _z = symbols_1.kNdjsonContentType, _0 = symbols_1.kAcceptHeader;\nObject.defineProperty(Transport, \"sniffReasons\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        SNIFF_ON_START: 'sniff-on-start',\n        SNIFF_INTERVAL: 'sniff-interval',\n        SNIFF_ON_CONNECTION_FAULT: 'sniff-on-connection-fault',\n        DEFAULT: 'default'\n    }\n});\nfunction toMs(time) {\n    if (typeof time === 'string') {\n        return (0, ms_1.default)(time);\n    }\n    return time;\n}\nfunction shouldSerialize(obj) {\n    return typeof obj !== 'string' &&\n        typeof obj.pipe !== 'function' &&\n        !Buffer.isBuffer(obj);\n}\nfunction isStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction defaultNodeFilter(node) {\n    return true;\n}\nfunction roundRobinSelector() {\n    let current = -1;\n    return function _roundRobinSelector(connections) {\n        if (++current >= connections.length) {\n            current = 0;\n        }\n        return connections[current];\n    };\n}\nfunction generateRequestId() {\n    const maxInt = 2147483647;\n    let nextReqId = 0;\n    return function genReqId(params, options) {\n        return (nextReqId = (nextReqId + 1) & maxInt);\n    };\n}\nexports.generateRequestId = generateRequestId;\nfunction lowerCaseHeaders(oldHeaders) {\n    if (oldHeaders == null)\n        return null;\n    const newHeaders = {};\n    for (const header in oldHeaders) {\n        // @ts-expect-error\n        newHeaders[header.toLowerCase()] = oldHeaders[header];\n    }\n    return newHeaders;\n}\nexports.lowerCaseHeaders = lowerCaseHeaders;\n//# sourceMappingURL=Transport.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a, _b, _c;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIssuerCertificate = exports.prepareHeaders = void 0;\nconst tslib_1 = require(\"tslib\");\nconst util_1 = require(\"util\");\nconst Diagnostic_1 = (0, tslib_1.__importDefault)(require(\"../Diagnostic\"));\nconst errors_1 = require(\"../errors\");\nconst symbols_1 = require(\"../symbols\");\nclass BaseConnection {\n    constructor(opts) {\n        var _d, _e, _f, _g, _h, _j;\n        Object.defineProperty(this, \"url\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"id\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"headers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"deadCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_openRequests\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"weight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _b, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _c, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.url = opts.url;\n        this.tls = (_d = opts.tls) !== null && _d !== void 0 ? _d : null;\n        this.id = (_e = opts.id) !== null && _e !== void 0 ? _e : stripAuth(opts.url.href);\n        this.headers = prepareHeaders(opts.headers, opts.auth);\n        this.timeout = (_f = opts.timeout) !== null && _f !== void 0 ? _f : 30000;\n        this.deadCount = 0;\n        this.resurrectTimeout = 0;\n        this.weight = 0;\n        this._openRequests = 0;\n        this[symbols_1.kStatus] = (_g = opts.status) !== null && _g !== void 0 ? _g : BaseConnection.statuses.ALIVE;\n        this[symbols_1.kDiagnostic] = (_h = opts.diagnostic) !== null && _h !== void 0 ? _h : new Diagnostic_1.default();\n        this[symbols_1.kCaFingerprint] = (_j = opts.caFingerprint) !== null && _j !== void 0 ? _j : null;\n        if (!['http:', 'https:'].includes(this.url.protocol)) {\n            throw new errors_1.ConfigurationError(`Invalid protocol: '${this.url.protocol}'`);\n        }\n    }\n    get status() {\n        return this[symbols_1.kStatus];\n    }\n    set status(status) {\n        if (!validStatuses.includes(status)) {\n            throw new errors_1.ConfigurationError(`Unsupported status: '${status}'`);\n        }\n        this[symbols_1.kStatus] = status;\n    }\n    get diagnostic() {\n        return this[symbols_1.kDiagnostic];\n    }\n    async request(params, options) {\n        throw new errors_1.ConfigurationError('The request method should be implemented by extended classes');\n    }\n    /* istanbul ignore next */\n    async close() {\n        throw new errors_1.ConfigurationError('The close method should be implemented by extended classes');\n    }\n    // Handles console.log and utils.inspect invocations.\n    // We want to hide `auth`, `agent` and `tls` since they made\n    // the logs very hard to read. The user can still\n    // access them with `instance.agent` and `instance.tls`.\n    [(_a = symbols_1.kStatus, _b = symbols_1.kCaFingerprint, _c = symbols_1.kDiagnostic, util_1.inspect.custom)](depth, options) {\n        const { authorization, ...headers } = this.headers;\n        return {\n            url: stripAuth(this.url.toString()),\n            id: this.id,\n            headers,\n            status: this.status\n        };\n    }\n    toJSON() {\n        const { authorization, ...headers } = this.headers;\n        return {\n            url: stripAuth(this.url.toString()),\n            id: this.id,\n            headers,\n            status: this.status\n        };\n    }\n}\nexports.default = BaseConnection;\nObject.defineProperty(BaseConnection, \"statuses\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        ALIVE: 'alive',\n        DEAD: 'dead'\n    }\n});\nconst validStatuses = Object.keys(BaseConnection.statuses)\n    // @ts-expect-error\n    .map(k => BaseConnection.statuses[k]);\nfunction stripAuth(url) {\n    if (!url.includes('@'))\n        return url;\n    return url.slice(0, url.indexOf('//') + 2) + url.slice(url.indexOf('@') + 1);\n}\nfunction prepareHeaders(headers = {}, auth) {\n    if (auth != null && headers.authorization == null) {\n        /* istanbul ignore else */\n        if (isApiKeyAuth(auth)) {\n            if (typeof auth.apiKey === 'object') {\n                headers.authorization = 'ApiKey ' + Buffer.from(`${auth.apiKey.id}:${auth.apiKey.api_key}`).toString('base64');\n            }\n            else {\n                headers.authorization = `ApiKey ${auth.apiKey}`;\n            }\n        }\n        else if (isBearerAuth(auth)) {\n            headers.authorization = `Bearer ${auth.bearer}`;\n        }\n        else if (auth.username != null && auth.password != null) {\n            headers.authorization = 'Basic ' + Buffer.from(`${auth.username}:${auth.password}`).toString('base64');\n        }\n    }\n    return headers;\n}\nexports.prepareHeaders = prepareHeaders;\nfunction isApiKeyAuth(auth) {\n    return auth.apiKey != null;\n}\nfunction isBearerAuth(auth) {\n    return auth.bearer != null;\n}\nfunction getIssuerCertificate(socket) {\n    let certificate = socket.getPeerCertificate(true);\n    while (certificate !== null && Object.keys(certificate).length > 0) {\n        // invalid certificate\n        if (certificate.issuerCertificate == null) {\n            return null;\n        }\n        // We have reached the root certificate.\n        // In case of self-signed certificates, `issuerCertificate` may be a circular reference.\n        if (certificate.fingerprint256 === certificate.issuerCertificate.fingerprint256) {\n            break;\n        }\n        // continue the loop\n        certificate = certificate.issuerCertificate;\n    }\n    return certificate;\n}\nexports.getIssuerCertificate = getIssuerCertificate;\n//# sourceMappingURL=BaseConnection.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nconst hpagent_1 = (0, tslib_1.__importDefault)(require(\"hpagent\"));\nconst http_1 = (0, tslib_1.__importDefault)(require(\"http\"));\nconst https_1 = (0, tslib_1.__importDefault)(require(\"https\"));\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst buffer_1 = (0, tslib_1.__importDefault)(require(\"buffer\"));\nconst BaseConnection_1 = (0, tslib_1.__importStar)(require(\"./BaseConnection\"));\nconst symbols_1 = require(\"../symbols\");\nconst stream_1 = require(\"stream\");\nconst errors_1 = require(\"../errors\");\nconst debug = (0, debug_1.default)('elasticsearch');\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst MAX_BUFFER_LENGTH = buffer_1.default.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = buffer_1.default.constants.MAX_STRING_LENGTH;\nclass HttpConnection extends BaseConnection_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"agent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"makeRequest\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof opts.agent === 'function') {\n            this.agent = opts.agent(opts);\n        }\n        else if (typeof opts.agent === 'boolean') {\n            this.agent = undefined;\n        }\n        else {\n            if (opts.agent != null && !isHttpAgentOptions(opts.agent)) {\n                throw new errors_1.ConfigurationError('Bad agent configuration for Http agent');\n            }\n            const agentOptions = Object.assign({}, {\n                keepAlive: true,\n                keepAliveMsecs: 1000,\n                maxSockets: 256,\n                maxFreeSockets: 256,\n                scheduling: 'lifo'\n            }, opts.agent);\n            if (opts.proxy != null) {\n                const proxyAgentOptions = {\n                    ...agentOptions,\n                    proxy: opts.proxy\n                };\n                this.agent = this.url.protocol === 'http:'\n                    ? new hpagent_1.default.HttpProxyAgent(proxyAgentOptions)\n                    : new hpagent_1.default.HttpsProxyAgent(Object.assign({}, proxyAgentOptions, this.tls));\n            }\n            else {\n                this.agent = this.url.protocol === 'http:'\n                    ? new http_1.default.Agent(agentOptions)\n                    : new https_1.default.Agent(Object.assign({}, agentOptions, this.tls));\n            }\n        }\n        this.makeRequest = this.url.protocol === 'http:'\n            ? http_1.default.request\n            : https_1.default.request;\n    }\n    async request(params, options) {\n        return await new Promise((resolve, reject) => {\n            var _a, _b;\n            let cleanedListeners = false;\n            const maxResponseSize = (_a = options.maxResponseSize) !== null && _a !== void 0 ? _a : MAX_STRING_LENGTH;\n            const maxCompressedResponseSize = (_b = options.maxCompressedResponseSize) !== null && _b !== void 0 ? _b : MAX_BUFFER_LENGTH;\n            const requestParams = this.buildRequestObject(params, options);\n            // https://github.com/nodejs/node/commit/b961d9fd83\n            if (INVALID_PATH_REGEX.test(requestParams.path)) {\n                return reject(new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`));\n            }\n            debug('Starting a new request', params);\n            let request;\n            try {\n                request = this.makeRequest(requestParams);\n            }\n            catch (err) {\n                return reject(err);\n            }\n            const abortListener = () => {\n                request.abort();\n            };\n            this._openRequests++;\n            if (options.signal != null) {\n                options.signal.addEventListener('abort', abortListener, { once: true });\n            }\n            const onResponse = (response) => {\n                var _a, _b;\n                cleanListeners();\n                this._openRequests--;\n                if (options.asStream === true) {\n                    return resolve({\n                        body: response,\n                        statusCode: response.statusCode,\n                        headers: response.headers\n                    });\n                }\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate');\n                const isVectorTile = ((_b = response.headers['content-type']) !== null && _b !== void 0 ? _b : '').includes('application/vnd.mapbox-vector-tile');\n                /* istanbul ignore else */\n                if (response.headers['content-length'] !== undefined) {\n                    const contentLength = Number(response.headers['content-length']);\n                    if (isCompressed && contentLength > maxCompressedResponseSize) {\n                        response.destroy();\n                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`));\n                    }\n                    else if (contentLength > maxResponseSize) {\n                        response.destroy();\n                        return reject(new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`));\n                    }\n                }\n                // if the response is compressed, we must handle it\n                // as buffer for allowing decompression later\n                let payload = isCompressed || isVectorTile ? new Array() : '';\n                const onData = isCompressed || isVectorTile\n                    ? (chunk) => { payload.push(chunk); }\n                    : (chunk) => { payload = `${payload}${chunk}`; };\n                const onEnd = (err) => {\n                    response.removeListener('data', onData);\n                    response.removeListener('end', onEnd);\n                    response.removeListener('error', onEnd);\n                    response.removeListener('aborted', onAbort);\n                    if (err != null) {\n                        return reject(new errors_1.ConnectionError(err.message));\n                    }\n                    resolve({\n                        body: isCompressed || isVectorTile ? Buffer.concat(payload) : payload,\n                        statusCode: response.statusCode,\n                        headers: response.headers\n                    });\n                };\n                const onAbort = () => {\n                    response.destroy();\n                    onEnd(new Error('Response aborted while reading the body'));\n                };\n                if (!isCompressed && !isVectorTile) {\n                    response.setEncoding('utf8');\n                }\n                this.diagnostic.emit('deserialization', null, options);\n                response.on('data', onData);\n                response.on('error', onEnd);\n                response.on('end', onEnd);\n                response.on('aborted', onAbort);\n            };\n            const onTimeout = () => {\n                cleanListeners();\n                this._openRequests--;\n                request.once('error', () => { }); // we need to catch the request aborted error\n                request.abort();\n                reject(new errors_1.TimeoutError('Request timed out'));\n            };\n            const onError = (err) => {\n                var _a, _b, _c, _d, _e, _f, _g, _h;\n                cleanListeners();\n                this._openRequests--;\n                let message = err.message;\n                // @ts-expect-error\n                if (err.code === 'ECONNRESET') {\n                    message += ` - Local: ${(_b = (_a = request.socket) === null || _a === void 0 ? void 0 : _a.localAddress) !== null && _b !== void 0 ? _b : 'unknown'}:${(_d = (_c = request.socket) === null || _c === void 0 ? void 0 : _c.localPort) !== null && _d !== void 0 ? _d : 'unknown'}, Remote: ${(_f = (_e = request.socket) === null || _e === void 0 ? void 0 : _e.remoteAddress) !== null && _f !== void 0 ? _f : 'unknown'}:${(_h = (_g = request.socket) === null || _g === void 0 ? void 0 : _g.remotePort) !== null && _h !== void 0 ? _h : 'unknown'}`;\n                }\n                reject(new errors_1.ConnectionError(message));\n            };\n            const onAbort = () => {\n                cleanListeners();\n                request.once('error', () => { }); // we need to catch the request aborted error\n                debug('Request aborted', params);\n                this._openRequests--;\n                reject(new errors_1.RequestAbortedError('Request aborted'));\n            };\n            const onSocket = (socket) => {\n                /* istanbul ignore else */\n                if (!socket.isSessionReused()) {\n                    socket.once('secureConnect', () => {\n                        const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);\n                        /* istanbul ignore next */\n                        if (issuerCertificate == null) {\n                            onError(new Error('Invalid or malformed certificate'));\n                            request.once('error', () => { }); // we need to catch the request aborted error\n                            return request.abort();\n                        }\n                        // Check if fingerprint matches\n                        /* istanbul ignore else */\n                        if (this[symbols_1.kCaFingerprint] !== issuerCertificate.fingerprint256) {\n                            onError(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'));\n                            request.once('error', () => { }); // we need to catch the request aborted error\n                            return request.abort();\n                        }\n                    });\n                }\n            };\n            request.on('response', onResponse);\n            request.on('timeout', onTimeout);\n            request.on('error', onError);\n            request.on('abort', onAbort);\n            if (this[symbols_1.kCaFingerprint] != null && requestParams.protocol === 'https:') {\n                request.on('socket', onSocket);\n            }\n            // Disables the Nagle algorithm\n            request.setNoDelay(true);\n            // starts the request\n            if (isStream(params.body)) {\n                (0, stream_1.pipeline)(params.body, request, err => {\n                    /* istanbul ignore if  */\n                    if (err != null && !cleanedListeners) {\n                        cleanListeners();\n                        this._openRequests--;\n                        reject(err);\n                    }\n                });\n            }\n            else {\n                request.end(params.body);\n            }\n            return request;\n            function cleanListeners() {\n                request.removeListener('response', onResponse);\n                request.removeListener('timeout', onTimeout);\n                request.removeListener('error', onError);\n                request.removeListener('abort', onAbort);\n                request.removeListener('socket', onSocket);\n                if (options.signal != null) {\n                    if ('removeEventListener' in options.signal) {\n                        options.signal.removeEventListener('abort', abortListener);\n                    }\n                    else {\n                        options.signal.removeListener('abort', abortListener);\n                    }\n                }\n                cleanedListeners = true;\n            }\n        });\n    }\n    async close() {\n        debug('Closing connection', this.id);\n        while (this._openRequests > 0) {\n            await sleep(1000);\n        }\n        /* istanbul ignore else */\n        if (this.agent !== undefined) {\n            this.agent.destroy();\n        }\n    }\n    buildRequestObject(params, options) {\n        var _a;\n        const url = this.url;\n        const request = {\n            protocol: url.protocol,\n            hostname: url.hostname[0] === '['\n                ? url.hostname.slice(1, -1)\n                : url.hostname,\n            hash: url.hash,\n            search: url.search,\n            pathname: url.pathname,\n            path: '',\n            href: url.href,\n            origin: url.origin,\n            // https://github.com/elastic/elasticsearch-js/issues/843\n            port: url.port !== '' ? url.port : undefined,\n            headers: this.headers,\n            agent: this.agent,\n            timeout: (_a = options.timeout) !== null && _a !== void 0 ? _a : this.timeout\n        };\n        const paramsKeys = Object.keys(params);\n        for (let i = 0, len = paramsKeys.length; i < len; i++) {\n            const key = paramsKeys[i];\n            if (key === 'path') {\n                request.pathname = resolve(request.pathname, params[key]);\n            }\n            else if (key === 'querystring' && Boolean(params[key])) {\n                if (request.search === '') {\n                    request.search = `?${params[key]}`;\n                }\n                else {\n                    request.search += `&${params[key]}`;\n                }\n            }\n            else if (key === 'headers') {\n                request.headers = Object.assign({}, request.headers, params.headers);\n            }\n            else {\n                // @ts-expect-error\n                request[key] = params[key];\n            }\n        }\n        request.path = request.pathname + request.search;\n        return request;\n    }\n}\nexports.default = HttpConnection;\nfunction isStream(obj) {\n    return obj != null && typeof obj.pipe === 'function';\n}\nfunction resolve(host, path) {\n    const hostEndWithSlash = host[host.length - 1] === '/';\n    const pathStartsWithSlash = path[0] === '/';\n    if (hostEndWithSlash && pathStartsWithSlash) {\n        return host + path.slice(1);\n    }\n    else if (hostEndWithSlash !== pathStartsWithSlash) {\n        return host + path;\n    }\n    else {\n        return host + '/' + path;\n    }\n}\n/* istanbul ignore next */\nfunction isHttpAgentOptions(opts) {\n    if (opts.keepAliveTimeout != null)\n        return false;\n    if (opts.keepAliveMaxTimeout != null)\n        return false;\n    if (opts.keepAliveTimeoutThreshold != null)\n        return false;\n    if (opts.pipelining != null)\n        return false;\n    if (opts.maxHeaderSize != null)\n        return false;\n    if (opts.connections != null)\n        return false;\n    return true;\n}\nasync function sleep(ms) {\n    return await new Promise((resolve) => setTimeout(resolve, ms));\n}\n//# sourceMappingURL=HttpConnection.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\n/* eslint-disable @typescript-eslint/restrict-template-expressions */\nconst events_1 = require(\"events\");\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst buffer_1 = (0, tslib_1.__importDefault)(require(\"buffer\"));\nconst BaseConnection_1 = (0, tslib_1.__importStar)(require(\"./BaseConnection\"));\nconst undici_1 = require(\"undici\");\nconst errors_1 = require(\"../errors\");\nconst symbols_1 = require(\"../symbols\");\nconst debug = (0, debug_1.default)('elasticsearch');\nconst INVALID_PATH_REGEX = /[^\\u0021-\\u00ff]/;\nconst MAX_BUFFER_LENGTH = buffer_1.default.constants.MAX_LENGTH;\nconst MAX_STRING_LENGTH = buffer_1.default.constants.MAX_STRING_LENGTH;\nclass Connection extends BaseConnection_1.default {\n    constructor(opts) {\n        var _b;\n        super(opts);\n        Object.defineProperty(this, \"pool\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (opts.proxy != null) {\n            throw new errors_1.ConfigurationError('Undici connection can\\'t work with proxies');\n        }\n        if (typeof opts.agent === 'function' || typeof opts.agent === 'boolean') {\n            throw new errors_1.ConfigurationError('Undici connection agent options can\\'t be a function or a boolean');\n        }\n        if (opts.agent != null && !isUndiciAgentOptions(opts.agent)) {\n            throw new errors_1.ConfigurationError('Bad agent configuration for Undici agent');\n        }\n        this[symbols_1.kEmitter] = new events_1.EventEmitter();\n        const undiciOptions = {\n            keepAliveTimeout: 600e3,\n            keepAliveMaxTimeout: 600e3,\n            keepAliveTimeoutThreshold: 1000,\n            pipelining: 1,\n            maxHeaderSize: 16384,\n            connections: 256,\n            headersTimeout: this.timeout,\n            bodyTimeout: this.timeout,\n            ...opts.agent\n        };\n        if (this[symbols_1.kCaFingerprint] !== null) {\n            const caFingerprint = this[symbols_1.kCaFingerprint];\n            const connector = (0, undici_1.buildConnector)(((_b = this.tls) !== null && _b !== void 0 ? _b : {}));\n            undiciOptions.connect = function (opts, cb) {\n                connector(opts, (err, socket) => {\n                    if (err != null) {\n                        return cb(err, null);\n                    }\n                    if (caFingerprint !== null && isTlsSocket(opts, socket)) {\n                        const issuerCertificate = (0, BaseConnection_1.getIssuerCertificate)(socket);\n                        /* istanbul ignore next */\n                        if (issuerCertificate == null) {\n                            socket.destroy();\n                            return cb(new Error('Invalid or malformed certificate'), null);\n                        }\n                        // Check if fingerprint matches\n                        /* istanbul ignore else */\n                        if (caFingerprint !== issuerCertificate.fingerprint256) {\n                            socket.destroy();\n                            return cb(new Error('Server certificate CA fingerprint does not match the value configured in caFingerprint'), null);\n                        }\n                    }\n                    return cb(null, socket);\n                });\n            };\n        }\n        else if (this.tls !== null) {\n            undiciOptions.connect = this.tls;\n        }\n        this.pool = new undici_1.Pool(this.url.toString(), undiciOptions);\n    }\n    async request(params, options) {\n        var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        const maxResponseSize = (_b = options.maxResponseSize) !== null && _b !== void 0 ? _b : MAX_STRING_LENGTH;\n        const maxCompressedResponseSize = (_c = options.maxCompressedResponseSize) !== null && _c !== void 0 ? _c : MAX_BUFFER_LENGTH;\n        const requestParams = {\n            method: params.method,\n            path: params.path + (params.querystring == null || params.querystring === '' ? '' : `?${params.querystring}`),\n            headers: Object.assign({}, this.headers, params.headers),\n            body: params.body,\n            signal: (_d = options.signal) !== null && _d !== void 0 ? _d : this[symbols_1.kEmitter]\n        };\n        if (requestParams.path[0] !== '/') {\n            requestParams.path = `/${requestParams.path}`;\n        }\n        // undici does not support per-request timeouts,\n        // to address this issue, we default to the constructor\n        // timeout (which is handled by undici) and create a local\n        // setTimeout callback if the request-specific timeout\n        // is different from the constructor timeout.\n        let timedout = false;\n        let timeoutId;\n        if (options.timeout != null && options.timeout !== this.timeout) {\n            timeoutId = setTimeout(() => {\n                timedout = true;\n                if (options.signal != null) {\n                    options.signal.dispatchEvent('abort');\n                }\n                else {\n                    this[symbols_1.kEmitter].emit('abort');\n                }\n            }, options.timeout);\n        }\n        // https://github.com/nodejs/node/commit/b961d9fd83\n        if (INVALID_PATH_REGEX.test(requestParams.path)) {\n            throw new TypeError(`ERR_UNESCAPED_CHARACTERS: ${requestParams.path}`);\n        }\n        debug('Starting a new request', params);\n        let response;\n        try {\n            // @ts-expect-error method it's fine as string\n            response = (await this.pool.request(requestParams));\n            if (timeoutId != null)\n                clearTimeout(timeoutId);\n        }\n        catch (err) {\n            if (timeoutId != null)\n                clearTimeout(timeoutId);\n            switch (err.code) {\n                case 'UND_ERR_ABORTED':\n                    throw (timedout ? new errors_1.TimeoutError('Request timed out') : new errors_1.RequestAbortedError('Request aborted'));\n                case 'UND_ERR_HEADERS_TIMEOUT':\n                    throw new errors_1.TimeoutError('Request timed out');\n                case 'UND_ERR_SOCKET':\n                    throw new errors_1.ConnectionError(`${err.message} - Local: ${(_f = (_e = err.socket) === null || _e === void 0 ? void 0 : _e.localAddress) !== null && _f !== void 0 ? _f : 'unknown'}:${(_h = (_g = err.socket) === null || _g === void 0 ? void 0 : _g.localPort) !== null && _h !== void 0 ? _h : 'unknown'}, Remote: ${(_k = (_j = err.socket) === null || _j === void 0 ? void 0 : _j.remoteAddress) !== null && _k !== void 0 ? _k : 'unknown'}:${(_m = (_l = err.socket) === null || _l === void 0 ? void 0 : _l.remotePort) !== null && _m !== void 0 ? _m : 'unknown'}`); // eslint-disable-line\n                default:\n                    throw new errors_1.ConnectionError(err.message);\n            }\n        }\n        if (options.asStream === true) {\n            return {\n                statusCode: response.statusCode,\n                headers: response.headers,\n                body: response.body\n            };\n        }\n        const contentEncoding = ((_o = response.headers['content-encoding']) !== null && _o !== void 0 ? _o : '').toLowerCase();\n        const isCompressed = contentEncoding.includes('gzip') || contentEncoding.includes('deflate'); // eslint-disable-line\n        const isVectorTile = ((_p = response.headers['content-type']) !== null && _p !== void 0 ? _p : '').includes('application/vnd.mapbox-vector-tile');\n        /* istanbul ignore else */\n        if (response.headers['content-length'] !== undefined) {\n            const contentLength = Number(response.headers['content-length']);\n            if (isCompressed && contentLength > maxCompressedResponseSize) { // eslint-disable-line\n                response.body.destroy();\n                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed buffer (${maxCompressedResponseSize})`);\n            }\n            else if (contentLength > maxResponseSize) {\n                response.body.destroy();\n                throw new errors_1.RequestAbortedError(`The content length (${contentLength}) is bigger than the maximum allowed string (${maxResponseSize})`);\n            }\n        }\n        this.diagnostic.emit('deserialization', null, options);\n        try {\n            if (isCompressed || isVectorTile) { // eslint-disable-line\n                return {\n                    statusCode: response.statusCode,\n                    headers: response.headers,\n                    body: Buffer.from(await response.body.arrayBuffer())\n                };\n            }\n            else {\n                return {\n                    statusCode: response.statusCode,\n                    headers: response.headers,\n                    body: await response.body.text()\n                };\n            }\n        }\n        catch (err) {\n            throw new errors_1.ConnectionError(err.message);\n        }\n    }\n    async close() {\n        debug('Closing connection', this.id);\n        await this.pool.close();\n    }\n}\nexports.default = Connection;\n_a = symbols_1.kEmitter;\n/* istanbul ignore next */\nfunction isUndiciAgentOptions(opts) {\n    if (opts.keepAlive != null)\n        return false;\n    if (opts.keepAliveMsecs != null)\n        return false;\n    if (opts.maxSockets != null)\n        return false;\n    if (opts.maxFreeSockets != null)\n        return false;\n    if (opts.scheduling != null)\n        return false;\n    if (opts.proxy != null)\n        return false;\n    return true;\n}\nfunction isTlsSocket(opts, socket) {\n    return socket !== null && opts.protocol === 'https:';\n}\n//# sourceMappingURL=UndiciConnection.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the 'License'); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UndiciConnection = exports.HttpConnection = exports.BaseConnection = void 0;\nconst tslib_1 = require(\"tslib\");\nconst BaseConnection_1 = (0, tslib_1.__importDefault)(require(\"./BaseConnection\"));\nexports.BaseConnection = BaseConnection_1.default;\nconst HttpConnection_1 = (0, tslib_1.__importDefault)(require(\"./HttpConnection\"));\nexports.HttpConnection = HttpConnection_1.default;\nconst UndiciConnection_1 = (0, tslib_1.__importDefault)(require(\"./UndiciConnection\"));\nexports.UndiciConnection = UndiciConnection_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProductNotSupportedError = exports.RequestAbortedError = exports.ResponseError = exports.ConfigurationError = exports.DeserializationError = exports.SerializationError = exports.NoLivingConnectionsError = exports.ConnectionError = exports.TimeoutError = exports.ElasticsearchClientError = void 0;\nclass ElasticsearchClientError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = 'ElasticsearchClientError';\n    }\n}\nexports.ElasticsearchClientError = ElasticsearchClientError;\nclass TimeoutError extends ElasticsearchClientError {\n    constructor(message, meta) {\n        super(message);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, TimeoutError);\n        this.name = 'TimeoutError';\n        this.message = message !== null && message !== void 0 ? message : 'Timeout Error';\n        this.meta = meta;\n    }\n}\nexports.TimeoutError = TimeoutError;\nclass ConnectionError extends ElasticsearchClientError {\n    constructor(message, meta) {\n        super(message);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ConnectionError);\n        this.name = 'ConnectionError';\n        this.message = message !== null && message !== void 0 ? message : 'Connection Error';\n        this.meta = meta;\n    }\n}\nexports.ConnectionError = ConnectionError;\nclass NoLivingConnectionsError extends ElasticsearchClientError {\n    constructor(message, meta) {\n        super(message);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, NoLivingConnectionsError);\n        this.name = 'NoLivingConnectionsError';\n        this.message = message !== null && message !== void 0 ? message : 'Given the configuration, the ConnectionPool was not able to find a usable Connection for this request.';\n        this.meta = meta;\n    }\n}\nexports.NoLivingConnectionsError = NoLivingConnectionsError;\nclass SerializationError extends ElasticsearchClientError {\n    constructor(message, data) {\n        super(message);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, SerializationError);\n        this.name = 'SerializationError';\n        this.message = message !== null && message !== void 0 ? message : 'Serialization Error';\n        this.data = data;\n    }\n}\nexports.SerializationError = SerializationError;\nclass DeserializationError extends ElasticsearchClientError {\n    constructor(message, data) {\n        super(message);\n        Object.defineProperty(this, \"data\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, DeserializationError);\n        this.name = 'DeserializationError';\n        this.message = message !== null && message !== void 0 ? message : 'Deserialization Error';\n        this.data = data;\n    }\n}\nexports.DeserializationError = DeserializationError;\nclass ConfigurationError extends ElasticsearchClientError {\n    constructor(message) {\n        super(message);\n        Error.captureStackTrace(this, ConfigurationError);\n        this.name = 'ConfigurationError';\n        this.message = message !== null && message !== void 0 ? message : 'Configuration Error';\n    }\n}\nexports.ConfigurationError = ConfigurationError;\nclass ResponseError extends ElasticsearchClientError {\n    constructor(meta) {\n        var _a;\n        super('Response Error');\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ResponseError);\n        this.name = 'ResponseError';\n        // TODO: this is for Elasticsearch\n        if (isObject(meta.body) && meta.body.error != null && meta.body.error.type != null) {\n            if (Array.isArray(meta.body.error.root_cause)) {\n                this.message = meta.body.error.type + ': ';\n                this.message += meta.body.error.root_cause.map((entry) => `[${entry.type}] Reason: ${entry.reason}`).join('; ');\n            }\n            else {\n                this.message = meta.body.error.type;\n            }\n        }\n        else if (typeof meta.body === 'object' && meta.body != null) {\n            this.message = JSON.stringify(meta.body);\n        }\n        else {\n            this.message = (_a = meta.body) !== null && _a !== void 0 ? _a : 'Response Error';\n        }\n        this.meta = meta;\n    }\n    get body() {\n        return this.meta.body;\n    }\n    get statusCode() {\n        if (isObject(this.meta.body) && typeof this.meta.body.status === 'number') {\n            return this.meta.body.status;\n        }\n        return this.meta.statusCode;\n    }\n    get headers() {\n        return this.meta.headers;\n    }\n}\nexports.ResponseError = ResponseError;\nclass RequestAbortedError extends ElasticsearchClientError {\n    constructor(message, meta) {\n        super(message);\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, RequestAbortedError);\n        this.name = 'RequestAbortedError';\n        this.message = message !== null && message !== void 0 ? message : 'Request aborted';\n        this.meta = meta;\n    }\n}\nexports.RequestAbortedError = RequestAbortedError;\nclass ProductNotSupportedError extends ElasticsearchClientError {\n    constructor(product, meta) {\n        super('Product Not Supported Error');\n        Object.defineProperty(this, \"meta\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Error.captureStackTrace(this, ProductNotSupportedError);\n        this.name = 'ProductNotSupportedError';\n        this.message = `The client noticed that the server is not ${product} and we do not support this unknown product.`;\n        this.meta = meta;\n    }\n}\nexports.ProductNotSupportedError = ProductNotSupportedError;\nfunction isObject(obj) {\n    return typeof obj === 'object';\n}\n//# sourceMappingURL=errors.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst url_1 = require(\"url\");\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst Diagnostic_1 = (0, tslib_1.__importDefault)(require(\"../Diagnostic\"));\nconst symbols_1 = require(\"../symbols\");\nconst connection_1 = require(\"../connection\");\nconst errors_1 = require(\"../errors\");\nconst debug = (0, debug_1.default)('elasticsearch');\nclass BaseConnectionPool {\n    constructor(opts) {\n        var _b;\n        Object.defineProperty(this, \"connections\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"size\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"Connection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"diagnostic\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"auth\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_agent\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_proxy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_tls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _a, {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // list of nodes and weights\n        this.connections = [];\n        // how many nodes we have in our scheduler\n        this.size = this.connections.length;\n        this.Connection = opts.Connection;\n        this.diagnostic = (_b = opts.diagnostic) !== null && _b !== void 0 ? _b : new Diagnostic_1.default();\n        this.auth = opts.auth;\n        this._tls = opts.tls;\n        this._agent = opts.agent;\n        this._proxy = opts.proxy;\n        this[symbols_1.kCaFingerprint] = opts.caFingerprint;\n    }\n    markAlive(connection) {\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        return this;\n    }\n    markDead(connection) {\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        return this;\n    }\n    getConnection(opts) {\n        throw new errors_1.ConfigurationError('The getConnection method should be implemented by extended classes');\n    }\n    /**\n     * Creates a new connection instance.\n     */\n    createConnection(opts) {\n        if (typeof opts === 'string') {\n            opts = this.urlToHost(opts);\n        }\n        if (this.auth != null) {\n            opts.auth = this.auth;\n        }\n        else if (opts.url.username !== '' && opts.url.password !== '') {\n            opts.auth = {\n                username: decodeURIComponent(opts.url.username),\n                password: decodeURIComponent(opts.url.password)\n            };\n        }\n        /* istanbul ignore else */\n        if (opts.tls == null)\n            opts.tls = this._tls;\n        /* istanbul ignore else */\n        if (opts.agent == null)\n            opts.agent = this._agent;\n        /* istanbul ignore else */\n        if (opts.proxy == null)\n            opts.proxy = this._proxy;\n        /* istanbul ignore else */\n        if (opts.diagnostic == null)\n            opts.diagnostic = this.diagnostic;\n        /* istanbul ignore else */\n        if (opts.caFingerprint == null)\n            opts.caFingerprint = this[symbols_1.kCaFingerprint];\n        const connection = new this.Connection(opts);\n        for (const conn of this.connections) {\n            if (conn.id === connection.id) {\n                throw new Error(`Connection with id '${connection.id}' is already present`);\n            }\n        }\n        return connection;\n    }\n    /**\n     * Adds a new connection to the pool.\n     *\n     * @param {object|string} host\n     * @returns {ConnectionPool}\n     */\n    addConnection(connection) {\n        if (Array.isArray(connection)) {\n            const connections = [];\n            for (const conn of connection) {\n                connections.push(this.createConnection(conn));\n            }\n            return this.update([...this.connections, ...connections]);\n        }\n        else {\n            return this.update([...this.connections, this.createConnection(connection)]);\n        }\n    }\n    /**\n     * Removes a new connection to the pool.\n     *\n     * @param {object} connection\n     * @returns {ConnectionPool}\n     */\n    removeConnection(connection) {\n        debug('Removing connection', connection);\n        return this.update(this.connections.filter(c => c.id !== connection.id));\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        debug('Emptying the connection pool');\n        const connections = this.connections;\n        this.connections = [];\n        this.size = 0;\n        for (const connection of connections) {\n            await connection.close();\n        }\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(nodes) {\n        debug('Updating the connection pool');\n        const newConnections = [];\n        const oldConnections = [];\n        for (const node of nodes) {\n            // if we already have a given connection in the pool\n            // we mark it as alive and we do not close the connection\n            // to avoid socket issues\n            const connectionById = this.connections.find(c => c.id === node.id);\n            const connectionByUrl = this.connections.find(c => c.id === node.url.href);\n            if (connectionById != null) {\n                debug(`The connection with id '${node.id}' is already present`);\n                this.markAlive(connectionById);\n                newConnections.push(connectionById);\n                // in case the user has passed a single url (or an array of urls),\n                // the connection id will be the full href; to avoid closing valid connections\n                // because are not present in the pool, we check also the node url,\n                // and if is already present we update its id with the ES provided one.\n            }\n            else if (connectionByUrl != null) {\n                connectionByUrl.id = node.id;\n                this.markAlive(connectionByUrl);\n                newConnections.push(connectionByUrl);\n            }\n            else {\n                if (node instanceof connection_1.BaseConnection) {\n                    newConnections.push(node);\n                }\n                else {\n                    newConnections.push(this.createConnection(node));\n                }\n            }\n        }\n        const ids = nodes.map(c => c.id);\n        // remove all the dead connections and old connections\n        for (const connection of this.connections) {\n            if (!ids.includes(connection.id)) {\n                oldConnections.push(connection);\n            }\n        }\n        // close old connections\n        for (const connection of oldConnections) {\n            connection.close().catch(/* istanbul ignore next */ () => { });\n        }\n        this.connections = newConnections;\n        this.size = this.connections.length;\n        return this;\n    }\n    /**\n     * Transforms the nodes objects to a host object.\n     *\n     * @param {object} nodes\n     * @returns {array} hosts\n     */\n    nodesToHost(nodes, protocol) {\n        const ids = Object.keys(nodes);\n        const hosts = [];\n        for (let i = 0, len = ids.length; i < len; i++) {\n            const node = nodes[ids[i]];\n            // If there is no protocol in\n            // the `publish_address` new URL will throw\n            // the publish_address can have two forms:\n            //   - ip:port\n            //   - hostname/ip:port\n            // if we encounter the second case, we should\n            // use the hostname instead of the ip\n            let address = node.http.publish_address;\n            const parts = address.split('/');\n            // the url is in the form of hostname/ip:port\n            if (parts.length > 1) {\n                const hostname = parts[0];\n                const port = parts[1].match(/((?::))(?:[0-9]+)$/g)[0].slice(1);\n                address = `${hostname}:${port}`;\n            }\n            address = address.slice(0, 4) === 'http'\n                /* istanbul ignore next */\n                ? address\n                : `${protocol}//${address}`;\n            hosts.push({\n                url: new url_1.URL(address),\n                id: ids[i]\n            });\n        }\n        return hosts;\n    }\n    /**\n     * Transforms an url string to a host object\n     *\n     * @param {string} url\n     * @returns {object} host\n     */\n    urlToHost(url) {\n        return {\n            url: new url_1.URL(url)\n        };\n    }\n}\nexports.default = BaseConnectionPool;\n_a = symbols_1.kCaFingerprint;\n//# sourceMappingURL=BaseConnectionPool.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst BaseConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./BaseConnectionPool\"));\nclass CloudConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"cloudConnection\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.cloudConnection = null;\n    }\n    /**\n     * Returns the only cloud connection.\n     *\n     * @returns {object} connection\n     */\n    getConnection(opts) {\n        return this.cloudConnection;\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.cloudConnection = null;\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.cloudConnection = this.connections[0];\n        return this;\n    }\n}\nexports.default = CloudConnectionPool;\n//# sourceMappingURL=CloudConnectionPool.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst BaseConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./BaseConnectionPool\"));\nconst assert_1 = (0, tslib_1.__importDefault)(require(\"assert\"));\nconst debug_1 = (0, tslib_1.__importDefault)(require(\"debug\"));\nconst connection_1 = require(\"../connection\");\nconst debug = (0, debug_1.default)('elasticsearch');\nclass ClusterConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        var _a, _b;\n        super(opts);\n        Object.defineProperty(this, \"dead\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectTimeoutCutoff\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"pingTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"resurrectStrategy\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.dead = [];\n        // the resurrect timeout is 60s\n        this.resurrectTimeout = 1000 * 60;\n        // number of consecutive failures after which\n        // the timeout doesn't increase\n        this.resurrectTimeoutCutoff = 5;\n        this.pingTimeout = (_a = opts.pingTimeout) !== null && _a !== void 0 ? _a : 3000;\n        const resurrectStrategy = (_b = opts.resurrectStrategy) !== null && _b !== void 0 ? _b : 'ping';\n        this.resurrectStrategy = ClusterConnectionPool.resurrectStrategies[resurrectStrategy];\n        (0, assert_1.default)(this.resurrectStrategy != null, `Invalid resurrection strategy: '${resurrectStrategy}'`);\n    }\n    /**\n     * Marks a connection as 'alive'.\n     * If needed removes the connection from the dead list\n     * and then resets the `deadCount`.\n     *\n     * @param {object} connection\n     */\n    markAlive(connection) {\n        const { id } = connection;\n        debug(`Marking as 'alive' connection '${id}'`);\n        const index = this.dead.indexOf(id);\n        if (index > -1)\n            this.dead.splice(index, 1);\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        connection.deadCount = 0;\n        connection.resurrectTimeout = 0;\n        return this;\n    }\n    /**\n     * Marks a connection as 'dead'.\n     * If needed adds the connection to the dead list\n     * and then increments the `deadCount`.\n     *\n     * @param {object} connection\n     */\n    markDead(connection) {\n        const { id } = connection;\n        debug(`Marking as 'dead' connection '${id}'`);\n        if (!this.dead.includes(id)) {\n            // It might happen that `markDead` is called jsut after\n            // a pool update, and in such case we will add to the dead\n            // list a node that no longer exist. The following check verify\n            // that the connection is still part of the pool before\n            // marking it as dead.\n            for (let i = 0; i < this.size; i++) {\n                if (this.connections[i].id === id) {\n                    this.dead.push(id);\n                    break;\n                }\n            }\n        }\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        connection.deadCount++;\n        // resurrectTimeout formula:\n        // `resurrectTimeout * 2 ** min(deadCount - 1, resurrectTimeoutCutoff)`\n        connection.resurrectTimeout = Date.now() + this.resurrectTimeout * Math.pow(2, Math.min(connection.deadCount - 1, this.resurrectTimeoutCutoff));\n        // sort the dead list in ascending order\n        // based on the resurrectTimeout\n        this.dead.sort((a, b) => {\n            const conn1 = this.connections.find(c => c.id === a);\n            const conn2 = this.connections.find(c => c.id === b);\n            return conn1.resurrectTimeout - conn2.resurrectTimeout;\n        });\n        return this;\n    }\n    /**\n     * If enabled, tries to resurrect a connection with the given\n     * resurrect strategy ('ping', 'optimistic', 'none').\n     *\n     * @param {object} { now, requestId }\n     */\n    resurrect(opts) {\n        if (this.resurrectStrategy === 0 || this.dead.length === 0) {\n            debug('Nothing to resurrect');\n            return;\n        }\n        // the dead list is sorted in ascending order based on the timeout\n        // so the first element will always be the one with the smaller timeout\n        const connection = this.connections.find(c => c.id === this.dead[0]);\n        if (opts.now < connection.resurrectTimeout) {\n            debug('Nothing to resurrect');\n            return;\n        }\n        const { id } = connection;\n        // ping strategy\n        if (this.resurrectStrategy === 1) {\n            connection.request({ method: 'HEAD', path: '/' }, { timeout: this.pingTimeout, requestId: opts.requestId, name: opts.name, context: opts.context })\n                .then(({ statusCode }) => {\n                let isAlive = true;\n                if (statusCode === 502 || statusCode === 503 || statusCode === 504) {\n                    debug(`Resurrect: connection '${id}' is still dead`);\n                    this.markDead(connection);\n                    isAlive = false;\n                }\n                else {\n                    debug(`Resurrect: connection '${id}' is now alive`);\n                    this.markAlive(connection);\n                }\n                this.diagnostic.emit('resurrect', null, {\n                    strategy: 'ping',\n                    name: opts.name,\n                    request: { id: opts.requestId },\n                    isAlive,\n                    connection\n                });\n            })\n                .catch((err) => {\n                this.markDead(connection);\n                this.diagnostic.emit('resurrect', err, {\n                    strategy: 'ping',\n                    name: opts.name,\n                    request: { id: opts.requestId },\n                    isAlive: false,\n                    connection\n                });\n            });\n            // optimistic strategy\n        }\n        else {\n            debug(`Resurrect: optimistic resurrection for connection '${id}'`);\n            this.dead.splice(this.dead.indexOf(id), 1);\n            connection.status = connection_1.BaseConnection.statuses.ALIVE;\n            this.diagnostic.emit('resurrect', null, {\n                strategy: 'optimistic',\n                name: opts.name,\n                request: { id: opts.requestId },\n                isAlive: true,\n                connection\n            });\n        }\n    }\n    /**\n     * Returns an alive connection if present,\n     * otherwise returns a dead connection.\n     * By default it filters the `master` only nodes.\n     * It uses the selector to choose which\n     * connection return.\n     *\n     * @param {object} options (filter and selector)\n     * @returns {object|null} connection\n     */\n    getConnection(opts) {\n        const filter = opts.filter != null ? opts.filter : () => true;\n        const selector = opts.selector != null ? opts.selector : (c) => c[0];\n        this.resurrect({\n            now: opts.now,\n            requestId: opts.requestId,\n            name: opts.name,\n            context: opts.context\n        });\n        const noAliveConnections = this.size === this.dead.length;\n        // TODO: can we cache this?\n        const connections = [];\n        for (let i = 0; i < this.size; i++) {\n            const connection = this.connections[i];\n            if (noAliveConnections || connection.status === connection_1.BaseConnection.statuses.ALIVE) {\n                if (filter(connection)) {\n                    connections.push(connection);\n                }\n            }\n        }\n        if (connections.length === 0)\n            return null;\n        return selector(connections);\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.dead = [];\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.dead = [];\n        return this;\n    }\n}\nexports.default = ClusterConnectionPool;\nObject.defineProperty(ClusterConnectionPool, \"resurrectStrategies\", {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: {\n        none: 0,\n        ping: 1,\n        optimistic: 2\n    }\n});\n//# sourceMappingURL=ClusterConnectionPool.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst tslib_1 = require(\"tslib\");\nconst connection_1 = require(\"../connection\");\nconst BaseConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./BaseConnectionPool\"));\nconst noFilter = () => true;\nclass WeightedConnectionPool extends BaseConnectionPool_1.default {\n    constructor(opts) {\n        super(opts);\n        Object.defineProperty(this, \"index\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"maxWeight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"greatestCommonDivisor\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"currentWeight\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // index choosen last time\n        this.index = -1;\n        // max weight of all nodes\n        this.maxWeight = 0;\n        // greatest common divisor of all nodes weights\n        this.greatestCommonDivisor = 0;\n        // current weight in scheduling\n        this.currentWeight = 0;\n    }\n    /**\n     * Returns a connection, even if the connection might be dead.\n     *\n     * @param {object} options (filter)\n     * @returns {object|null} connection\n     */\n    getConnection(opts) {\n        const filter = opts.filter != null ? opts.filter : noFilter;\n        // we should be able to find the next node in 1 array scan,\n        // if we don't, it means that we are in an infinite loop\n        let counter = 0;\n        while (counter++ < this.size) {\n            // 0 <= index < size\n            this.index = (this.index + 1) % this.size;\n            if (this.index === 0) {\n                this.currentWeight = this.currentWeight - this.greatestCommonDivisor;\n                if (this.currentWeight <= 0) {\n                    this.currentWeight = this.maxWeight;\n                    /* istanbul ignore if */\n                    if (this.currentWeight === 0) {\n                        return null;\n                    }\n                }\n            }\n            const connection = this.connections[this.index];\n            if (connection.weight >= this.currentWeight && filter(connection)) {\n                return connection;\n            }\n        }\n        return null;\n    }\n    /**\n     * Set the weight of a connection to the maximum value.\n     * If sniffing is not enabled and there is only\n     * one node, this method is a noop.\n     *\n     * @param {object} connection\n     */\n    markAlive(connection) {\n        if (this.size === 1 || connection.status === connection_1.BaseConnection.statuses.ALIVE)\n            return this;\n        connection.status = connection_1.BaseConnection.statuses.ALIVE;\n        connection.deadCount = 0;\n        connection.weight = Math.round(1000 / this.size);\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        return this;\n    }\n    /**\n     * Decreases the connection weight.\n     * If sniffing is not enabled and there is only\n     * one node, this method is a noop.\n     *\n     * @param {object} connection\n     */\n    markDead(connection) {\n        if (this.size === 1)\n            return this;\n        connection.status = connection_1.BaseConnection.statuses.DEAD;\n        connection.deadCount++;\n        connection.weight -= Math.round(Math.pow(Math.log2(connection.weight), connection.deadCount));\n        /* istanbul ignore if */\n        if (connection.weight <= 0)\n            connection.weight = 1;\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        return this;\n    }\n    /**\n     * Empties the connection pool.\n     *\n     * @returns {ConnectionPool}\n     */\n    async empty() {\n        await super.empty();\n        this.maxWeight = 0;\n        this.greatestCommonDivisor = 0;\n        this.index = -1;\n        this.currentWeight = 0;\n    }\n    /**\n     * Update the ConnectionPool with new connections.\n     *\n     * @param {array} array of connections\n     * @returns {ConnectionPool}\n     */\n    update(connections) {\n        super.update(connections);\n        this.connections.forEach(connection => {\n            connection.weight = Math.round(1000 / this.size);\n        });\n        this.maxWeight = Math.max(...(this.connections.map(c => c.weight)));\n        this.greatestCommonDivisor = this.connections.map(c => c.weight).reduce(getGreatestCommonDivisor, 0);\n        this.index = -1;\n        this.currentWeight = 0;\n        return this;\n    }\n}\nexports.default = WeightedConnectionPool;\nfunction getGreatestCommonDivisor(a, b) {\n    if (b === 0)\n        return a;\n    return getGreatestCommonDivisor(b, a % b);\n}\n//# sourceMappingURL=WeightedConnectionPool.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the 'License'); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * 'AS IS' BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CloudConnectionPool = exports.ClusterConnectionPool = exports.WeightedConnectionPool = exports.BaseConnectionPool = void 0;\nconst tslib_1 = require(\"tslib\");\nconst BaseConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./BaseConnectionPool\"));\nexports.BaseConnectionPool = BaseConnectionPool_1.default;\nconst WeightedConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./WeightedConnectionPool\"));\nexports.WeightedConnectionPool = WeightedConnectionPool_1.default;\nconst ClusterConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./ClusterConnectionPool\"));\nexports.ClusterConnectionPool = ClusterConnectionPool_1.default;\nconst CloudConnectionPool_1 = (0, tslib_1.__importDefault)(require(\"./CloudConnectionPool\"));\nexports.CloudConnectionPool = CloudConnectionPool_1.default;\n//# sourceMappingURL=index.js.map","\"use strict\";\n/*\n * Licensed to Elasticsearch B.V. under one or more contributor\n * license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch B.V. licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.kAcceptHeader = exports.kNdjsonContentType = exports.kJsonContentType = exports.kMaxCompressedResponseSize = exports.kMaxResponseSize = exports.kCaFingerprint = exports.kProductCheck = exports.kEmitter = exports.kStatus = exports.kJsonOptions = exports.kNodeSelector = exports.kNodeFilter = exports.kHeaders = exports.kDiagnostic = exports.kSerializer = exports.kConnectionPool = exports.kContext = exports.kGenerateRequestId = exports.kOpaqueIdPrefix = exports.kName = exports.kMaxRetries = exports.kCompression = exports.kRequestTimeout = exports.kSniffEndpoint = exports.kSniffOnConnectionFault = exports.kSniffInterval = exports.kIsSniffing = exports.kNextSniff = exports.kSniffEnabled = void 0;\nexports.kSniffEnabled = Symbol('sniff enabled');\nexports.kNextSniff = Symbol('next sniff');\nexports.kIsSniffing = Symbol('is sniffing');\nexports.kSniffInterval = Symbol('sniff interval');\nexports.kSniffOnConnectionFault = Symbol('sniff on connection fault');\nexports.kSniffEndpoint = Symbol('sniff endpoint');\nexports.kRequestTimeout = Symbol('request timeout');\nexports.kCompression = Symbol('compression');\nexports.kMaxRetries = Symbol('max retries');\nexports.kName = Symbol('name');\nexports.kOpaqueIdPrefix = Symbol('opaque id prefix');\nexports.kGenerateRequestId = Symbol('generate request id');\nexports.kContext = Symbol('context');\nexports.kConnectionPool = Symbol('connection pool');\nexports.kSerializer = Symbol('serializer');\nexports.kDiagnostic = Symbol('diagnostics');\nexports.kHeaders = Symbol('headers');\nexports.kNodeFilter = Symbol('node filter');\nexports.kNodeSelector = Symbol('node selector');\nexports.kJsonOptions = Symbol('secure json parse options');\nexports.kStatus = Symbol('status');\nexports.kEmitter = Symbol('event emitter');\nexports.kProductCheck = Symbol('product check');\nexports.kCaFingerprint = Symbol('ca fingerprint');\nexports.kMaxResponseSize = Symbol('max response size');\nexports.kMaxCompressedResponseSize = Symbol('max compressed response size');\nexports.kJsonContentType = Symbol('json content type');\nexports.kNdjsonContentType = Symbol('ndjson content type');\nexports.kAcceptHeader = Symbol('accept header');\n//# sourceMappingURL=symbols.js.map","module.exports = require('./lib/axios');","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar buildFullPath = require('../core/buildFullPath');\nvar buildURL = require('./../helpers/buildURL');\nvar http = require('http');\nvar https = require('https');\nvar httpFollow = require('follow-redirects').http;\nvar httpsFollow = require('follow-redirects').https;\nvar url = require('url');\nvar zlib = require('zlib');\nvar VERSION = require('./../env/data').version;\nvar createError = require('../core/createError');\nvar enhanceError = require('../core/enhanceError');\nvar defaults = require('../defaults');\nvar Cancel = require('../cancel/Cancel');\n\nvar isHttps = /https:?/;\n\n/**\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} proxy\n * @param {string} location\n */\nfunction setProxy(options, proxy, location) {\n  options.hostname = proxy.host;\n  options.host = proxy.host;\n  options.port = proxy.port;\n  options.path = location;\n\n  // Basic proxy authorization\n  if (proxy.auth) {\n    var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');\n    options.headers['Proxy-Authorization'] = 'Basic ' + base64;\n  }\n\n  // If a proxy is used, any redirects must also pass through the proxy\n  options.beforeRedirect = function beforeRedirect(redirection) {\n    redirection.headers.host = redirection.host;\n    setProxy(redirection, proxy, redirection.href);\n  };\n}\n\n/*eslint consistent-return:0*/\nmodule.exports = function httpAdapter(config) {\n  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n    var resolve = function resolve(value) {\n      done();\n      resolvePromise(value);\n    };\n    var rejected = false;\n    var reject = function reject(value) {\n      done();\n      rejected = true;\n      rejectPromise(value);\n    };\n    var data = config.data;\n    var headers = config.headers;\n    var headerNames = {};\n\n    Object.keys(headers).forEach(function storeLowerName(name) {\n      headerNames[name.toLowerCase()] = name;\n    });\n\n    // Set User-Agent (required by some servers)\n    // See https://github.com/axios/axios/issues/69\n    if ('user-agent' in headerNames) {\n      // User-Agent is specified; handle case where no UA header is desired\n      if (!headers[headerNames['user-agent']]) {\n        delete headers[headerNames['user-agent']];\n      }\n      // Otherwise, use specified value\n    } else {\n      // Only set header if it hasn't been set in config\n      headers['User-Agent'] = 'axios/' + VERSION;\n    }\n\n    if (data && !utils.isStream(data)) {\n      if (Buffer.isBuffer(data)) {\n        // Nothing to do...\n      } else if (utils.isArrayBuffer(data)) {\n        data = Buffer.from(new Uint8Array(data));\n      } else if (utils.isString(data)) {\n        data = Buffer.from(data, 'utf-8');\n      } else {\n        return reject(createError(\n          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',\n          config\n        ));\n      }\n\n      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {\n        return reject(createError('Request body larger than maxBodyLength limit', config));\n      }\n\n      // Add Content-Length header if data exists\n      if (!headerNames['content-length']) {\n        headers['Content-Length'] = data.length;\n      }\n    }\n\n    // HTTP basic authentication\n    var auth = undefined;\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password || '';\n      auth = username + ':' + password;\n    }\n\n    // Parse url\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    var parsed = url.parse(fullPath);\n    var protocol = parsed.protocol || 'http:';\n\n    if (!auth && parsed.auth) {\n      var urlAuth = parsed.auth.split(':');\n      var urlUsername = urlAuth[0] || '';\n      var urlPassword = urlAuth[1] || '';\n      auth = urlUsername + ':' + urlPassword;\n    }\n\n    if (auth && headerNames.authorization) {\n      delete headers[headerNames.authorization];\n    }\n\n    var isHttpsRequest = isHttps.test(protocol);\n    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;\n\n    try {\n      buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, '');\n    } catch (err) {\n      var customErr = new Error(err.message);\n      customErr.config = config;\n      customErr.url = config.url;\n      customErr.exists = true;\n      reject(customErr);\n    }\n\n    var options = {\n      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\\?/, ''),\n      method: config.method.toUpperCase(),\n      headers: headers,\n      agent: agent,\n      agents: { http: config.httpAgent, https: config.httpsAgent },\n      auth: auth\n    };\n\n    if (config.socketPath) {\n      options.socketPath = config.socketPath;\n    } else {\n      options.hostname = parsed.hostname;\n      options.port = parsed.port;\n    }\n\n    var proxy = config.proxy;\n    if (!proxy && proxy !== false) {\n      var proxyEnv = protocol.slice(0, -1) + '_proxy';\n      var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];\n      if (proxyUrl) {\n        var parsedProxyUrl = url.parse(proxyUrl);\n        var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;\n        var shouldProxy = true;\n\n        if (noProxyEnv) {\n          var noProxy = noProxyEnv.split(',').map(function trim(s) {\n            return s.trim();\n          });\n\n          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {\n            if (!proxyElement) {\n              return false;\n            }\n            if (proxyElement === '*') {\n              return true;\n            }\n            if (proxyElement[0] === '.' &&\n                parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {\n              return true;\n            }\n\n            return parsed.hostname === proxyElement;\n          });\n        }\n\n        if (shouldProxy) {\n          proxy = {\n            host: parsedProxyUrl.hostname,\n            port: parsedProxyUrl.port,\n            protocol: parsedProxyUrl.protocol\n          };\n\n          if (parsedProxyUrl.auth) {\n            var proxyUrlAuth = parsedProxyUrl.auth.split(':');\n            proxy.auth = {\n              username: proxyUrlAuth[0],\n              password: proxyUrlAuth[1]\n            };\n          }\n        }\n      }\n    }\n\n    if (proxy) {\n      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');\n      setProxy(options, proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);\n    }\n\n    var transport;\n    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);\n    if (config.transport) {\n      transport = config.transport;\n    } else if (config.maxRedirects === 0) {\n      transport = isHttpsProxy ? https : http;\n    } else {\n      if (config.maxRedirects) {\n        options.maxRedirects = config.maxRedirects;\n      }\n      transport = isHttpsProxy ? httpsFollow : httpFollow;\n    }\n\n    if (config.maxBodyLength > -1) {\n      options.maxBodyLength = config.maxBodyLength;\n    }\n\n    if (config.insecureHTTPParser) {\n      options.insecureHTTPParser = config.insecureHTTPParser;\n    }\n\n    // Create the request\n    var req = transport.request(options, function handleResponse(res) {\n      if (req.aborted) return;\n\n      // uncompress the response body transparently if required\n      var stream = res;\n\n      // return the last request in case of redirects\n      var lastRequest = res.req || req;\n\n\n      // if no content, is HEAD request or decompress disabled we should not decompress\n      if (res.statusCode !== 204 && lastRequest.method !== 'HEAD' && config.decompress !== false) {\n        switch (res.headers['content-encoding']) {\n        /*eslint default-case:0*/\n        case 'gzip':\n        case 'compress':\n        case 'deflate':\n        // add the unzipper to the body stream processing pipeline\n          stream = stream.pipe(zlib.createUnzip());\n\n          // remove the content-encoding in order to not confuse downstream operations\n          delete res.headers['content-encoding'];\n          break;\n        }\n      }\n\n      var response = {\n        status: res.statusCode,\n        statusText: res.statusMessage,\n        headers: res.headers,\n        config: config,\n        request: lastRequest\n      };\n\n      if (config.responseType === 'stream') {\n        response.data = stream;\n        settle(resolve, reject, response);\n      } else {\n        var responseBuffer = [];\n        var totalResponseBytes = 0;\n        stream.on('data', function handleStreamData(chunk) {\n          responseBuffer.push(chunk);\n          totalResponseBytes += chunk.length;\n\n          // make sure the content length is not over the maxContentLength if specified\n          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {\n            // stream.destoy() emit aborted event before calling reject() on Node.js v16\n            rejected = true;\n            stream.destroy();\n            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded',\n              config, null, lastRequest));\n          }\n        });\n\n        stream.on('aborted', function handlerStreamAborted() {\n          if (rejected) {\n            return;\n          }\n          stream.destroy();\n          reject(createError('error request aborted', config, 'ERR_REQUEST_ABORTED', lastRequest));\n        });\n\n        stream.on('error', function handleStreamError(err) {\n          if (req.aborted) return;\n          reject(enhanceError(err, config, null, lastRequest));\n        });\n\n        stream.on('end', function handleStreamEnd() {\n          try {\n            var responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);\n            if (config.responseType !== 'arraybuffer') {\n              responseData = responseData.toString(config.responseEncoding);\n              if (!config.responseEncoding || config.responseEncoding === 'utf8') {\n                responseData = utils.stripBOM(responseData);\n              }\n            }\n            response.data = responseData;\n          } catch (err) {\n            reject(enhanceError(err, config, err.code, response.request, response));\n          }\n          settle(resolve, reject, response);\n        });\n      }\n    });\n\n    // Handle errors\n    req.on('error', function handleRequestError(err) {\n      if (req.aborted && err.code !== 'ERR_FR_TOO_MANY_REDIRECTS') return;\n      reject(enhanceError(err, config, null, req));\n    });\n\n    // set tcp keep alive to prevent drop connection by peer\n    req.on('socket', function handleRequestSocket(socket) {\n      // default interval of sending ack packet is 1 minute\n      socket.setKeepAlive(true, 1000 * 60);\n    });\n\n    // Handle request timeout\n    if (config.timeout) {\n      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.\n      var timeout = parseInt(config.timeout, 10);\n\n      if (isNaN(timeout)) {\n        reject(createError(\n          'error trying to parse `config.timeout` to int',\n          config,\n          'ERR_PARSE_TIMEOUT',\n          req\n        ));\n\n        return;\n      }\n\n      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.\n      // And timer callback will be fired, and abort() will be invoked before connection, then get \"socket hang up\" and code ECONNRESET.\n      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.\n      // And then these socket which be hang up will devoring CPU little by little.\n      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.\n      req.setTimeout(timeout, function handleRequestTimeout() {\n        req.abort();\n        var timeoutErrorMessage = '';\n        if (config.timeoutErrorMessage) {\n          timeoutErrorMessage = config.timeoutErrorMessage;\n        } else {\n          timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';\n        }\n        var transitional = config.transitional || defaults.transitional;\n        reject(createError(\n          timeoutErrorMessage,\n          config,\n          transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n          req\n        ));\n      });\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (req.aborted) return;\n\n        req.abort();\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n\n    // Send the request\n    if (utils.isStream(data)) {\n      data.on('error', function handleStreamError(err) {\n        reject(enhanceError(err, config, null, req));\n      }).pipe(req);\n    } else {\n      req.end(data);\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar settle = require('./../core/settle');\nvar cookies = require('./../helpers/cookies');\nvar buildURL = require('./../helpers/buildURL');\nvar buildFullPath = require('../core/buildFullPath');\nvar parseHeaders = require('./../helpers/parseHeaders');\nvar isURLSameOrigin = require('./../helpers/isURLSameOrigin');\nvar createError = require('../core/createError');\nvar defaults = require('../defaults');\nvar Cancel = require('../cancel/Cancel');\n\nmodule.exports = function xhrAdapter(config) {\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\n    var requestData = config.data;\n    var requestHeaders = config.headers;\n    var responseType = config.responseType;\n    var onCanceled;\n    function done() {\n      if (config.cancelToken) {\n        config.cancelToken.unsubscribe(onCanceled);\n      }\n\n      if (config.signal) {\n        config.signal.removeEventListener('abort', onCanceled);\n      }\n    }\n\n    if (utils.isFormData(requestData)) {\n      delete requestHeaders['Content-Type']; // Let the browser set it\n    }\n\n    var request = new XMLHttpRequest();\n\n    // HTTP basic authentication\n    if (config.auth) {\n      var username = config.auth.username || '';\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\n    }\n\n    var fullPath = buildFullPath(config.baseURL, config.url);\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\n\n    // Set the request timeout in MS\n    request.timeout = config.timeout;\n\n    function onloadend() {\n      if (!request) {\n        return;\n      }\n      // Prepare the response\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\n        request.responseText : request.response;\n      var response = {\n        data: responseData,\n        status: request.status,\n        statusText: request.statusText,\n        headers: responseHeaders,\n        config: config,\n        request: request\n      };\n\n      settle(function _resolve(value) {\n        resolve(value);\n        done();\n      }, function _reject(err) {\n        reject(err);\n        done();\n      }, response);\n\n      // Clean up request\n      request = null;\n    }\n\n    if ('onloadend' in request) {\n      // Use onloadend if available\n      request.onloadend = onloadend;\n    } else {\n      // Listen for ready state to emulate onloadend\n      request.onreadystatechange = function handleLoad() {\n        if (!request || request.readyState !== 4) {\n          return;\n        }\n\n        // The request errored out and we didn't get a response, this will be\n        // handled by onerror instead\n        // With one exception: request that using file: protocol, most browsers\n        // will return status as 0 even though it's a successful request\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\n          return;\n        }\n        // readystate handler is calling before onerror or ontimeout handlers,\n        // so we should call onloadend on the next 'tick'\n        setTimeout(onloadend);\n      };\n    }\n\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    request.onabort = function handleAbort() {\n      if (!request) {\n        return;\n      }\n\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle low level network errors\n    request.onerror = function handleError() {\n      // Real errors are hidden from us by the browser\n      // onerror should only fire if it's a network error\n      reject(createError('Network Error', config, null, request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Handle timeout\n    request.ontimeout = function handleTimeout() {\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\n      var transitional = config.transitional || defaults.transitional;\n      if (config.timeoutErrorMessage) {\n        timeoutErrorMessage = config.timeoutErrorMessage;\n      }\n      reject(createError(\n        timeoutErrorMessage,\n        config,\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\n        request));\n\n      // Clean up request\n      request = null;\n    };\n\n    // Add xsrf header\n    // This is only done if running in a standard browser environment.\n    // Specifically not if we're in a web worker, or react-native.\n    if (utils.isStandardBrowserEnv()) {\n      // Add xsrf header\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\n        cookies.read(config.xsrfCookieName) :\n        undefined;\n\n      if (xsrfValue) {\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\n      }\n    }\n\n    // Add headers to the request\n    if ('setRequestHeader' in request) {\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\n          // Remove Content-Type if data is undefined\n          delete requestHeaders[key];\n        } else {\n          // Otherwise add header to the request\n          request.setRequestHeader(key, val);\n        }\n      });\n    }\n\n    // Add withCredentials to request if needed\n    if (!utils.isUndefined(config.withCredentials)) {\n      request.withCredentials = !!config.withCredentials;\n    }\n\n    // Add responseType to request if needed\n    if (responseType && responseType !== 'json') {\n      request.responseType = config.responseType;\n    }\n\n    // Handle progress if needed\n    if (typeof config.onDownloadProgress === 'function') {\n      request.addEventListener('progress', config.onDownloadProgress);\n    }\n\n    // Not all browsers support upload events\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\n      request.upload.addEventListener('progress', config.onUploadProgress);\n    }\n\n    if (config.cancelToken || config.signal) {\n      // Handle cancellation\n      // eslint-disable-next-line func-names\n      onCanceled = function(cancel) {\n        if (!request) {\n          return;\n        }\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\n        request.abort();\n        request = null;\n      };\n\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\n      if (config.signal) {\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\n      }\n    }\n\n    if (!requestData) {\n      requestData = null;\n    }\n\n    // Send the request\n    request.send(requestData);\n  });\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar bind = require('./helpers/bind');\nvar Axios = require('./core/Axios');\nvar mergeConfig = require('./core/mergeConfig');\nvar defaults = require('./defaults');\n\n/**\n * Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n * @return {Axios} A new instance of Axios\n */\nfunction createInstance(defaultConfig) {\n  var context = new Axios(defaultConfig);\n  var instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context);\n\n  // Copy context to instance\n  utils.extend(instance, context);\n\n  // Factory for creating new instances\n  instance.create = function create(instanceConfig) {\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\n  };\n\n  return instance;\n}\n\n// Create the default instance to be exported\nvar axios = createInstance(defaults);\n\n// Expose Axios class to allow class inheritance\naxios.Axios = Axios;\n\n// Expose Cancel & CancelToken\naxios.Cancel = require('./cancel/Cancel');\naxios.CancelToken = require('./cancel/CancelToken');\naxios.isCancel = require('./cancel/isCancel');\naxios.VERSION = require('./env/data').version;\n\n// Expose all/spread\naxios.all = function all(promises) {\n  return Promise.all(promises);\n};\naxios.spread = require('./helpers/spread');\n\n// Expose isAxiosError\naxios.isAxiosError = require('./helpers/isAxiosError');\n\nmodule.exports = axios;\n\n// Allow use of default import syntax in TypeScript\nmodule.exports.default = axios;\n","'use strict';\n\n/**\n * A `Cancel` is an object that is thrown when an operation is canceled.\n *\n * @class\n * @param {string=} message The message.\n */\nfunction Cancel(message) {\n  this.message = message;\n}\n\nCancel.prototype.toString = function toString() {\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\n};\n\nCancel.prototype.__CANCEL__ = true;\n\nmodule.exports = Cancel;\n","'use strict';\n\nvar Cancel = require('./Cancel');\n\n/**\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @class\n * @param {Function} executor The executor function.\n */\nfunction CancelToken(executor) {\n  if (typeof executor !== 'function') {\n    throw new TypeError('executor must be a function.');\n  }\n\n  var resolvePromise;\n\n  this.promise = new Promise(function promiseExecutor(resolve) {\n    resolvePromise = resolve;\n  });\n\n  var token = this;\n\n  // eslint-disable-next-line func-names\n  this.promise.then(function(cancel) {\n    if (!token._listeners) return;\n\n    var i;\n    var l = token._listeners.length;\n\n    for (i = 0; i < l; i++) {\n      token._listeners[i](cancel);\n    }\n    token._listeners = null;\n  });\n\n  // eslint-disable-next-line func-names\n  this.promise.then = function(onfulfilled) {\n    var _resolve;\n    // eslint-disable-next-line func-names\n    var promise = new Promise(function(resolve) {\n      token.subscribe(resolve);\n      _resolve = resolve;\n    }).then(onfulfilled);\n\n    promise.cancel = function reject() {\n      token.unsubscribe(_resolve);\n    };\n\n    return promise;\n  };\n\n  executor(function cancel(message) {\n    if (token.reason) {\n      // Cancellation has already been requested\n      return;\n    }\n\n    token.reason = new Cancel(message);\n    resolvePromise(token.reason);\n  });\n}\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\n  if (this.reason) {\n    throw this.reason;\n  }\n};\n\n/**\n * Subscribe to the cancel signal\n */\n\nCancelToken.prototype.subscribe = function subscribe(listener) {\n  if (this.reason) {\n    listener(this.reason);\n    return;\n  }\n\n  if (this._listeners) {\n    this._listeners.push(listener);\n  } else {\n    this._listeners = [listener];\n  }\n};\n\n/**\n * Unsubscribe from the cancel signal\n */\n\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\n  if (!this._listeners) {\n    return;\n  }\n  var index = this._listeners.indexOf(listener);\n  if (index !== -1) {\n    this._listeners.splice(index, 1);\n  }\n};\n\n/**\n * Returns an object that contains a new `CancelToken` and a function that, when called,\n * cancels the `CancelToken`.\n */\nCancelToken.source = function source() {\n  var cancel;\n  var token = new CancelToken(function executor(c) {\n    cancel = c;\n  });\n  return {\n    token: token,\n    cancel: cancel\n  };\n};\n\nmodule.exports = CancelToken;\n","'use strict';\n\nmodule.exports = function isCancel(value) {\n  return !!(value && value.__CANCEL__);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar buildURL = require('../helpers/buildURL');\nvar InterceptorManager = require('./InterceptorManager');\nvar dispatchRequest = require('./dispatchRequest');\nvar mergeConfig = require('./mergeConfig');\nvar validator = require('../helpers/validator');\n\nvar validators = validator.validators;\n/**\n * Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n */\nfunction Axios(instanceConfig) {\n  this.defaults = instanceConfig;\n  this.interceptors = {\n    request: new InterceptorManager(),\n    response: new InterceptorManager()\n  };\n}\n\n/**\n * Dispatch a request\n *\n * @param {Object} config The config specific for this request (merged with this.defaults)\n */\nAxios.prototype.request = function request(configOrUrl, config) {\n  /*eslint no-param-reassign:0*/\n  // Allow for axios('example/url'[, config]) a la fetch API\n  if (typeof configOrUrl === 'string') {\n    config = config || {};\n    config.url = configOrUrl;\n  } else {\n    config = configOrUrl || {};\n  }\n\n  config = mergeConfig(this.defaults, config);\n\n  // Set config.method\n  if (config.method) {\n    config.method = config.method.toLowerCase();\n  } else if (this.defaults.method) {\n    config.method = this.defaults.method.toLowerCase();\n  } else {\n    config.method = 'get';\n  }\n\n  var transitional = config.transitional;\n\n  if (transitional !== undefined) {\n    validator.assertOptions(transitional, {\n      silentJSONParsing: validators.transitional(validators.boolean),\n      forcedJSONParsing: validators.transitional(validators.boolean),\n      clarifyTimeoutError: validators.transitional(validators.boolean)\n    }, false);\n  }\n\n  // filter out skipped interceptors\n  var requestInterceptorChain = [];\n  var synchronousRequestInterceptors = true;\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\n      return;\n    }\n\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\n\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var responseInterceptorChain = [];\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\n  });\n\n  var promise;\n\n  if (!synchronousRequestInterceptors) {\n    var chain = [dispatchRequest, undefined];\n\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\n    chain = chain.concat(responseInterceptorChain);\n\n    promise = Promise.resolve(config);\n    while (chain.length) {\n      promise = promise.then(chain.shift(), chain.shift());\n    }\n\n    return promise;\n  }\n\n\n  var newConfig = config;\n  while (requestInterceptorChain.length) {\n    var onFulfilled = requestInterceptorChain.shift();\n    var onRejected = requestInterceptorChain.shift();\n    try {\n      newConfig = onFulfilled(newConfig);\n    } catch (error) {\n      onRejected(error);\n      break;\n    }\n  }\n\n  try {\n    promise = dispatchRequest(newConfig);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n\n  while (responseInterceptorChain.length) {\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\n  }\n\n  return promise;\n};\n\nAxios.prototype.getUri = function getUri(config) {\n  config = mergeConfig(this.defaults, config);\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\?/, '');\n};\n\n// Provide aliases for supported request methods\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: (config || {}).data\n    }));\n  };\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  /*eslint func-names:0*/\n  Axios.prototype[method] = function(url, data, config) {\n    return this.request(mergeConfig(config || {}, {\n      method: method,\n      url: url,\n      data: data\n    }));\n  };\n});\n\nmodule.exports = Axios;\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction InterceptorManager() {\n  this.handlers = [];\n}\n\n/**\n * Add a new interceptor to the stack\n *\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\n * @param {Function} rejected The function to handle `reject` for a `Promise`\n *\n * @return {Number} An ID used to remove interceptor later\n */\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\n  this.handlers.push({\n    fulfilled: fulfilled,\n    rejected: rejected,\n    synchronous: options ? options.synchronous : false,\n    runWhen: options ? options.runWhen : null\n  });\n  return this.handlers.length - 1;\n};\n\n/**\n * Remove an interceptor from the stack\n *\n * @param {Number} id The ID that was returned by `use`\n */\nInterceptorManager.prototype.eject = function eject(id) {\n  if (this.handlers[id]) {\n    this.handlers[id] = null;\n  }\n};\n\n/**\n * Iterate over all the registered interceptors\n *\n * This method is particularly useful for skipping over any\n * interceptors that may have become `null` calling `eject`.\n *\n * @param {Function} fn The function to call for each interceptor\n */\nInterceptorManager.prototype.forEach = function forEach(fn) {\n  utils.forEach(this.handlers, function forEachHandler(h) {\n    if (h !== null) {\n      fn(h);\n    }\n  });\n};\n\nmodule.exports = InterceptorManager;\n","'use strict';\n\nvar isAbsoluteURL = require('../helpers/isAbsoluteURL');\nvar combineURLs = require('../helpers/combineURLs');\n\n/**\n * Creates a new URL by combining the baseURL with the requestedURL,\n * only when the requestedURL is not already an absolute URL.\n * If the requestURL is absolute, this function returns the requestedURL untouched.\n *\n * @param {string} baseURL The base URL\n * @param {string} requestedURL Absolute or relative URL to combine\n * @returns {string} The combined full path\n */\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\n    return combineURLs(baseURL, requestedURL);\n  }\n  return requestedURL;\n};\n","'use strict';\n\nvar enhanceError = require('./enhanceError');\n\n/**\n * Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The created error.\n */\nmodule.exports = function createError(message, config, code, request, response) {\n  var error = new Error(message);\n  return enhanceError(error, config, code, request, response);\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar transformData = require('./transformData');\nvar isCancel = require('../cancel/isCancel');\nvar defaults = require('../defaults');\nvar Cancel = require('../cancel/Cancel');\n\n/**\n * Throws a `Cancel` if cancellation has been requested.\n */\nfunction throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }\n\n  if (config.signal && config.signal.aborted) {\n    throw new Cancel('canceled');\n  }\n}\n\n/**\n * Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n * @returns {Promise} The Promise to be fulfilled\n */\nmodule.exports = function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  // Ensure headers exist\n  config.headers = config.headers || {};\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.data,\n    config.headers,\n    config.transformRequest\n  );\n\n  // Flatten headers\n  config.headers = utils.merge(\n    config.headers.common || {},\n    config.headers[config.method] || {},\n    config.headers\n  );\n\n  utils.forEach(\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\n    function cleanHeaderConfig(method) {\n      delete config.headers[method];\n    }\n  );\n\n  var adapter = config.adapter || defaults.adapter;\n\n  return adapter(config).then(function onAdapterResolution(response) {\n    throwIfCancellationRequested(config);\n\n    // Transform response data\n    response.data = transformData.call(\n      config,\n      response.data,\n      response.headers,\n      config.transformResponse\n    );\n\n    return response;\n  }, function onAdapterRejection(reason) {\n    if (!isCancel(reason)) {\n      throwIfCancellationRequested(config);\n\n      // Transform response data\n      if (reason && reason.response) {\n        reason.response.data = transformData.call(\n          config,\n          reason.response.data,\n          reason.response.headers,\n          config.transformResponse\n        );\n      }\n    }\n\n    return Promise.reject(reason);\n  });\n};\n","'use strict';\n\n/**\n * Update an Error with the specified config, error code, and response.\n *\n * @param {Error} error The error to update.\n * @param {Object} config The config.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n * @returns {Error} The error.\n */\nmodule.exports = function enhanceError(error, config, code, request, response) {\n  error.config = config;\n  if (code) {\n    error.code = code;\n  }\n\n  error.request = request;\n  error.response = response;\n  error.isAxiosError = true;\n\n  error.toJSON = function toJSON() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: this.config,\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  };\n  return error;\n};\n","'use strict';\n\nvar utils = require('../utils');\n\n/**\n * Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n * @returns {Object} New object resulting from merging config2 to config1\n */\nmodule.exports = function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {};\n  var config = {};\n\n  function getMergedValue(target, source) {\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\n      return utils.merge(target, source);\n    } else if (utils.isPlainObject(source)) {\n      return utils.merge({}, source);\n    } else if (utils.isArray(source)) {\n      return source.slice();\n    }\n    return source;\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDeepProperties(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function valueFromConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function defaultToConfig2(prop) {\n    if (!utils.isUndefined(config2[prop])) {\n      return getMergedValue(undefined, config2[prop]);\n    } else if (!utils.isUndefined(config1[prop])) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  // eslint-disable-next-line consistent-return\n  function mergeDirectKeys(prop) {\n    if (prop in config2) {\n      return getMergedValue(config1[prop], config2[prop]);\n    } else if (prop in config1) {\n      return getMergedValue(undefined, config1[prop]);\n    }\n  }\n\n  var mergeMap = {\n    'url': valueFromConfig2,\n    'method': valueFromConfig2,\n    'data': valueFromConfig2,\n    'baseURL': defaultToConfig2,\n    'transformRequest': defaultToConfig2,\n    'transformResponse': defaultToConfig2,\n    'paramsSerializer': defaultToConfig2,\n    'timeout': defaultToConfig2,\n    'timeoutMessage': defaultToConfig2,\n    'withCredentials': defaultToConfig2,\n    'adapter': defaultToConfig2,\n    'responseType': defaultToConfig2,\n    'xsrfCookieName': defaultToConfig2,\n    'xsrfHeaderName': defaultToConfig2,\n    'onUploadProgress': defaultToConfig2,\n    'onDownloadProgress': defaultToConfig2,\n    'decompress': defaultToConfig2,\n    'maxContentLength': defaultToConfig2,\n    'maxBodyLength': defaultToConfig2,\n    'transport': defaultToConfig2,\n    'httpAgent': defaultToConfig2,\n    'httpsAgent': defaultToConfig2,\n    'cancelToken': defaultToConfig2,\n    'socketPath': defaultToConfig2,\n    'responseEncoding': defaultToConfig2,\n    'validateStatus': mergeDirectKeys\n  };\n\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\n    var merge = mergeMap[prop] || mergeDeepProperties;\n    var configValue = merge(prop);\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n  });\n\n  return config;\n};\n","'use strict';\n\nvar createError = require('./createError');\n\n/**\n * Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n */\nmodule.exports = function settle(resolve, reject, response) {\n  var validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  } else {\n    reject(createError(\n      'Request failed with status code ' + response.status,\n      response.config,\n      null,\n      response.request,\n      response\n    ));\n  }\n};\n","'use strict';\n\nvar utils = require('./../utils');\nvar defaults = require('./../defaults');\n\n/**\n * Transform the data for a request or a response\n *\n * @param {Object|String} data The data to be transformed\n * @param {Array} headers The headers for the request or response\n * @param {Array|Function} fns A single function or Array of functions\n * @returns {*} The resulting transformed data\n */\nmodule.exports = function transformData(data, headers, fns) {\n  var context = this || defaults;\n  /*eslint no-param-reassign:0*/\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(context, data, headers);\n  });\n\n  return data;\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar normalizeHeaderName = require('./helpers/normalizeHeaderName');\nvar enhanceError = require('./core/enhanceError');\n\nvar DEFAULT_CONTENT_TYPE = {\n  'Content-Type': 'application/x-www-form-urlencoded'\n};\n\nfunction setContentTypeIfUnset(headers, value) {\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\n    headers['Content-Type'] = value;\n  }\n}\n\nfunction getDefaultAdapter() {\n  var adapter;\n  if (typeof XMLHttpRequest !== 'undefined') {\n    // For browsers use XHR adapter\n    adapter = require('./adapters/xhr');\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\n    // For node use HTTP adapter\n    adapter = require('./adapters/http');\n  }\n  return adapter;\n}\n\nfunction stringifySafely(rawValue, parser, encoder) {\n  if (utils.isString(rawValue)) {\n    try {\n      (parser || JSON.parse)(rawValue);\n      return utils.trim(rawValue);\n    } catch (e) {\n      if (e.name !== 'SyntaxError') {\n        throw e;\n      }\n    }\n  }\n\n  return (encoder || JSON.stringify)(rawValue);\n}\n\nvar defaults = {\n\n  transitional: {\n    silentJSONParsing: true,\n    forcedJSONParsing: true,\n    clarifyTimeoutError: false\n  },\n\n  adapter: getDefaultAdapter(),\n\n  transformRequest: [function transformRequest(data, headers) {\n    normalizeHeaderName(headers, 'Accept');\n    normalizeHeaderName(headers, 'Content-Type');\n\n    if (utils.isFormData(data) ||\n      utils.isArrayBuffer(data) ||\n      utils.isBuffer(data) ||\n      utils.isStream(data) ||\n      utils.isFile(data) ||\n      utils.isBlob(data)\n    ) {\n      return data;\n    }\n    if (utils.isArrayBufferView(data)) {\n      return data.buffer;\n    }\n    if (utils.isURLSearchParams(data)) {\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\n      return data.toString();\n    }\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\n      setContentTypeIfUnset(headers, 'application/json');\n      return stringifySafely(data);\n    }\n    return data;\n  }],\n\n  transformResponse: [function transformResponse(data) {\n    var transitional = this.transitional || defaults.transitional;\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\n\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        if (strictJSONParsing) {\n          if (e.name === 'SyntaxError') {\n            throw enhanceError(e, this, 'E_JSON_PARSE');\n          }\n          throw e;\n        }\n      }\n    }\n\n    return data;\n  }],\n\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n\n  xsrfCookieName: 'XSRF-TOKEN',\n  xsrfHeaderName: 'X-XSRF-TOKEN',\n\n  maxContentLength: -1,\n  maxBodyLength: -1,\n\n  validateStatus: function validateStatus(status) {\n    return status >= 200 && status < 300;\n  },\n\n  headers: {\n    common: {\n      'Accept': 'application/json, text/plain, */*'\n    }\n  }\n};\n\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\n  defaults.headers[method] = {};\n});\n\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\n});\n\nmodule.exports = defaults;\n","module.exports = {\n  \"version\": \"0.26.0\"\n};","'use strict';\n\nmodule.exports = function bind(fn, thisArg) {\n  return function wrap() {\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n    return fn.apply(thisArg, args);\n  };\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nfunction encode(val) {\n  return encodeURIComponent(val).\n    replace(/%3A/gi, ':').\n    replace(/%24/g, '$').\n    replace(/%2C/gi, ',').\n    replace(/%20/g, '+').\n    replace(/%5B/gi, '[').\n    replace(/%5D/gi, ']');\n}\n\n/**\n * Build a URL by appending params to the end\n *\n * @param {string} url The base of the url (e.g., http://www.google.com)\n * @param {object} [params] The params to be appended\n * @returns {string} The formatted url\n */\nmodule.exports = function buildURL(url, params, paramsSerializer) {\n  /*eslint no-param-reassign:0*/\n  if (!params) {\n    return url;\n  }\n\n  var serializedParams;\n  if (paramsSerializer) {\n    serializedParams = paramsSerializer(params);\n  } else if (utils.isURLSearchParams(params)) {\n    serializedParams = params.toString();\n  } else {\n    var parts = [];\n\n    utils.forEach(params, function serialize(val, key) {\n      if (val === null || typeof val === 'undefined') {\n        return;\n      }\n\n      if (utils.isArray(val)) {\n        key = key + '[]';\n      } else {\n        val = [val];\n      }\n\n      utils.forEach(val, function parseValue(v) {\n        if (utils.isDate(v)) {\n          v = v.toISOString();\n        } else if (utils.isObject(v)) {\n          v = JSON.stringify(v);\n        }\n        parts.push(encode(key) + '=' + encode(v));\n      });\n    });\n\n    serializedParams = parts.join('&');\n  }\n\n  if (serializedParams) {\n    var hashmarkIndex = url.indexOf('#');\n    if (hashmarkIndex !== -1) {\n      url = url.slice(0, hashmarkIndex);\n    }\n\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\n  }\n\n  return url;\n};\n","'use strict';\n\n/**\n * Creates a new URL by combining the specified URLs\n *\n * @param {string} baseURL The base URL\n * @param {string} relativeURL The relative URL\n * @returns {string} The combined URL\n */\nmodule.exports = function combineURLs(baseURL, relativeURL) {\n  return relativeURL\n    ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n    : baseURL;\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs support document.cookie\n    (function standardBrowserEnv() {\n      return {\n        write: function write(name, value, expires, path, domain, secure) {\n          var cookie = [];\n          cookie.push(name + '=' + encodeURIComponent(value));\n\n          if (utils.isNumber(expires)) {\n            cookie.push('expires=' + new Date(expires).toGMTString());\n          }\n\n          if (utils.isString(path)) {\n            cookie.push('path=' + path);\n          }\n\n          if (utils.isString(domain)) {\n            cookie.push('domain=' + domain);\n          }\n\n          if (secure === true) {\n            cookie.push('secure');\n          }\n\n          document.cookie = cookie.join('; ');\n        },\n\n        read: function read(name) {\n          var match = document.cookie.match(new RegExp('(^|;\\\\s*)(' + name + ')=([^;]*)'));\n          return (match ? decodeURIComponent(match[3]) : null);\n        },\n\n        remove: function remove(name) {\n          this.write(name, '', Date.now() - 86400000);\n        }\n      };\n    })() :\n\n  // Non standard browser env (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return {\n        write: function write() {},\n        read: function read() { return null; },\n        remove: function remove() {}\n      };\n    })()\n);\n","'use strict';\n\n/**\n * Determines whether the specified URL is absolute\n *\n * @param {string} url The URL to test\n * @returns {boolean} True if the specified URL is absolute, otherwise false\n */\nmodule.exports = function isAbsoluteURL(url) {\n  // A URL is considered absolute if it begins with \"<scheme>://\" or \"//\" (protocol-relative URL).\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\n  // by any combination of letters, digits, plus, period, or hyphen.\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n/**\n * Determines whether the payload is an error thrown by Axios\n *\n * @param {*} payload The value to test\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\n */\nmodule.exports = function isAxiosError(payload) {\n  return utils.isObject(payload) && (payload.isAxiosError === true);\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\nmodule.exports = (\n  utils.isStandardBrowserEnv() ?\n\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n    (function standardBrowserEnv() {\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\n      var urlParsingNode = document.createElement('a');\n      var originURL;\n\n      /**\n    * Parse a URL to discover it's components\n    *\n    * @param {String} url The URL to be parsed\n    * @returns {Object}\n    */\n      function resolveURL(url) {\n        var href = url;\n\n        if (msie) {\n        // IE needs attribute set twice to normalize properties\n          urlParsingNode.setAttribute('href', href);\n          href = urlParsingNode.href;\n        }\n\n        urlParsingNode.setAttribute('href', href);\n\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n        return {\n          href: urlParsingNode.href,\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\n          host: urlParsingNode.host,\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\?/, '') : '',\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\n          hostname: urlParsingNode.hostname,\n          port: urlParsingNode.port,\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\n            urlParsingNode.pathname :\n            '/' + urlParsingNode.pathname\n        };\n      }\n\n      originURL = resolveURL(window.location.href);\n\n      /**\n    * Determine if a URL shares the same origin as the current location\n    *\n    * @param {String} requestURL The URL to test\n    * @returns {boolean} True if URL shares the same origin, otherwise false\n    */\n      return function isURLSameOrigin(requestURL) {\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\n        return (parsed.protocol === originURL.protocol &&\n            parsed.host === originURL.host);\n      };\n    })() :\n\n  // Non standard browser envs (web workers, react-native) lack needed support.\n    (function nonStandardBrowserEnv() {\n      return function isURLSameOrigin() {\n        return true;\n      };\n    })()\n);\n","'use strict';\n\nvar utils = require('../utils');\n\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\n  utils.forEach(headers, function processHeader(value, name) {\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\n      headers[normalizedName] = value;\n      delete headers[name];\n    }\n  });\n};\n","'use strict';\n\nvar utils = require('./../utils');\n\n// Headers whose duplicates are ignored by node\n// c.f. https://nodejs.org/api/http.html#http_message_headers\nvar ignoreDuplicateOf = [\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\n  'referer', 'retry-after', 'user-agent'\n];\n\n/**\n * Parse headers into an object\n *\n * ```\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\n * Content-Type: application/json\n * Connection: keep-alive\n * Transfer-Encoding: chunked\n * ```\n *\n * @param {String} headers Headers needing to be parsed\n * @returns {Object} Headers parsed into an object\n */\nmodule.exports = function parseHeaders(headers) {\n  var parsed = {};\n  var key;\n  var val;\n  var i;\n\n  if (!headers) { return parsed; }\n\n  utils.forEach(headers.split('\\n'), function parser(line) {\n    i = line.indexOf(':');\n    key = utils.trim(line.substr(0, i)).toLowerCase();\n    val = utils.trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\n        return;\n      }\n      if (key === 'set-cookie') {\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\n      } else {\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\n      }\n    }\n  });\n\n  return parsed;\n};\n","'use strict';\n\n/**\n * Syntactic sugar for invoking a function and expanding an array for arguments.\n *\n * Common use case would be to use `Function.prototype.apply`.\n *\n *  ```js\n *  function f(x, y, z) {}\n *  var args = [1, 2, 3];\n *  f.apply(null, args);\n *  ```\n *\n * With `spread` this example can be re-written.\n *\n *  ```js\n *  spread(function(x, y, z) {})([1, 2, 3]);\n *  ```\n *\n * @param {Function} callback\n * @returns {Function}\n */\nmodule.exports = function spread(callback) {\n  return function wrap(arr) {\n    return callback.apply(null, arr);\n  };\n};\n","'use strict';\n\nvar VERSION = require('../env/data').version;\n\nvar validators = {};\n\n// eslint-disable-next-line func-names\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\n  validators[type] = function validator(thing) {\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\n  };\n});\n\nvar deprecatedWarnings = {};\n\n/**\n * Transitional option validator\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\n * @param {string?} version - deprecated version / removed since version\n * @param {string?} message - some message with additional info\n * @returns {function}\n */\nvalidators.transitional = function transitional(validator, version, message) {\n  function formatMessage(opt, desc) {\n    return '[Axios v' + VERSION + '] Transitional option \\'' + opt + '\\'' + desc + (message ? '. ' + message : '');\n  }\n\n  // eslint-disable-next-line func-names\n  return function(value, opt, opts) {\n    if (validator === false) {\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\n    }\n\n    if (version && !deprecatedWarnings[opt]) {\n      deprecatedWarnings[opt] = true;\n      // eslint-disable-next-line no-console\n      console.warn(\n        formatMessage(\n          opt,\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\n        )\n      );\n    }\n\n    return validator ? validator(value, opt, opts) : true;\n  };\n};\n\n/**\n * Assert object's properties type\n * @param {object} options\n * @param {object} schema\n * @param {boolean?} allowUnknown\n */\n\nfunction assertOptions(options, schema, allowUnknown) {\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  var keys = Object.keys(options);\n  var i = keys.length;\n  while (i-- > 0) {\n    var opt = keys[i];\n    var validator = schema[opt];\n    if (validator) {\n      var value = options[opt];\n      var result = value === undefined || validator(value, opt, options);\n      if (result !== true) {\n        throw new TypeError('option ' + opt + ' must be ' + result);\n      }\n      continue;\n    }\n    if (allowUnknown !== true) {\n      throw Error('Unknown option ' + opt);\n    }\n  }\n}\n\nmodule.exports = {\n  assertOptions: assertOptions,\n  validators: validators\n};\n","'use strict';\n\nvar bind = require('./helpers/bind');\n\n// utils is a library of generic helper functions non-specific to axios\n\nvar toString = Object.prototype.toString;\n\n/**\n * Determine if a value is an Array\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Array, otherwise false\n */\nfunction isArray(val) {\n  return Array.isArray(val);\n}\n\n/**\n * Determine if a value is undefined\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if the value is undefined, otherwise false\n */\nfunction isUndefined(val) {\n  return typeof val === 'undefined';\n}\n\n/**\n * Determine if a value is a Buffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Buffer, otherwise false\n */\nfunction isBuffer(val) {\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\n}\n\n/**\n * Determine if a value is an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\n */\nfunction isArrayBuffer(val) {\n  return toString.call(val) === '[object ArrayBuffer]';\n}\n\n/**\n * Determine if a value is a FormData\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an FormData, otherwise false\n */\nfunction isFormData(val) {\n  return toString.call(val) === '[object FormData]';\n}\n\n/**\n * Determine if a value is a view on an ArrayBuffer\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\n */\nfunction isArrayBufferView(val) {\n  var result;\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\n    result = ArrayBuffer.isView(val);\n  } else {\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\n  }\n  return result;\n}\n\n/**\n * Determine if a value is a String\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a String, otherwise false\n */\nfunction isString(val) {\n  return typeof val === 'string';\n}\n\n/**\n * Determine if a value is a Number\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Number, otherwise false\n */\nfunction isNumber(val) {\n  return typeof val === 'number';\n}\n\n/**\n * Determine if a value is an Object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is an Object, otherwise false\n */\nfunction isObject(val) {\n  return val !== null && typeof val === 'object';\n}\n\n/**\n * Determine if a value is a plain Object\n *\n * @param {Object} val The value to test\n * @return {boolean} True if value is a plain Object, otherwise false\n */\nfunction isPlainObject(val) {\n  if (toString.call(val) !== '[object Object]') {\n    return false;\n  }\n\n  var prototype = Object.getPrototypeOf(val);\n  return prototype === null || prototype === Object.prototype;\n}\n\n/**\n * Determine if a value is a Date\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Date, otherwise false\n */\nfunction isDate(val) {\n  return toString.call(val) === '[object Date]';\n}\n\n/**\n * Determine if a value is a File\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a File, otherwise false\n */\nfunction isFile(val) {\n  return toString.call(val) === '[object File]';\n}\n\n/**\n * Determine if a value is a Blob\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Blob, otherwise false\n */\nfunction isBlob(val) {\n  return toString.call(val) === '[object Blob]';\n}\n\n/**\n * Determine if a value is a Function\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Function, otherwise false\n */\nfunction isFunction(val) {\n  return toString.call(val) === '[object Function]';\n}\n\n/**\n * Determine if a value is a Stream\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a Stream, otherwise false\n */\nfunction isStream(val) {\n  return isObject(val) && isFunction(val.pipe);\n}\n\n/**\n * Determine if a value is a URLSearchParams object\n *\n * @param {Object} val The value to test\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\n */\nfunction isURLSearchParams(val) {\n  return toString.call(val) === '[object URLSearchParams]';\n}\n\n/**\n * Trim excess whitespace off the beginning and end of a string\n *\n * @param {String} str The String to trim\n * @returns {String} The String freed of excess whitespace\n */\nfunction trim(str) {\n  return str.trim ? str.trim() : str.replace(/^\\s+|\\s+$/g, '');\n}\n\n/**\n * Determine if we're running in a standard browser environment\n *\n * This allows axios to run in a web worker, and react-native.\n * Both environments support XMLHttpRequest, but not fully standard globals.\n *\n * web workers:\n *  typeof window -> undefined\n *  typeof document -> undefined\n *\n * react-native:\n *  navigator.product -> 'ReactNative'\n * nativescript\n *  navigator.product -> 'NativeScript' or 'NS'\n */\nfunction isStandardBrowserEnv() {\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\n                                           navigator.product === 'NativeScript' ||\n                                           navigator.product === 'NS')) {\n    return false;\n  }\n  return (\n    typeof window !== 'undefined' &&\n    typeof document !== 'undefined'\n  );\n}\n\n/**\n * Iterate over an Array or an Object invoking a function for each item.\n *\n * If `obj` is an Array callback will be called passing\n * the value, index, and complete array for each item.\n *\n * If 'obj' is an Object callback will be called passing\n * the value, key, and complete object for each property.\n *\n * @param {Object|Array} obj The object to iterate\n * @param {Function} fn The callback to invoke for each item\n */\nfunction forEach(obj, fn) {\n  // Don't bother if no value provided\n  if (obj === null || typeof obj === 'undefined') {\n    return;\n  }\n\n  // Force an array if not already something iterable\n  if (typeof obj !== 'object') {\n    /*eslint no-param-reassign:0*/\n    obj = [obj];\n  }\n\n  if (isArray(obj)) {\n    // Iterate over array values\n    for (var i = 0, l = obj.length; i < l; i++) {\n      fn.call(null, obj[i], i, obj);\n    }\n  } else {\n    // Iterate over object keys\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\n        fn.call(null, obj[key], key, obj);\n      }\n    }\n  }\n}\n\n/**\n * Accepts varargs expecting each argument to be an object, then\n * immutably merges the properties of each object and returns result.\n *\n * When multiple objects contain the same key the later object in\n * the arguments list will take precedence.\n *\n * Example:\n *\n * ```js\n * var result = merge({foo: 123}, {foo: 456});\n * console.log(result.foo); // outputs 456\n * ```\n *\n * @param {Object} obj1 Object to merge\n * @returns {Object} Result of all merge properties\n */\nfunction merge(/* obj1, obj2, obj3, ... */) {\n  var result = {};\n  function assignValue(val, key) {\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\n      result[key] = merge(result[key], val);\n    } else if (isPlainObject(val)) {\n      result[key] = merge({}, val);\n    } else if (isArray(val)) {\n      result[key] = val.slice();\n    } else {\n      result[key] = val;\n    }\n  }\n\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    forEach(arguments[i], assignValue);\n  }\n  return result;\n}\n\n/**\n * Extends object a by mutably adding to it the properties of object b.\n *\n * @param {Object} a The object to be extended\n * @param {Object} b The object to copy properties from\n * @param {Object} thisArg The object to bind function to\n * @return {Object} The resulting value of object a\n */\nfunction extend(a, b, thisArg) {\n  forEach(b, function assignValue(val, key) {\n    if (thisArg && typeof val === 'function') {\n      a[key] = bind(val, thisArg);\n    } else {\n      a[key] = val;\n    }\n  });\n  return a;\n}\n\n/**\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\n *\n * @param {string} content with BOM\n * @return {string} content value without BOM\n */\nfunction stripBOM(content) {\n  if (content.charCodeAt(0) === 0xFEFF) {\n    content = content.slice(1);\n  }\n  return content;\n}\n\nmodule.exports = {\n  isArray: isArray,\n  isArrayBuffer: isArrayBuffer,\n  isBuffer: isBuffer,\n  isFormData: isFormData,\n  isArrayBufferView: isArrayBufferView,\n  isString: isString,\n  isNumber: isNumber,\n  isObject: isObject,\n  isPlainObject: isPlainObject,\n  isUndefined: isUndefined,\n  isDate: isDate,\n  isFile: isFile,\n  isBlob: isBlob,\n  isFunction: isFunction,\n  isStream: isStream,\n  isURLSearchParams: isURLSearchParams,\n  isStandardBrowserEnv: isStandardBrowserEnv,\n  forEach: forEach,\n  merge: merge,\n  extend: extend,\n  trim: trim,\n  stripBOM: stripBOM\n};\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","/* eslint-env browser */\n\n/**\n * This is the web browser implementation of `debug()`.\n */\n\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = localstorage();\nexports.destroy = (() => {\n\tlet warned = false;\n\n\treturn () => {\n\t\tif (!warned) {\n\t\t\twarned = true;\n\t\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t\t}\n\t};\n})();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n\t'#0000CC',\n\t'#0000FF',\n\t'#0033CC',\n\t'#0033FF',\n\t'#0066CC',\n\t'#0066FF',\n\t'#0099CC',\n\t'#0099FF',\n\t'#00CC00',\n\t'#00CC33',\n\t'#00CC66',\n\t'#00CC99',\n\t'#00CCCC',\n\t'#00CCFF',\n\t'#3300CC',\n\t'#3300FF',\n\t'#3333CC',\n\t'#3333FF',\n\t'#3366CC',\n\t'#3366FF',\n\t'#3399CC',\n\t'#3399FF',\n\t'#33CC00',\n\t'#33CC33',\n\t'#33CC66',\n\t'#33CC99',\n\t'#33CCCC',\n\t'#33CCFF',\n\t'#6600CC',\n\t'#6600FF',\n\t'#6633CC',\n\t'#6633FF',\n\t'#66CC00',\n\t'#66CC33',\n\t'#9900CC',\n\t'#9900FF',\n\t'#9933CC',\n\t'#9933FF',\n\t'#99CC00',\n\t'#99CC33',\n\t'#CC0000',\n\t'#CC0033',\n\t'#CC0066',\n\t'#CC0099',\n\t'#CC00CC',\n\t'#CC00FF',\n\t'#CC3300',\n\t'#CC3333',\n\t'#CC3366',\n\t'#CC3399',\n\t'#CC33CC',\n\t'#CC33FF',\n\t'#CC6600',\n\t'#CC6633',\n\t'#CC9900',\n\t'#CC9933',\n\t'#CCCC00',\n\t'#CCCC33',\n\t'#FF0000',\n\t'#FF0033',\n\t'#FF0066',\n\t'#FF0099',\n\t'#FF00CC',\n\t'#FF00FF',\n\t'#FF3300',\n\t'#FF3333',\n\t'#FF3366',\n\t'#FF3399',\n\t'#FF33CC',\n\t'#FF33FF',\n\t'#FF6600',\n\t'#FF6633',\n\t'#FF9900',\n\t'#FF9933',\n\t'#FFCC00',\n\t'#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\n// eslint-disable-next-line complexity\nfunction useColors() {\n\t// NB: In an Electron preload script, document will be defined but not fully\n\t// initialized. Since we know we're in Chrome, we'll just detect this case\n\t// explicitly\n\tif (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {\n\t\treturn true;\n\t}\n\n\t// Internet Explorer and Edge do not support colors.\n\tif (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t\treturn false;\n\t}\n\n\t// Is webkit? http://stackoverflow.com/a/16459606/376773\n\t// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\treturn (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t\t// Is firebug? http://stackoverflow.com/a/398120/376773\n\t\t(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t\t// Is firefox >= v31?\n\t\t// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t\t// Double check webkit in userAgent just in case we are in a worker\n\t\t(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\targs[0] = (this.useColors ? '%c' : '') +\n\t\tthis.namespace +\n\t\t(this.useColors ? ' %c' : ' ') +\n\t\targs[0] +\n\t\t(this.useColors ? '%c ' : ' ') +\n\t\t'+' + module.exports.humanize(this.diff);\n\n\tif (!this.useColors) {\n\t\treturn;\n\t}\n\n\tconst c = 'color: ' + this.color;\n\targs.splice(1, 0, c, 'color: inherit');\n\n\t// The final \"%c\" is somewhat tricky, because there could be other\n\t// arguments passed either before or after the %c, so we need to\n\t// figure out the correct index to insert the CSS into\n\tlet index = 0;\n\tlet lastC = 0;\n\targs[0].replace(/%[a-zA-Z%]/g, match => {\n\t\tif (match === '%%') {\n\t\t\treturn;\n\t\t}\n\t\tindex++;\n\t\tif (match === '%c') {\n\t\t\t// We only are interested in the *last* %c\n\t\t\t// (the user may have provided their own)\n\t\t\tlastC = index;\n\t\t}\n\t});\n\n\targs.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.debug()` when available.\n * No-op when `console.debug` is not a \"function\".\n * If `console.debug` is not available, falls back\n * to `console.log`.\n *\n * @api public\n */\nexports.log = console.debug || console.log || (() => {});\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\ttry {\n\t\tif (namespaces) {\n\t\t\texports.storage.setItem('debug', namespaces);\n\t\t} else {\n\t\t\texports.storage.removeItem('debug');\n\t\t}\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\nfunction load() {\n\tlet r;\n\ttry {\n\t\tr = exports.storage.getItem('debug');\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n\n\t// If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\tif (!r && typeof process !== 'undefined' && 'env' in process) {\n\t\tr = process.env.DEBUG;\n\t}\n\n\treturn r;\n}\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n\ttry {\n\t\t// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context\n\t\t// The Browser also has localStorage in the global context.\n\t\treturn localStorage;\n\t} catch (error) {\n\t\t// Swallow\n\t\t// XXX (@Qix-) should we be logging these?\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nformatters.j = function (v) {\n\ttry {\n\t\treturn JSON.stringify(v);\n\t} catch (error) {\n\t\treturn '[UnexpectedJSONParseError]: ' + error.message;\n\t}\n};\n","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n */\n\nfunction setup(env) {\n\tcreateDebug.debug = createDebug;\n\tcreateDebug.default = createDebug;\n\tcreateDebug.coerce = coerce;\n\tcreateDebug.disable = disable;\n\tcreateDebug.enable = enable;\n\tcreateDebug.enabled = enabled;\n\tcreateDebug.humanize = require('ms');\n\tcreateDebug.destroy = destroy;\n\n\tObject.keys(env).forEach(key => {\n\t\tcreateDebug[key] = env[key];\n\t});\n\n\t/**\n\t* The currently active debug mode names, and names to skip.\n\t*/\n\n\tcreateDebug.names = [];\n\tcreateDebug.skips = [];\n\n\t/**\n\t* Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t*\n\t* Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t*/\n\tcreateDebug.formatters = {};\n\n\t/**\n\t* Selects a color for a debug namespace\n\t* @param {String} namespace The namespace string for the debug instance to be colored\n\t* @return {Number|String} An ANSI color code for the given namespace\n\t* @api private\n\t*/\n\tfunction selectColor(namespace) {\n\t\tlet hash = 0;\n\n\t\tfor (let i = 0; i < namespace.length; i++) {\n\t\t\thash = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t\t\thash |= 0; // Convert to 32bit integer\n\t\t}\n\n\t\treturn createDebug.colors[Math.abs(hash) % createDebug.colors.length];\n\t}\n\tcreateDebug.selectColor = selectColor;\n\n\t/**\n\t* Create a debugger with the given `namespace`.\n\t*\n\t* @param {String} namespace\n\t* @return {Function}\n\t* @api public\n\t*/\n\tfunction createDebug(namespace) {\n\t\tlet prevTime;\n\t\tlet enableOverride = null;\n\t\tlet namespacesCache;\n\t\tlet enabledCache;\n\n\t\tfunction debug(...args) {\n\t\t\t// Disabled?\n\t\t\tif (!debug.enabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst self = debug;\n\n\t\t\t// Set `diff` timestamp\n\t\t\tconst curr = Number(new Date());\n\t\t\tconst ms = curr - (prevTime || curr);\n\t\t\tself.diff = ms;\n\t\t\tself.prev = prevTime;\n\t\t\tself.curr = curr;\n\t\t\tprevTime = curr;\n\n\t\t\targs[0] = createDebug.coerce(args[0]);\n\n\t\t\tif (typeof args[0] !== 'string') {\n\t\t\t\t// Anything else let's inspect with %O\n\t\t\t\targs.unshift('%O');\n\t\t\t}\n\n\t\t\t// Apply any `formatters` transformations\n\t\t\tlet index = 0;\n\t\t\targs[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {\n\t\t\t\t// If we encounter an escaped % then don't increase the array index\n\t\t\t\tif (match === '%%') {\n\t\t\t\t\treturn '%';\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t\tconst formatter = createDebug.formatters[format];\n\t\t\t\tif (typeof formatter === 'function') {\n\t\t\t\t\tconst val = args[index];\n\t\t\t\t\tmatch = formatter.call(self, val);\n\n\t\t\t\t\t// Now we need to remove `args[index]` since it's inlined in the `format`\n\t\t\t\t\targs.splice(index, 1);\n\t\t\t\t\tindex--;\n\t\t\t\t}\n\t\t\t\treturn match;\n\t\t\t});\n\n\t\t\t// Apply env-specific formatting (colors, etc.)\n\t\t\tcreateDebug.formatArgs.call(self, args);\n\n\t\t\tconst logFn = self.log || createDebug.log;\n\t\t\tlogFn.apply(self, args);\n\t\t}\n\n\t\tdebug.namespace = namespace;\n\t\tdebug.useColors = createDebug.useColors();\n\t\tdebug.color = createDebug.selectColor(namespace);\n\t\tdebug.extend = extend;\n\t\tdebug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.\n\n\t\tObject.defineProperty(debug, 'enabled', {\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false,\n\t\t\tget: () => {\n\t\t\t\tif (enableOverride !== null) {\n\t\t\t\t\treturn enableOverride;\n\t\t\t\t}\n\t\t\t\tif (namespacesCache !== createDebug.namespaces) {\n\t\t\t\t\tnamespacesCache = createDebug.namespaces;\n\t\t\t\t\tenabledCache = createDebug.enabled(namespace);\n\t\t\t\t}\n\n\t\t\t\treturn enabledCache;\n\t\t\t},\n\t\t\tset: v => {\n\t\t\t\tenableOverride = v;\n\t\t\t}\n\t\t});\n\n\t\t// Env-specific initialization logic for debug instances\n\t\tif (typeof createDebug.init === 'function') {\n\t\t\tcreateDebug.init(debug);\n\t\t}\n\n\t\treturn debug;\n\t}\n\n\tfunction extend(namespace, delimiter) {\n\t\tconst newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);\n\t\tnewDebug.log = this.log;\n\t\treturn newDebug;\n\t}\n\n\t/**\n\t* Enables a debug mode by namespaces. This can include modes\n\t* separated by a colon and wildcards.\n\t*\n\t* @param {String} namespaces\n\t* @api public\n\t*/\n\tfunction enable(namespaces) {\n\t\tcreateDebug.save(namespaces);\n\t\tcreateDebug.namespaces = namespaces;\n\n\t\tcreateDebug.names = [];\n\t\tcreateDebug.skips = [];\n\n\t\tlet i;\n\t\tconst split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t\tconst len = split.length;\n\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (!split[i]) {\n\t\t\t\t// ignore empty strings\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tnamespaces = split[i].replace(/\\*/g, '.*?');\n\n\t\t\tif (namespaces[0] === '-') {\n\t\t\t\tcreateDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t\t\t} else {\n\t\t\t\tcreateDebug.names.push(new RegExp('^' + namespaces + '$'));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t* Disable debug output.\n\t*\n\t* @return {String} namespaces\n\t* @api public\n\t*/\n\tfunction disable() {\n\t\tconst namespaces = [\n\t\t\t...createDebug.names.map(toNamespace),\n\t\t\t...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)\n\t\t].join(',');\n\t\tcreateDebug.enable('');\n\t\treturn namespaces;\n\t}\n\n\t/**\n\t* Returns true if the given mode name is enabled, false otherwise.\n\t*\n\t* @param {String} name\n\t* @return {Boolean}\n\t* @api public\n\t*/\n\tfunction enabled(name) {\n\t\tif (name[name.length - 1] === '*') {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet i;\n\t\tlet len;\n\n\t\tfor (i = 0, len = createDebug.skips.length; i < len; i++) {\n\t\t\tif (createDebug.skips[i].test(name)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tfor (i = 0, len = createDebug.names.length; i < len; i++) {\n\t\t\tif (createDebug.names[i].test(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t* Convert regexp to namespace\n\t*\n\t* @param {RegExp} regxep\n\t* @return {String} namespace\n\t* @api private\n\t*/\n\tfunction toNamespace(regexp) {\n\t\treturn regexp.toString()\n\t\t\t.substring(2, regexp.toString().length - 2)\n\t\t\t.replace(/\\.\\*\\?$/, '*');\n\t}\n\n\t/**\n\t* Coerce `val`.\n\t*\n\t* @param {Mixed} val\n\t* @return {Mixed}\n\t* @api private\n\t*/\n\tfunction coerce(val) {\n\t\tif (val instanceof Error) {\n\t\t\treturn val.stack || val.message;\n\t\t}\n\t\treturn val;\n\t}\n\n\t/**\n\t* XXX DO NOT USE. This is a temporary stub function.\n\t* XXX It WILL be removed in the next major release.\n\t*/\n\tfunction destroy() {\n\t\tconsole.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');\n\t}\n\n\tcreateDebug.enable(createDebug.load());\n\n\treturn createDebug;\n}\n\nmodule.exports = setup;\n","/**\n * Detect Electron renderer / nwjs process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {\n\tmodule.exports = require('./browser.js');\n} else {\n\tmodule.exports = require('./node.js');\n}\n","/**\n * Module dependencies.\n */\n\nconst tty = require('tty');\nconst util = require('util');\n\n/**\n * This is the Node.js implementation of `debug()`.\n */\n\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.destroy = util.deprecate(\n\t() => {},\n\t'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'\n);\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\ntry {\n\t// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)\n\t// eslint-disable-next-line import/no-extraneous-dependencies\n\tconst supportsColor = require('supports-color');\n\n\tif (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {\n\t\texports.colors = [\n\t\t\t20,\n\t\t\t21,\n\t\t\t26,\n\t\t\t27,\n\t\t\t32,\n\t\t\t33,\n\t\t\t38,\n\t\t\t39,\n\t\t\t40,\n\t\t\t41,\n\t\t\t42,\n\t\t\t43,\n\t\t\t44,\n\t\t\t45,\n\t\t\t56,\n\t\t\t57,\n\t\t\t62,\n\t\t\t63,\n\t\t\t68,\n\t\t\t69,\n\t\t\t74,\n\t\t\t75,\n\t\t\t76,\n\t\t\t77,\n\t\t\t78,\n\t\t\t79,\n\t\t\t80,\n\t\t\t81,\n\t\t\t92,\n\t\t\t93,\n\t\t\t98,\n\t\t\t99,\n\t\t\t112,\n\t\t\t113,\n\t\t\t128,\n\t\t\t129,\n\t\t\t134,\n\t\t\t135,\n\t\t\t148,\n\t\t\t149,\n\t\t\t160,\n\t\t\t161,\n\t\t\t162,\n\t\t\t163,\n\t\t\t164,\n\t\t\t165,\n\t\t\t166,\n\t\t\t167,\n\t\t\t168,\n\t\t\t169,\n\t\t\t170,\n\t\t\t171,\n\t\t\t172,\n\t\t\t173,\n\t\t\t178,\n\t\t\t179,\n\t\t\t184,\n\t\t\t185,\n\t\t\t196,\n\t\t\t197,\n\t\t\t198,\n\t\t\t199,\n\t\t\t200,\n\t\t\t201,\n\t\t\t202,\n\t\t\t203,\n\t\t\t204,\n\t\t\t205,\n\t\t\t206,\n\t\t\t207,\n\t\t\t208,\n\t\t\t209,\n\t\t\t214,\n\t\t\t215,\n\t\t\t220,\n\t\t\t221\n\t\t];\n\t}\n} catch (error) {\n\t// Swallow - we only care if `supports-color` is available; it doesn't have to be.\n}\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(key => {\n\treturn /^debug_/i.test(key);\n}).reduce((obj, key) => {\n\t// Camel-case\n\tconst prop = key\n\t\t.substring(6)\n\t\t.toLowerCase()\n\t\t.replace(/_([a-z])/g, (_, k) => {\n\t\t\treturn k.toUpperCase();\n\t\t});\n\n\t// Coerce string value into JS value\n\tlet val = process.env[key];\n\tif (/^(yes|on|true|enabled)$/i.test(val)) {\n\t\tval = true;\n\t} else if (/^(no|off|false|disabled)$/i.test(val)) {\n\t\tval = false;\n\t} else if (val === 'null') {\n\t\tval = null;\n\t} else {\n\t\tval = Number(val);\n\t}\n\n\tobj[prop] = val;\n\treturn obj;\n}, {});\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n\treturn 'colors' in exports.inspectOpts ?\n\t\tBoolean(exports.inspectOpts.colors) :\n\t\ttty.isatty(process.stderr.fd);\n}\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n\tconst {namespace: name, useColors} = this;\n\n\tif (useColors) {\n\t\tconst c = this.color;\n\t\tconst colorCode = '\\u001B[3' + (c < 8 ? c : '8;5;' + c);\n\t\tconst prefix = `  ${colorCode};1m${name} \\u001B[0m`;\n\n\t\targs[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n\t\targs.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\\u001B[0m');\n\t} else {\n\t\targs[0] = getDate() + name + ' ' + args[0];\n\t}\n}\n\nfunction getDate() {\n\tif (exports.inspectOpts.hideDate) {\n\t\treturn '';\n\t}\n\treturn new Date().toISOString() + ' ';\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to stderr.\n */\n\nfunction log(...args) {\n\treturn process.stderr.write(util.format(...args) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\nfunction save(namespaces) {\n\tif (namespaces) {\n\t\tprocess.env.DEBUG = namespaces;\n\t} else {\n\t\t// If you set a process.env field to null or undefined, it gets cast to the\n\t\t// string 'null' or 'undefined'. Just delete instead.\n\t\tdelete process.env.DEBUG;\n\t}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n\treturn process.env.DEBUG;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init(debug) {\n\tdebug.inspectOpts = {};\n\n\tconst keys = Object.keys(exports.inspectOpts);\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tdebug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n\t}\n}\n\nmodule.exports = require('./common')(exports);\n\nconst {formatters} = module.exports;\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nformatters.o = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts)\n\t\t.split('\\n')\n\t\t.map(str => str.trim())\n\t\t.join(' ');\n};\n\n/**\n * Map %O to `util.inspect()`, allowing multiple lines if needed.\n */\n\nformatters.O = function (v) {\n\tthis.inspectOpts.colors = this.useColors;\n\treturn util.inspect(v, this.inspectOpts);\n};\n","var debug;\n\nmodule.exports = function () {\n  if (!debug) {\n    try {\n      /* eslint global-require: off */\n      debug = require(\"debug\")(\"follow-redirects\");\n    }\n    catch (error) { /* */ }\n    if (typeof debug !== \"function\") {\n      debug = function () { /* */ };\n    }\n  }\n  debug.apply(null, arguments);\n};\n","var url = require(\"url\");\nvar URL = url.URL;\nvar http = require(\"http\");\nvar https = require(\"https\");\nvar Writable = require(\"stream\").Writable;\nvar assert = require(\"assert\");\nvar debug = require(\"./debug\");\n\n// Create handlers that pass events from native requests\nvar events = [\"abort\", \"aborted\", \"connect\", \"error\", \"socket\", \"timeout\"];\nvar eventHandlers = Object.create(null);\nevents.forEach(function (event) {\n  eventHandlers[event] = function (arg1, arg2, arg3) {\n    this._redirectable.emit(event, arg1, arg2, arg3);\n  };\n});\n\n// Error types with codes\nvar RedirectionError = createErrorType(\n  \"ERR_FR_REDIRECTION_FAILURE\",\n  \"Redirected request failed\"\n);\nvar TooManyRedirectsError = createErrorType(\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"Maximum number of redirects exceeded\"\n);\nvar MaxBodyLengthExceededError = createErrorType(\n  \"ERR_FR_MAX_BODY_LENGTH_EXCEEDED\",\n  \"Request body larger than maxBodyLength limit\"\n);\nvar WriteAfterEndError = createErrorType(\n  \"ERR_STREAM_WRITE_AFTER_END\",\n  \"write after end\"\n);\n\n// An HTTP(S) request that can be redirected\nfunction RedirectableRequest(options, responseCallback) {\n  // Initialize the request\n  Writable.call(this);\n  this._sanitizeOptions(options);\n  this._options = options;\n  this._ended = false;\n  this._ending = false;\n  this._redirectCount = 0;\n  this._redirects = [];\n  this._requestBodyLength = 0;\n  this._requestBodyBuffers = [];\n\n  // Attach a callback if passed\n  if (responseCallback) {\n    this.on(\"response\", responseCallback);\n  }\n\n  // React to responses of native requests\n  var self = this;\n  this._onNativeResponse = function (response) {\n    self._processResponse(response);\n  };\n\n  // Perform the first request\n  this._performRequest();\n}\nRedirectableRequest.prototype = Object.create(Writable.prototype);\n\nRedirectableRequest.prototype.abort = function () {\n  abortRequest(this._currentRequest);\n  this.emit(\"abort\");\n};\n\n// Writes buffered data to the current native request\nRedirectableRequest.prototype.write = function (data, encoding, callback) {\n  // Writing is not allowed if end has been called\n  if (this._ending) {\n    throw new WriteAfterEndError();\n  }\n\n  // Validate input and shift parameters if necessary\n  if (!(typeof data === \"string\" || typeof data === \"object\" && (\"length\" in data))) {\n    throw new TypeError(\"data should be a string, Buffer or Uint8Array\");\n  }\n  if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Ignore empty buffers, since writing them doesn't invoke the callback\n  // https://github.com/nodejs/node/issues/22066\n  if (data.length === 0) {\n    if (callback) {\n      callback();\n    }\n    return;\n  }\n  // Only write when we don't exceed the maximum body length\n  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {\n    this._requestBodyLength += data.length;\n    this._requestBodyBuffers.push({ data: data, encoding: encoding });\n    this._currentRequest.write(data, encoding, callback);\n  }\n  // Error when we exceed the maximum body length\n  else {\n    this.emit(\"error\", new MaxBodyLengthExceededError());\n    this.abort();\n  }\n};\n\n// Ends the current native request\nRedirectableRequest.prototype.end = function (data, encoding, callback) {\n  // Shift parameters if necessary\n  if (typeof data === \"function\") {\n    callback = data;\n    data = encoding = null;\n  }\n  else if (typeof encoding === \"function\") {\n    callback = encoding;\n    encoding = null;\n  }\n\n  // Write data if needed and end\n  if (!data) {\n    this._ended = this._ending = true;\n    this._currentRequest.end(null, null, callback);\n  }\n  else {\n    var self = this;\n    var currentRequest = this._currentRequest;\n    this.write(data, encoding, function () {\n      self._ended = true;\n      currentRequest.end(null, null, callback);\n    });\n    this._ending = true;\n  }\n};\n\n// Sets a header value on the current native request\nRedirectableRequest.prototype.setHeader = function (name, value) {\n  this._options.headers[name] = value;\n  this._currentRequest.setHeader(name, value);\n};\n\n// Clears a header value on the current native request\nRedirectableRequest.prototype.removeHeader = function (name) {\n  delete this._options.headers[name];\n  this._currentRequest.removeHeader(name);\n};\n\n// Global timeout for all underlying requests\nRedirectableRequest.prototype.setTimeout = function (msecs, callback) {\n  var self = this;\n\n  // Destroys the socket on timeout\n  function destroyOnTimeout(socket) {\n    socket.setTimeout(msecs);\n    socket.removeListener(\"timeout\", socket.destroy);\n    socket.addListener(\"timeout\", socket.destroy);\n  }\n\n  // Sets up a timer to trigger a timeout event\n  function startTimer(socket) {\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n    }\n    self._timeout = setTimeout(function () {\n      self.emit(\"timeout\");\n      clearTimer();\n    }, msecs);\n    destroyOnTimeout(socket);\n  }\n\n  // Stops a timeout from triggering\n  function clearTimer() {\n    // Clear the timeout\n    if (self._timeout) {\n      clearTimeout(self._timeout);\n      self._timeout = null;\n    }\n\n    // Clean up all attached listeners\n    self.removeListener(\"abort\", clearTimer);\n    self.removeListener(\"error\", clearTimer);\n    self.removeListener(\"response\", clearTimer);\n    if (callback) {\n      self.removeListener(\"timeout\", callback);\n    }\n    if (!self.socket) {\n      self._currentRequest.removeListener(\"socket\", startTimer);\n    }\n  }\n\n  // Attach callback if passed\n  if (callback) {\n    this.on(\"timeout\", callback);\n  }\n\n  // Start the timer if or when the socket is opened\n  if (this.socket) {\n    startTimer(this.socket);\n  }\n  else {\n    this._currentRequest.once(\"socket\", startTimer);\n  }\n\n  // Clean up on events\n  this.on(\"socket\", destroyOnTimeout);\n  this.on(\"abort\", clearTimer);\n  this.on(\"error\", clearTimer);\n  this.on(\"response\", clearTimer);\n\n  return this;\n};\n\n// Proxy all other public ClientRequest methods\n[\n  \"flushHeaders\", \"getHeader\",\n  \"setNoDelay\", \"setSocketKeepAlive\",\n].forEach(function (method) {\n  RedirectableRequest.prototype[method] = function (a, b) {\n    return this._currentRequest[method](a, b);\n  };\n});\n\n// Proxy all public ClientRequest properties\n[\"aborted\", \"connection\", \"socket\"].forEach(function (property) {\n  Object.defineProperty(RedirectableRequest.prototype, property, {\n    get: function () { return this._currentRequest[property]; },\n  });\n});\n\nRedirectableRequest.prototype._sanitizeOptions = function (options) {\n  // Ensure headers are always present\n  if (!options.headers) {\n    options.headers = {};\n  }\n\n  // Since http.request treats host as an alias of hostname,\n  // but the url module interprets host as hostname plus port,\n  // eliminate the host property to avoid confusion.\n  if (options.host) {\n    // Use hostname if set, because it has precedence\n    if (!options.hostname) {\n      options.hostname = options.host;\n    }\n    delete options.host;\n  }\n\n  // Complete the URL object when necessary\n  if (!options.pathname && options.path) {\n    var searchPos = options.path.indexOf(\"?\");\n    if (searchPos < 0) {\n      options.pathname = options.path;\n    }\n    else {\n      options.pathname = options.path.substring(0, searchPos);\n      options.search = options.path.substring(searchPos);\n    }\n  }\n};\n\n\n// Executes the next native request (initial or redirect)\nRedirectableRequest.prototype._performRequest = function () {\n  // Load the native protocol\n  var protocol = this._options.protocol;\n  var nativeProtocol = this._options.nativeProtocols[protocol];\n  if (!nativeProtocol) {\n    this.emit(\"error\", new TypeError(\"Unsupported protocol \" + protocol));\n    return;\n  }\n\n  // If specified, use the agent corresponding to the protocol\n  // (HTTP and HTTPS use different types of agents)\n  if (this._options.agents) {\n    var scheme = protocol.substr(0, protocol.length - 1);\n    this._options.agent = this._options.agents[scheme];\n  }\n\n  // Create the native request\n  var request = this._currentRequest =\n        nativeProtocol.request(this._options, this._onNativeResponse);\n  this._currentUrl = url.format(this._options);\n\n  // Set up event handlers\n  request._redirectable = this;\n  for (var e = 0; e < events.length; e++) {\n    request.on(events[e], eventHandlers[events[e]]);\n  }\n\n  // End a redirected request\n  // (The first request must be ended explicitly with RedirectableRequest#end)\n  if (this._isRedirect) {\n    // Write the request entity and end.\n    var i = 0;\n    var self = this;\n    var buffers = this._requestBodyBuffers;\n    (function writeNext(error) {\n      // Only write if this request has not been redirected yet\n      /* istanbul ignore else */\n      if (request === self._currentRequest) {\n        // Report any write errors\n        /* istanbul ignore if */\n        if (error) {\n          self.emit(\"error\", error);\n        }\n        // Write the next buffer if there are still left\n        else if (i < buffers.length) {\n          var buffer = buffers[i++];\n          /* istanbul ignore else */\n          if (!request.finished) {\n            request.write(buffer.data, buffer.encoding, writeNext);\n          }\n        }\n        // End the request if `end` has been called on us\n        else if (self._ended) {\n          request.end();\n        }\n      }\n    }());\n  }\n};\n\n// Processes a response from the current native request\nRedirectableRequest.prototype._processResponse = function (response) {\n  // Store the redirected response\n  var statusCode = response.statusCode;\n  if (this._options.trackRedirects) {\n    this._redirects.push({\n      url: this._currentUrl,\n      headers: response.headers,\n      statusCode: statusCode,\n    });\n  }\n\n  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates\n  // that further action needs to be taken by the user agent in order to\n  // fulfill the request. If a Location header field is provided,\n  // the user agent MAY automatically redirect its request to the URI\n  // referenced by the Location field value,\n  // even if the specific status code is not understood.\n\n  // If the response is not a redirect; return it as-is\n  var location = response.headers.location;\n  if (!location || this._options.followRedirects === false ||\n      statusCode < 300 || statusCode >= 400) {\n    response.responseUrl = this._currentUrl;\n    response.redirects = this._redirects;\n    this.emit(\"response\", response);\n\n    // Clean up\n    this._requestBodyBuffers = [];\n    return;\n  }\n\n  // The response is a redirect, so abort the current request\n  abortRequest(this._currentRequest);\n  // Discard the remainder of the response to avoid waiting for data\n  response.destroy();\n\n  // RFC7231§6.4: A client SHOULD detect and intervene\n  // in cyclical redirections (i.e., \"infinite\" redirection loops).\n  if (++this._redirectCount > this._options.maxRedirects) {\n    this.emit(\"error\", new TooManyRedirectsError());\n    return;\n  }\n\n  // RFC7231§6.4: Automatic redirection needs to done with\n  // care for methods not known to be safe, […]\n  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change\n  // the request method from POST to GET for the subsequent request.\n  if ((statusCode === 301 || statusCode === 302) && this._options.method === \"POST\" ||\n      // RFC7231§6.4.4: The 303 (See Other) status code indicates that\n      // the server is redirecting the user agent to a different resource […]\n      // A user agent can perform a retrieval request targeting that URI\n      // (a GET or HEAD request if using HTTP) […]\n      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {\n    this._options.method = \"GET\";\n    // Drop a possible entity and headers related to it\n    this._requestBodyBuffers = [];\n    removeMatchingHeaders(/^content-/i, this._options.headers);\n  }\n\n  // Drop the Host header, as the redirect might lead to a different host\n  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);\n\n  // If the redirect is relative, carry over the host of the last request\n  var currentUrlParts = url.parse(this._currentUrl);\n  var currentHost = currentHostHeader || currentUrlParts.host;\n  var currentUrl = /^\\w+:/.test(location) ? this._currentUrl :\n    url.format(Object.assign(currentUrlParts, { host: currentHost }));\n\n  // Determine the URL of the redirection\n  var redirectUrl;\n  try {\n    redirectUrl = url.resolve(currentUrl, location);\n  }\n  catch (cause) {\n    this.emit(\"error\", new RedirectionError(cause));\n    return;\n  }\n\n  // Create the redirected request\n  debug(\"redirecting to\", redirectUrl);\n  this._isRedirect = true;\n  var redirectUrlParts = url.parse(redirectUrl);\n  Object.assign(this._options, redirectUrlParts);\n\n  // Drop confidential headers when redirecting to a less secure protocol\n  // or to a different domain that is not a superdomain\n  if (redirectUrlParts.protocol !== currentUrlParts.protocol &&\n     redirectUrlParts.protocol !== \"https:\" ||\n     redirectUrlParts.host !== currentHost &&\n     !isSubdomain(redirectUrlParts.host, currentHost)) {\n    removeMatchingHeaders(/^(?:authorization|cookie)$/i, this._options.headers);\n  }\n\n  // Evaluate the beforeRedirect callback\n  if (typeof this._options.beforeRedirect === \"function\") {\n    var responseDetails = { headers: response.headers };\n    try {\n      this._options.beforeRedirect.call(null, this._options, responseDetails);\n    }\n    catch (err) {\n      this.emit(\"error\", err);\n      return;\n    }\n    this._sanitizeOptions(this._options);\n  }\n\n  // Perform the redirected request\n  try {\n    this._performRequest();\n  }\n  catch (cause) {\n    this.emit(\"error\", new RedirectionError(cause));\n  }\n};\n\n// Wraps the key/value object of protocols with redirect functionality\nfunction wrap(protocols) {\n  // Default settings\n  var exports = {\n    maxRedirects: 21,\n    maxBodyLength: 10 * 1024 * 1024,\n  };\n\n  // Wrap each protocol\n  var nativeProtocols = {};\n  Object.keys(protocols).forEach(function (scheme) {\n    var protocol = scheme + \":\";\n    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];\n    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);\n\n    // Executes a request, following redirects\n    function request(input, options, callback) {\n      // Parse parameters\n      if (typeof input === \"string\") {\n        var urlStr = input;\n        try {\n          input = urlToOptions(new URL(urlStr));\n        }\n        catch (err) {\n          /* istanbul ignore next */\n          input = url.parse(urlStr);\n        }\n      }\n      else if (URL && (input instanceof URL)) {\n        input = urlToOptions(input);\n      }\n      else {\n        callback = options;\n        options = input;\n        input = { protocol: protocol };\n      }\n      if (typeof options === \"function\") {\n        callback = options;\n        options = null;\n      }\n\n      // Set defaults\n      options = Object.assign({\n        maxRedirects: exports.maxRedirects,\n        maxBodyLength: exports.maxBodyLength,\n      }, input, options);\n      options.nativeProtocols = nativeProtocols;\n\n      assert.equal(options.protocol, protocol, \"protocol mismatch\");\n      debug(\"options\", options);\n      return new RedirectableRequest(options, callback);\n    }\n\n    // Executes a GET request, following redirects\n    function get(input, options, callback) {\n      var wrappedRequest = wrappedProtocol.request(input, options, callback);\n      wrappedRequest.end();\n      return wrappedRequest;\n    }\n\n    // Expose the properties on the wrapped protocol\n    Object.defineProperties(wrappedProtocol, {\n      request: { value: request, configurable: true, enumerable: true, writable: true },\n      get: { value: get, configurable: true, enumerable: true, writable: true },\n    });\n  });\n  return exports;\n}\n\n/* istanbul ignore next */\nfunction noop() { /* empty */ }\n\n// from https://github.com/nodejs/node/blob/master/lib/internal/url.js\nfunction urlToOptions(urlObject) {\n  var options = {\n    protocol: urlObject.protocol,\n    hostname: urlObject.hostname.startsWith(\"[\") ?\n      /* istanbul ignore next */\n      urlObject.hostname.slice(1, -1) :\n      urlObject.hostname,\n    hash: urlObject.hash,\n    search: urlObject.search,\n    pathname: urlObject.pathname,\n    path: urlObject.pathname + urlObject.search,\n    href: urlObject.href,\n  };\n  if (urlObject.port !== \"\") {\n    options.port = Number(urlObject.port);\n  }\n  return options;\n}\n\nfunction removeMatchingHeaders(regex, headers) {\n  var lastValue;\n  for (var header in headers) {\n    if (regex.test(header)) {\n      lastValue = headers[header];\n      delete headers[header];\n    }\n  }\n  return (lastValue === null || typeof lastValue === \"undefined\") ?\n    undefined : String(lastValue).trim();\n}\n\nfunction createErrorType(code, defaultMessage) {\n  function CustomError(cause) {\n    Error.captureStackTrace(this, this.constructor);\n    if (!cause) {\n      this.message = defaultMessage;\n    }\n    else {\n      this.message = defaultMessage + \": \" + cause.message;\n      this.cause = cause;\n    }\n  }\n  CustomError.prototype = new Error();\n  CustomError.prototype.constructor = CustomError;\n  CustomError.prototype.name = \"Error [\" + code + \"]\";\n  CustomError.prototype.code = code;\n  return CustomError;\n}\n\nfunction abortRequest(request) {\n  for (var e = 0; e < events.length; e++) {\n    request.removeListener(events[e], eventHandlers[events[e]]);\n  }\n  request.on(\"error\", noop);\n  request.abort();\n}\n\nfunction isSubdomain(subdomain, domain) {\n  const dot = subdomain.length - domain.length - 1;\n  return dot > 0 && subdomain[dot] === \".\" && subdomain.endsWith(domain);\n}\n\n// Exports\nmodule.exports = wrap({ http: http, https: https });\nmodule.exports.wrap = wrap;\n","'use strict';\n\nmodule.exports = (flag, argv = process.argv) => {\n\tconst prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');\n\tconst position = argv.indexOf(prefix + flag);\n\tconst terminatorPosition = argv.indexOf('--');\n\treturn position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);\n};\n","'use strict'\n\nconst https = require('https')\nconst http = require('http')\nconst { URL } = require('url')\n\nclass HttpProxyAgent extends http.Agent {\n  constructor (options) {\n    const { proxy, ...opts } = options\n    super(opts)\n    this.proxy = typeof proxy === 'string'\n      ? new URL(proxy)\n      : proxy\n  }\n\n  createConnection (options, callback) {\n    const requestOptions = {\n      method: 'CONNECT',\n      host: this.proxy.hostname,\n      port: this.proxy.port,\n      path: `${options.host}:${options.port}`,\n      setHost: false,\n      headers: { connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },\n      agent: false\n    }\n\n    if (this.proxy.username || this.proxy.password) {\n      const base64 = Buffer.from(`${this.proxy.username || ''}:${this.proxy.password || ''}`).toString('base64')\n      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`\n    }\n\n    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)\n    request.once('connect', (response, socket, head) => {\n      request.removeAllListeners()\n      socket.removeAllListeners()\n      if (response.statusCode === 200) {\n        callback(null, socket)\n      } else {\n        callback(new Error(`Bad response: ${response.statusCode}`), null)\n      }\n    })\n\n    request.once('error', err => {\n      request.removeAllListeners()\n      callback(err, null)\n    })\n\n    request.end()\n  }\n}\n\nclass HttpsProxyAgent extends https.Agent {\n  constructor (options) {\n    const { proxy, ...opts } = options\n    super(opts)\n    this.proxy = typeof proxy === 'string'\n      ? new URL(proxy)\n      : proxy\n  }\n\n  createConnection (options, callback) {\n    const requestOptions = {\n      method: 'CONNECT',\n      host: this.proxy.hostname,\n      port: this.proxy.port,\n      path: `${options.host}:${options.port}`,\n      setHost: false,\n      headers: { connection: this.keepAlive ? 'keep-alive' : 'close', host: `${options.host}:${options.port}` },\n      agent: false\n    }\n\n    if (this.proxy.username || this.proxy.password) {\n      const base64 = Buffer.from(`${this.proxy.username || ''}:${this.proxy.password || ''}`).toString('base64')\n      requestOptions.headers['proxy-authorization'] = `Basic ${base64}`\n    }\n\n    const request = (this.proxy.protocol === 'http:' ? http : https).request(requestOptions)\n    request.once('connect', (response, socket, head) => {\n      request.removeAllListeners()\n      socket.removeAllListeners()\n      if (response.statusCode === 200) {\n        const secureSocket = super.createConnection({ ...options, socket })\n        callback(null, secureSocket)\n      } else {\n        callback(new Error(`Bad response: ${response.statusCode}`), null)\n      }\n    })\n\n    request.once('error', err => {\n      request.removeAllListeners()\n      callback(err, null)\n    })\n\n    request.end()\n  }\n}\n\nmodule.exports = {\n  HttpProxyAgent,\n  HttpsProxyAgent\n}\n","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar w = d * 7;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isFinite(val)) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'weeks':\n    case 'week':\n    case 'w':\n      return n * w;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (msAbs >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (msAbs >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (msAbs >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  var msAbs = Math.abs(ms);\n  if (msAbs >= d) {\n    return plural(ms, msAbs, d, 'day');\n  }\n  if (msAbs >= h) {\n    return plural(ms, msAbs, h, 'hour');\n  }\n  if (msAbs >= m) {\n    return plural(ms, msAbs, m, 'minute');\n  }\n  if (msAbs >= s) {\n    return plural(ms, msAbs, s, 'second');\n  }\n  return ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, msAbs, n, name) {\n  var isPlural = msAbs >= n * 1.5;\n  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');\n}\n","'use strict'\n\nconst hasBuffer = typeof Buffer !== 'undefined'\nconst suspectProtoRx = /\"(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])(?:p|\\\\u0070)(?:r|\\\\u0072)(?:o|\\\\u006[Ff])(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:_|\\\\u005[Ff])(?:_|\\\\u005[Ff])\"\\s*:/\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/\n\nfunction parse (text, reviver, options) {\n  // Normalize arguments\n  if (options == null) {\n    if (reviver !== null && typeof reviver === 'object') {\n      options = reviver\n      reviver = undefined\n    } else {\n      options = {}\n    }\n  }\n\n  const protoAction = options.protoAction || 'error'\n  const constructorAction = options.constructorAction || 'error'\n\n  if (hasBuffer && Buffer.isBuffer(text)) {\n    text = text.toString()\n  }\n\n  // BOM checker\n  if (text && text.charCodeAt(0) === 0xFEFF) {\n    text = text.slice(1)\n  }\n\n  // Parse normally, allowing exceptions\n  const obj = JSON.parse(text, reviver)\n\n  // options: 'error' (default) / 'remove' / 'ignore'\n  if (protoAction === 'ignore' && constructorAction === 'ignore') {\n    return obj\n  }\n\n  // Ignore null and non-objects\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }\n\n  if (protoAction !== 'ignore' && constructorAction !== 'ignore') {\n    if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  } else if (protoAction !== 'ignore' && constructorAction === 'ignore') {\n    if (suspectProtoRx.test(text) === false) {\n      return obj\n    }\n  } else {\n    if (suspectConstructorRx.test(text) === false) {\n      return obj\n    }\n  }\n\n  // Scan result for proto keys\n  scan(obj, { protoAction, constructorAction })\n\n  return obj\n}\n\nfunction scan (obj, { protoAction = 'error', constructorAction = 'error' } = {}) {\n  let next = [obj]\n\n  while (next.length) {\n    const nodes = next\n    next = []\n\n    for (const node of nodes) {\n      if (protoAction !== 'ignore' && Object.prototype.hasOwnProperty.call(node, '__proto__')) { // Avoid calling node.hasOwnProperty directly\n        if (protoAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.__proto__ // eslint-disable-line no-proto\n      }\n\n      if (constructorAction !== 'ignore' &&\n          Object.prototype.hasOwnProperty.call(node, 'constructor') &&\n          Object.prototype.hasOwnProperty.call(node.constructor, 'prototype')) { // Avoid calling node.hasOwnProperty directly\n        if (constructorAction === 'error') {\n          throw new SyntaxError('Object contains forbidden prototype property')\n        }\n\n        delete node.constructor\n      }\n\n      for (const key in node) {\n        const value = node[key]\n        if (value && typeof value === 'object') {\n          next.push(node[key])\n        }\n      }\n    }\n  }\n}\n\nfunction safeParse (text, reviver) {\n  try {\n    return parse(text, reviver)\n  } catch (ignoreError) {\n    return null\n  }\n}\n\nmodule.exports = {\n  parse,\n  scan,\n  safeParse\n}\n","'use strict';\nconst os = require('os');\nconst tty = require('tty');\nconst hasFlag = require('has-flag');\n\nconst {env} = process;\n\nlet forceColor;\nif (hasFlag('no-color') ||\n\thasFlag('no-colors') ||\n\thasFlag('color=false') ||\n\thasFlag('color=never')) {\n\tforceColor = 0;\n} else if (hasFlag('color') ||\n\thasFlag('colors') ||\n\thasFlag('color=true') ||\n\thasFlag('color=always')) {\n\tforceColor = 1;\n}\n\nif ('FORCE_COLOR' in env) {\n\tif (env.FORCE_COLOR === 'true') {\n\t\tforceColor = 1;\n\t} else if (env.FORCE_COLOR === 'false') {\n\t\tforceColor = 0;\n\t} else {\n\t\tforceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);\n\t}\n}\n\nfunction translateLevel(level) {\n\tif (level === 0) {\n\t\treturn false;\n\t}\n\n\treturn {\n\t\tlevel,\n\t\thasBasic: true,\n\t\thas256: level >= 2,\n\t\thas16m: level >= 3\n\t};\n}\n\nfunction supportsColor(haveStream, streamIsTTY) {\n\tif (forceColor === 0) {\n\t\treturn 0;\n\t}\n\n\tif (hasFlag('color=16m') ||\n\t\thasFlag('color=full') ||\n\t\thasFlag('color=truecolor')) {\n\t\treturn 3;\n\t}\n\n\tif (hasFlag('color=256')) {\n\t\treturn 2;\n\t}\n\n\tif (haveStream && !streamIsTTY && forceColor === undefined) {\n\t\treturn 0;\n\t}\n\n\tconst min = forceColor || 0;\n\n\tif (env.TERM === 'dumb') {\n\t\treturn min;\n\t}\n\n\tif (process.platform === 'win32') {\n\t\t// Windows 10 build 10586 is the first Windows release that supports 256 colors.\n\t\t// Windows 10 build 14931 is the first release that supports 16m/TrueColor.\n\t\tconst osRelease = os.release().split('.');\n\t\tif (\n\t\t\tNumber(osRelease[0]) >= 10 &&\n\t\t\tNumber(osRelease[2]) >= 10586\n\t\t) {\n\t\t\treturn Number(osRelease[2]) >= 14931 ? 3 : 2;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\tif ('CI' in env) {\n\t\tif (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn min;\n\t}\n\n\tif ('TEAMCITY_VERSION' in env) {\n\t\treturn /^(9\\.(0*[1-9]\\d*)\\.|\\d{2,}\\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;\n\t}\n\n\tif (env.COLORTERM === 'truecolor') {\n\t\treturn 3;\n\t}\n\n\tif ('TERM_PROGRAM' in env) {\n\t\tconst version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);\n\n\t\tswitch (env.TERM_PROGRAM) {\n\t\t\tcase 'iTerm.app':\n\t\t\t\treturn version >= 3 ? 3 : 2;\n\t\t\tcase 'Apple_Terminal':\n\t\t\t\treturn 2;\n\t\t\t// No default\n\t\t}\n\t}\n\n\tif (/-256(color)?$/i.test(env.TERM)) {\n\t\treturn 2;\n\t}\n\n\tif (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {\n\t\treturn 1;\n\t}\n\n\tif ('COLORTERM' in env) {\n\t\treturn 1;\n\t}\n\n\treturn min;\n}\n\nfunction getSupportLevel(stream) {\n\tconst level = supportsColor(stream, stream && stream.isTTY);\n\treturn translateLevel(level);\n}\n\nmodule.exports = {\n\tsupportsColor: getSupportLevel,\n\tstdout: translateLevel(supportsColor(true, tty.isatty(1))),\n\tstderr: translateLevel(supportsColor(true, tty.isatty(2)))\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global global, define, System, Reflect, Promise */\r\nvar __extends;\r\nvar __assign;\r\nvar __rest;\r\nvar __decorate;\r\nvar __param;\r\nvar __metadata;\r\nvar __awaiter;\r\nvar __generator;\r\nvar __exportStar;\r\nvar __values;\r\nvar __read;\r\nvar __spread;\r\nvar __spreadArrays;\r\nvar __spreadArray;\r\nvar __await;\r\nvar __asyncGenerator;\r\nvar __asyncDelegator;\r\nvar __asyncValues;\r\nvar __makeTemplateObject;\r\nvar __importStar;\r\nvar __importDefault;\r\nvar __classPrivateFieldGet;\r\nvar __classPrivateFieldSet;\r\nvar __createBinding;\r\n(function (factory) {\r\n    var root = typeof global === \"object\" ? global : typeof self === \"object\" ? self : typeof this === \"object\" ? this : {};\r\n    if (typeof define === \"function\" && define.amd) {\r\n        define(\"tslib\", [\"exports\"], function (exports) { factory(createExporter(root, createExporter(exports))); });\r\n    }\r\n    else if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        factory(createExporter(root, createExporter(module.exports)));\r\n    }\r\n    else {\r\n        factory(createExporter(root));\r\n    }\r\n    function createExporter(exports, previous) {\r\n        if (exports !== root) {\r\n            if (typeof Object.create === \"function\") {\r\n                Object.defineProperty(exports, \"__esModule\", { value: true });\r\n            }\r\n            else {\r\n                exports.__esModule = true;\r\n            }\r\n        }\r\n        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };\r\n    }\r\n})\r\n(function (exporter) {\r\n    var extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n\r\n    __extends = function (d, b) {\r\n        if (typeof b !== \"function\" && b !== null)\r\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n        extendStatics(d, b);\r\n        function __() { this.constructor = d; }\r\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n    };\r\n\r\n    __assign = Object.assign || function (t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n\r\n    __rest = function (s, e) {\r\n        var t = {};\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n            t[p] = s[p];\r\n        if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                    t[p[i]] = s[p[i]];\r\n            }\r\n        return t;\r\n    };\r\n\r\n    __decorate = function (decorators, target, key, desc) {\r\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n    };\r\n\r\n    __param = function (paramIndex, decorator) {\r\n        return function (target, key) { decorator(target, key, paramIndex); }\r\n    };\r\n\r\n    __metadata = function (metadataKey, metadataValue) {\r\n        if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n    };\r\n\r\n    __awaiter = function (thisArg, _arguments, P, generator) {\r\n        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n        return new (P || (P = Promise))(function (resolve, reject) {\r\n            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n            function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n            step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n        });\r\n    };\r\n\r\n    __generator = function (thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    };\r\n\r\n    __exportStar = function(m, o) {\r\n        for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n    };\r\n\r\n    __createBinding = Object.create ? (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n    }) : (function(o, m, k, k2) {\r\n        if (k2 === undefined) k2 = k;\r\n        o[k2] = m[k];\r\n    });\r\n\r\n    __values = function (o) {\r\n        var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n        if (m) return m.call(o);\r\n        if (o && typeof o.length === \"number\") return {\r\n            next: function () {\r\n                if (o && i >= o.length) o = void 0;\r\n                return { value: o && o[i++], done: !o };\r\n            }\r\n        };\r\n        throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n    };\r\n\r\n    __read = function (o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spread = function () {\r\n        for (var ar = [], i = 0; i < arguments.length; i++)\r\n            ar = ar.concat(__read(arguments[i]));\r\n        return ar;\r\n    };\r\n\r\n    /** @deprecated */\r\n    __spreadArrays = function () {\r\n        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n        for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n                r[k] = a[j];\r\n        return r;\r\n    };\r\n\r\n    __spreadArray = function (to, from, pack) {\r\n        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n            if (ar || !(i in from)) {\r\n                if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n                ar[i] = from[i];\r\n            }\r\n        }\r\n        return to.concat(ar || Array.prototype.slice.call(from));\r\n    };\r\n\r\n    __await = function (v) {\r\n        return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n    };\r\n\r\n    __asyncGenerator = function (thisArg, _arguments, generator) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n        return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n        function fulfill(value) { resume(\"next\", value); }\r\n        function reject(value) { resume(\"throw\", value); }\r\n        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n    };\r\n\r\n    __asyncDelegator = function (o) {\r\n        var i, p;\r\n        return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n    };\r\n\r\n    __asyncValues = function (o) {\r\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n        var m = o[Symbol.asyncIterator], i;\r\n        return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n    };\r\n\r\n    __makeTemplateObject = function (cooked, raw) {\r\n        if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n        return cooked;\r\n    };\r\n\r\n    var __setModuleDefault = Object.create ? (function(o, v) {\r\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n    }) : function(o, v) {\r\n        o[\"default\"] = v;\r\n    };\r\n\r\n    __importStar = function (mod) {\r\n        if (mod && mod.__esModule) return mod;\r\n        var result = {};\r\n        if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n        __setModuleDefault(result, mod);\r\n        return result;\r\n    };\r\n\r\n    __importDefault = function (mod) {\r\n        return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n    };\r\n\r\n    __classPrivateFieldGet = function (receiver, state, kind, f) {\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n        return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n    };\r\n\r\n    __classPrivateFieldSet = function (receiver, state, value, kind, f) {\r\n        if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n        if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n        if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n        return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n    };\r\n\r\n    exporter(\"__extends\", __extends);\r\n    exporter(\"__assign\", __assign);\r\n    exporter(\"__rest\", __rest);\r\n    exporter(\"__decorate\", __decorate);\r\n    exporter(\"__param\", __param);\r\n    exporter(\"__metadata\", __metadata);\r\n    exporter(\"__awaiter\", __awaiter);\r\n    exporter(\"__generator\", __generator);\r\n    exporter(\"__exportStar\", __exportStar);\r\n    exporter(\"__createBinding\", __createBinding);\r\n    exporter(\"__values\", __values);\r\n    exporter(\"__read\", __read);\r\n    exporter(\"__spread\", __spread);\r\n    exporter(\"__spreadArrays\", __spreadArrays);\r\n    exporter(\"__spreadArray\", __spreadArray);\r\n    exporter(\"__await\", __await);\r\n    exporter(\"__asyncGenerator\", __asyncGenerator);\r\n    exporter(\"__asyncDelegator\", __asyncDelegator);\r\n    exporter(\"__asyncValues\", __asyncValues);\r\n    exporter(\"__makeTemplateObject\", __makeTemplateObject);\r\n    exporter(\"__importStar\", __importStar);\r\n    exporter(\"__importDefault\", __importDefault);\r\n    exporter(\"__classPrivateFieldGet\", __classPrivateFieldGet);\r\n    exporter(\"__classPrivateFieldSet\", __classPrivateFieldSet);\r\n});\r\n","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","'use strict'\n\nconst Client = require('./lib/client')\nconst Dispatcher = require('./lib/dispatcher')\nconst errors = require('./lib/core/errors')\nconst Pool = require('./lib/pool')\nconst BalancedPool = require('./lib/balanced-pool')\nconst Agent = require('./lib/agent')\nconst util = require('./lib/core/util')\nconst { InvalidArgumentError } = errors\nconst api = require('./lib/api')\nconst buildConnector = require('./lib/core/connect')\nconst MockClient = require('./lib/mock/mock-client')\nconst MockAgent = require('./lib/mock/mock-agent')\nconst MockPool = require('./lib/mock/mock-pool')\nconst mockErrors = require('./lib/mock/mock-errors')\nconst ProxyAgent = require('./lib/proxy-agent')\n\nconst nodeVersion = process.versions.node.split('.')\nconst nodeMajor = Number(nodeVersion[0])\nconst nodeMinor = Number(nodeVersion[1])\n\nObject.assign(Dispatcher.prototype, api)\n\nmodule.exports.Dispatcher = Dispatcher\nmodule.exports.Client = Client\nmodule.exports.Pool = Pool\nmodule.exports.BalancedPool = BalancedPool\nmodule.exports.Agent = Agent\nmodule.exports.ProxyAgent = ProxyAgent\n\nmodule.exports.buildConnector = buildConnector\nmodule.exports.errors = errors\n\nlet globalDispatcher = new Agent()\n\nfunction setGlobalDispatcher (agent) {\n  if (!agent || typeof agent.dispatch !== 'function') {\n    throw new InvalidArgumentError('Argument agent must implement Agent')\n  }\n  globalDispatcher = agent\n}\n\nfunction getGlobalDispatcher () {\n  return globalDispatcher\n}\n\nfunction makeDispatcher (fn) {\n  return (url, opts, handler) => {\n    if (typeof opts === 'function') {\n      handler = opts\n      opts = null\n    }\n\n    if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {\n      throw new InvalidArgumentError('invalid url')\n    }\n\n    if (opts != null && typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (opts && opts.path != null) {\n      if (typeof opts.path !== 'string') {\n        throw new InvalidArgumentError('invalid opts.path')\n      }\n\n      url = new URL(opts.path, util.parseOrigin(url))\n    } else {\n      if (!opts) {\n        opts = typeof url === 'object' ? url : {}\n      }\n\n      url = util.parseURL(url)\n    }\n\n    const { agent, dispatcher = getGlobalDispatcher() } = opts\n\n    if (agent) {\n      throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?')\n    }\n\n    return fn.call(dispatcher, {\n      ...opts,\n      origin: url.origin,\n      path: url.search ? `${url.pathname}${url.search}` : url.pathname,\n      method: opts.method || (opts.body ? 'PUT' : 'GET')\n    }, handler)\n  }\n}\n\nmodule.exports.setGlobalDispatcher = setGlobalDispatcher\nmodule.exports.getGlobalDispatcher = getGlobalDispatcher\n\nif (nodeMajor > 16 || (nodeMajor === 16 && nodeMinor >= 5)) {\n  let fetchImpl = null\n  module.exports.fetch = async function fetch (resource, init) {\n    if (!fetchImpl) {\n      fetchImpl = require('./lib/fetch')\n    }\n    const dispatcher = getGlobalDispatcher()\n    return fetchImpl.call(dispatcher, resource, init)\n  }\n  module.exports.Headers = require('./lib/fetch/headers').Headers\n  module.exports.Response = require('./lib/fetch/response').Response\n  module.exports.Request = require('./lib/fetch/request').Request\n  module.exports.FormData = require('./lib/fetch/formdata').FormData\n  module.exports.File = require('./lib/fetch/file').File\n}\n\nmodule.exports.request = makeDispatcher(api.request)\nmodule.exports.stream = makeDispatcher(api.stream)\nmodule.exports.pipeline = makeDispatcher(api.pipeline)\nmodule.exports.connect = makeDispatcher(api.connect)\nmodule.exports.upgrade = makeDispatcher(api.upgrade)\n\nmodule.exports.MockClient = MockClient\nmodule.exports.MockPool = MockPool\nmodule.exports.MockAgent = MockAgent\nmodule.exports.mockErrors = mockErrors\n","'use strict'\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst { kClients, kRunning } = require('./core/symbols')\nconst Dispatcher = require('./dispatcher')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst RedirectHandler = require('./handler/redirect')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kDestroyed = Symbol('destroyed')\nconst kClosed = Symbol('closed')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends Dispatcher {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n    this[kClosed] = false\n    this[kDestroyed] = false\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      let key\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin)\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const ref = this[kClients].get(key)\n\n      let dispatcher = ref ? ref.deref() : null\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions])\n          .on('drain', this[kOnDrain])\n          .on('connect', this[kOnConnect])\n          .on('disconnect', this[kOnDisconnect])\n          .on('connectionError', this[kOnConnectionError])\n\n        this[kClients].set(key, new WeakRef(dispatcher))\n        this[kFinalizer].register(dispatcher, key)\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      return dispatcher.dispatch(opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  close (callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises)\n    }\n\n    // Should never error.\n    Promise.all(closePromises).then(() => process.nextTick(callback))\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises)\n    }\n\n    // Should never error.\n    Promise.all(destroyPromises).then(() => process.nextTick(callback))\n  }\n}\n\nmodule.exports = Agent\n","const { RequestAbortedError } = require('../core/errors')\n\nconst kListener = Symbol('kListener')\nconst kSignal = Symbol('kSignal')\n\nfunction abort (self) {\n  if (self.abort) {\n    self.abort()\n  } else {\n    self.onError(new RequestAbortedError())\n  }\n}\n\nfunction addSignal (self, signal) {\n  self[kSignal] = null\n  self[kListener] = null\n\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    abort(self)\n    return\n  }\n\n  self[kSignal] = signal\n  self[kListener] = () => {\n    abort(self)\n  }\n\n  if ('addEventListener' in self[kSignal]) {\n    self[kSignal].addEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].addListener('abort', self[kListener])\n  }\n}\n\nfunction removeSignal (self) {\n  if (!self[kSignal]) {\n    return\n  }\n\n  if ('removeEventListener' in self[kSignal]) {\n    self[kSignal].removeEventListener('abort', self[kListener])\n  } else {\n    self[kSignal].removeListener('abort', self[kListener])\n  }\n\n  self[kSignal] = null\n  self[kListener] = null\n}\n\nmodule.exports = {\n  addSignal,\n  removeSignal\n}\n","'use strict'\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass ConnectHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_CONNECT')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders () {\n    throw new SocketError('bad connect', null)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque, context } = this\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction connect (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      connect.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const connectHandler = new ConnectHandler(opts, callback)\n    this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = connect\n","'use strict'\n\nconst {\n  Readable,\n  Duplex,\n  PassThrough\n} = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('assert')\n\nconst kResume = Symbol('resume')\n\nclass PipelineRequest extends Readable {\n  constructor () {\n    super({ autoDestroy: true })\n\n    this[kResume] = null\n  }\n\n  _read () {\n    const { [kResume]: resume } = this\n\n    if (resume) {\n      this[kResume] = null\n      resume()\n    }\n  }\n\n  _destroy (err, callback) {\n    this._read()\n\n    callback(err)\n  }\n}\n\nclass PipelineResponse extends Readable {\n  constructor (resume) {\n    super({ autoDestroy: true })\n    this[kResume] = resume\n  }\n\n  _read () {\n    this[kResume]()\n  }\n\n  _destroy (err, callback) {\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    callback(err)\n  }\n}\n\nclass PipelineHandler extends AsyncResource {\n  constructor (opts, handler) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof handler !== 'function') {\n      throw new InvalidArgumentError('invalid handler')\n    }\n\n    const { signal, method, opaque, onInfo } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    if (method === 'CONNECT') {\n      throw new InvalidArgumentError('invalid method')\n    }\n\n    if (onInfo && typeof onInfo !== 'function') {\n      throw new InvalidArgumentError('invalid onInfo callback')\n    }\n\n    super('UNDICI_PIPELINE')\n\n    this.opaque = opaque || null\n    this.handler = handler\n    this.abort = null\n    this.context = null\n    this.onInfo = onInfo || null\n\n    this.req = new PipelineRequest().on('error', util.nop)\n\n    this.ret = new Duplex({\n      readableObjectMode: opts.objectMode,\n      autoDestroy: true,\n      read: () => {\n        const { body } = this\n\n        if (body && body.resume) {\n          body.resume()\n        }\n      },\n      write: (chunk, encoding, callback) => {\n        const { req } = this\n\n        if (req.push(chunk, encoding) || req._readableState.destroyed) {\n          callback()\n        } else {\n          req[kResume] = callback\n        }\n      },\n      destroy: (err, callback) => {\n        const { body, req, res, ret, abort } = this\n\n        if (!err && !ret._readableState.endEmitted) {\n          err = new RequestAbortedError()\n        }\n\n        if (abort && err) {\n          abort()\n        }\n\n        util.destroy(body, err)\n        util.destroy(req, err)\n        util.destroy(res, err)\n\n        removeSignal(this)\n\n        callback(err)\n      }\n    }).on('prefinish', () => {\n      const { req } = this\n\n      // Node < 15 does not call _final in same tick.\n      req.push(null)\n    })\n\n    this.res = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    const { ret, res } = this\n\n    assert(!res, 'pipeline cannot be retried')\n\n    if (ret.destroyed) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { opaque, handler, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    this.res = new PipelineResponse(resume)\n\n    let body\n    try {\n      this.handler = null\n      body = this.runInAsyncScope(handler, null, {\n        statusCode,\n        headers: util.parseHeaders(headers),\n        opaque,\n        body: this.res,\n        context\n      })\n    } catch (err) {\n      this.res.on('error', util.nop)\n      throw err\n    }\n\n    if (!body || typeof body.on !== 'function') {\n      throw new InvalidReturnValueError('expected Readable')\n    }\n\n    body\n      .on('data', (chunk) => {\n        const { ret, body } = this\n\n        if (!ret.push(chunk) && body.pause) {\n          body.pause()\n        }\n      })\n      .on('error', (err) => {\n        const { ret } = this\n\n        util.destroy(ret, err)\n      })\n      .on('end', () => {\n        const { ret } = this\n\n        ret.push(null)\n      })\n      .on('close', () => {\n        const { ret } = this\n\n        if (!ret._readableState.ended) {\n          util.destroy(ret, new RequestAbortedError())\n        }\n      })\n\n    this.body = body\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n    res.push(null)\n  }\n\n  onError (err) {\n    const { ret } = this\n    this.handler = null\n    util.destroy(ret, err)\n  }\n}\n\nfunction pipeline (opts, handler) {\n  try {\n    const pipelineHandler = new PipelineHandler(opts, handler)\n    this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler)\n    return pipelineHandler.ret\n  } catch (err) {\n    return new PassThrough().destroy(err)\n  }\n}\n\nmodule.exports = pipeline\n","'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(headers)\n    const body = new Readable(resume, abort, parsedHeaders['content-type'])\n\n    this.callback = null\n    this.res = body\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers: parsedHeaders,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n","'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, headers, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        this.onInfo({ statusCode, headers: util.parseHeaders(headers) })\n      }\n      return\n    }\n\n    this.factory = null\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers: util.parseHeaders(headers),\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n","'use strict'\n\nconst { InvalidArgumentError, RequestAbortedError, SocketError } = require('../core/errors')\nconst { AsyncResource } = require('async_hooks')\nconst util = require('../core/util')\nconst { addSignal, removeSignal } = require('./abort-signal')\nconst assert = require('assert')\n\nclass UpgradeHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    const { signal, opaque } = opts\n\n    if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n      throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n    }\n\n    super('UNDICI_UPGRADE')\n\n    this.opaque = opaque || null\n    this.callback = callback\n    this.abort = null\n    this.context = null\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = null\n  }\n\n  onHeaders () {\n    throw new SocketError('bad upgrade', null)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    const { callback, opaque, context } = this\n\n    assert.strictEqual(statusCode, 101)\n\n    removeSignal(this)\n\n    this.callback = null\n    this.runInAsyncScope(callback, null, null, {\n      headers: util.parseHeaders(headers),\n      socket,\n      opaque,\n      context\n    })\n  }\n\n  onError (err) {\n    const { callback, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n  }\n}\n\nfunction upgrade (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      upgrade.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    const upgradeHandler = new UpgradeHandler(opts, callback)\n    this.dispatch({\n      ...opts,\n      method: opts.method || 'GET',\n      upgrade: opts.protocol || 'Websocket'\n    }, upgradeHandler)\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = upgrade\n","'use strict'\n\nmodule.exports.request = require('./api-request')\nmodule.exports.stream = require('./api-stream')\nmodule.exports.pipeline = require('./api-pipeline')\nmodule.exports.upgrade = require('./api-upgrade')\nmodule.exports.connect = require('./api-connect')\n","// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../core/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor (resume, abort, contentType = '') {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      // Do nothing...\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n","'use strict'\n\nconst {\n  BalancedPoolMissingUpstreamError\n} = require('./core/errors')\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Pool = require('./pool')\nconst { kUrl } = require('./core/symbols')\n\nconst kOptions = Symbol('options')\n\nclass BalancedPool extends PoolBase {\n  constructor (upstreams = [], opts = {}) {\n    super()\n\n    this[kOptions] = opts\n\n    if (!Array.isArray(upstreams)) {\n      upstreams = [upstreams]\n    }\n\n    for (const upstream of upstreams) {\n      this.addUpstream(upstream)\n    }\n  }\n\n  addUpstream (upstream) {\n    if (this[kClients].find((pool) => (\n      pool[kUrl].origin === upstream &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))) {\n      return this\n    }\n\n    this[kAddClient](new Pool(upstream, Object.assign({}, this[kOptions])))\n\n    return this\n  }\n\n  removeUpstream (upstream) {\n    const pool = this[kClients].find((pool) => (\n      pool[kUrl].origin === upstream &&\n      pool.closed !== true &&\n      pool.destroyed !== true\n    ))\n\n    if (pool) {\n      this[kRemoveClient](pool)\n    }\n\n    return this\n  }\n\n  get upstreams () {\n    return this[kClients]\n      .filter(dispatcher => dispatcher.closed !== true && dispatcher.destroyed !== true)\n      .map((p) => p[kUrl].origin)\n  }\n\n  [kGetDispatcher] () {\n    // We validate that pools is greater than 0,\n    // otherwise we would have to wait until an upstream\n    // is added, which might never happen.\n    if (this[kClients].length === 0) {\n      throw new BalancedPoolMissingUpstreamError()\n    }\n\n    const dispatcher = this[kClients].find(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n\n    if (!dispatcher) {\n      return\n    }\n\n    this[kClients].splice(this[kClients].indexOf(dispatcher), 1)\n    this[kClients].push(dispatcher)\n\n    return dispatcher\n  }\n}\n\nmodule.exports = BalancedPool\n","'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst Request = require('./core/request')\nconst Dispatcher = require('./dispatcher')\nconst RedirectHandler = require('./handler/redirect')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  ClientDestroyedError,\n  ClientClosedError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kClosed,\n  kDestroyed,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kOnDestroyed,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter\n} = require('./core/symbols')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends Dispatcher {\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kClosed] = false\n    this[kDestroyed] = false\n    this[kServerName] = null\n    this[kOnDestroyed] = []\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  // TODO: Make private?\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  // TODO: Make private?\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections) {\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      const origin = opts.origin || this[kUrl].origin\n\n      const request = new Request(origin, opts, handler)\n\n      this[kQueue].push(request)\n      if (this[kResuming]) {\n        // Do nothing.\n      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n        // Wait a tick in case stream/iterator is ended in the same tick.\n        this[kResuming] = 1\n        process.nextTick(resume, this)\n      } else {\n        resume(this, true)\n      }\n\n      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n        this[kNeedDrain] = 2\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    this[kClosed] = true\n\n    if (!this[kSize]) {\n      this.destroy(callback)\n    } else {\n      this[kOnDestroyed].push(callback)\n    }\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    const requests = this[kQueue].splice(this[kPendingIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    if (!this[kSocket]) {\n      queueMicrotask(onDestroyed)\n    } else {\n      util.destroy(this[kSocket].on('close', onDestroyed), err)\n    }\n\n    resume(this)\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n    // TODO: Emit warning?\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.trailer = ''\n    this.keepAlive = ''\n    this.contentLength = ''\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    // TODO (perf): Can we avoid this copy somehow?\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  finish () {\n    try {\n      try {\n        currentParser = this\n        this.llhttp.llhttp_finish(this.ptr) // TODO (fix): Check ret?\n      } finally {\n        currentParser = null\n      }\n    } catch (err) {\n      // TODO (fix): What if socket is already destroyed? Error will be swallowed.\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 7 && key.toString().toLowerCase() === 'trailer') {\n      this.trailer += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    // TODO: Check for content-length mismatch from server?\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    // TODO: More statusCode validation?\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* istanbul ignore if: this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT' && statusCode >= 200 && statusCode < 300) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, trailer, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.trailer = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    const trailers = trailer ? trailer.split(/,\\s*/) : []\n    for (let i = 0; i < trailers.length; i++) {\n      const trailer = trailers[i]\n      let found = false\n      for (let n = 0; n < headers.length; n += 2) {\n        const key = headers[n]\n        if (key.length === trailer.length && key.toString().toLowerCase() === trailer.toLowerCase()) {\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        util.destroy(socket, new TrailerMismatchError())\n        return -1\n      }\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      // TODO: What if running > 0?\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting]) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client[kDestroyed]) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client[kDestroyed]) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosed] && !client[kSize]) {\n      client.destroy(util.nop)\n      continue\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  // TODO: Expect: 100-continue\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (host) {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    // TODO (fix): Avoid using err.message for logic.\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // TODO (fix): What if socket errors while waiting for body?\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // TODO: What if not ended and bytesWritten === contentLength?\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n    request.onBodySent(chunk)\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    // TODO (fix): Add comment clarifying what this does?\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n","'use strict'\n\n/* istanbul ignore file: only for Node 12 */\n\nconst { kConnected, kSize } = require('../core/symbols')\n\nclass CompatWeakRef {\n  constructor (value) {\n    this.value = value\n  }\n\n  deref () {\n    return this.value[kConnected] === 0 && this.value[kSize] === 0\n      ? undefined\n      : this.value\n  }\n}\n\nclass CompatFinalizer {\n  constructor (finalizer) {\n    this.finalizer = finalizer\n  }\n\n  register (dispatcher, key) {\n    dispatcher.on('disconnect', () => {\n      if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {\n        this.finalizer(key)\n      }\n    })\n  }\n}\n\nmodule.exports = function () {\n  return {\n    WeakRef: global.WeakRef || CompatWeakRef,\n    FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer\n  }\n}\n","'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls') \n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const timeoutId = timeout\n      ? setTimeout(onConnectTimeout, timeout, socket)\n      : null\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n","'use strict'\n\nclass AbortError extends Error {\n  constructor () {\n    super('The operation was aborted')\n    this.code = 'ABORT_ERR'\n    this.name = 'AbortError'\n  }\n}\n\nclass UndiciError extends Error {\n  constructor (message) {\n    super(message)\n    this.name = 'UndiciError'\n    this.code = 'UND_ERR'\n  }\n}\n\nclass ConnectTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ConnectTimeoutError)\n    this.name = 'ConnectTimeoutError'\n    this.message = message || 'Connect Timeout Error'\n    this.code = 'UND_ERR_CONNECT_TIMEOUT'\n  }\n}\n\nclass HeadersTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersTimeoutError)\n    this.name = 'HeadersTimeoutError'\n    this.message = message || 'Headers Timeout Error'\n    this.code = 'UND_ERR_HEADERS_TIMEOUT'\n  }\n}\n\nclass HeadersOverflowError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, HeadersOverflowError)\n    this.name = 'HeadersOverflowError'\n    this.message = message || 'Headers Overflow Error'\n    this.code = 'UND_ERR_HEADERS_OVERFLOW'\n  }\n}\n\nclass BodyTimeoutError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, BodyTimeoutError)\n    this.name = 'BodyTimeoutError'\n    this.message = message || 'Body Timeout Error'\n    this.code = 'UND_ERR_BODY_TIMEOUT'\n  }\n}\n\nclass InvalidArgumentError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidArgumentError)\n    this.name = 'InvalidArgumentError'\n    this.message = message || 'Invalid Argument Error'\n    this.code = 'UND_ERR_INVALID_ARG'\n  }\n}\n\nclass InvalidReturnValueError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InvalidReturnValueError)\n    this.name = 'InvalidReturnValueError'\n    this.message = message || 'Invalid Return Value Error'\n    this.code = 'UND_ERR_INVALID_RETURN_VALUE'\n  }\n}\n\nclass RequestAbortedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestAbortedError)\n    this.name = 'AbortError'\n    this.message = message || 'Request aborted'\n    this.code = 'UND_ERR_ABORTED'\n  }\n}\n\nclass InformationalError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, InformationalError)\n    this.name = 'InformationalError'\n    this.message = message || 'Request information'\n    this.code = 'UND_ERR_INFO'\n  }\n}\n\nclass RequestContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, RequestContentLengthMismatchError)\n    this.name = 'RequestContentLengthMismatchError'\n    this.message = message || 'Request body length does not match content-length header'\n    this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass ResponseContentLengthMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ResponseContentLengthMismatchError)\n    this.name = 'ResponseContentLengthMismatchError'\n    this.message = message || 'Response body length does not match content-length header'\n    this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH'\n  }\n}\n\nclass TrailerMismatchError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, TrailerMismatchError)\n    this.name = 'TrailerMismatchError'\n    this.message = message || 'Trailers does not match trailer header'\n    this.code = 'UND_ERR_TRAILER_MISMATCH'\n  }\n}\n\nclass ClientDestroyedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientDestroyedError)\n    this.name = 'ClientDestroyedError'\n    this.message = message || 'The client is destroyed'\n    this.code = 'UND_ERR_DESTROYED'\n  }\n}\n\nclass ClientClosedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, ClientClosedError)\n    this.name = 'ClientClosedError'\n    this.message = message || 'The client is closed'\n    this.code = 'UND_ERR_CLOSED'\n  }\n}\n\nclass SocketError extends UndiciError {\n  constructor (message, socket) {\n    super(message)\n    Error.captureStackTrace(this, SocketError)\n    this.name = 'SocketError'\n    this.message = message || 'Socket error'\n    this.code = 'UND_ERR_SOCKET'\n    this.socket = socket\n  }\n}\n\nclass NotSupportedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'NotSupportedError'\n    this.message = message || 'Not supported error'\n    this.code = 'UND_ERR_NOT_SUPPORTED'\n  }\n}\n\nclass BalancedPoolMissingUpstreamError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, NotSupportedError)\n    this.name = 'MissingUpstreamError'\n    this.message = message || 'No upstream has been added to the BalancedPool'\n    this.code = 'UND_ERR_BPL_MISSING_UPSTREAM'\n  }\n}\n\nclass HTTPParserError extends Error {\n  constructor (message, code, data) {\n    super(message)\n    Error.captureStackTrace(this, HTTPParserError)\n    this.name = 'HTTPParserError'\n    this.code = code ? `HPE_${code}` : undefined\n    this.data = data ? data.toString() : undefined\n  }\n}\n\nmodule.exports = {\n  AbortError,\n  HTTPParserError,\n  UndiciError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  BodyTimeoutError,\n  RequestContentLengthMismatchError,\n  ConnectTimeoutError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError,\n  ClientDestroyedError,\n  ClientClosedError,\n  InformationalError,\n  SocketError,\n  NotSupportedError,\n  ResponseContentLengthMismatchError,\n  BalancedPoolMissingUpstreamError\n}\n","'use strict'\n\nconst {\n  InvalidArgumentError,\n  NotSupportedError\n} = require('./errors')\nconst util = require('./util')\nconst assert = require('assert')\n\nconst kHandler = Symbol('handler')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.create = diagnosticsChannel.channel('undici:request:create')\n  channels.bodySent = diagnosticsChannel.channel('undici:request:bodySent')\n  channels.headers = diagnosticsChannel.channel('undici:request:headers')\n  channels.trailers = diagnosticsChannel.channel('undici:request:trailers')\n  channels.error = diagnosticsChannel.channel('undici:request:error')\n} catch {\n  channels.create = { hasSubscribers: false }\n  channels.bodySent = { hasSubscribers: false }\n  channels.headers = { hasSubscribers: false }\n  channels.trailers = { hasSubscribers: false }\n  channels.error = { hasSubscribers: false }\n}\n\nclass Request {\n  constructor (origin, {\n    path,\n    method,\n    body,\n    headers,\n    idempotent,\n    blocking,\n    upgrade,\n    headersTimeout,\n    bodyTimeout\n  }, handler) {\n    if (typeof path !== 'string') {\n      throw new InvalidArgumentError('path must be a string')\n    } else if (path[0] !== '/' && !(path.startsWith('http://') || path.startsWith('https://'))) {\n      throw new InvalidArgumentError('path must be an absolute URL or start with a slash')\n    }\n\n    if (typeof method !== 'string') {\n      throw new InvalidArgumentError('method must be a string')\n    }\n\n    if (upgrade && typeof upgrade !== 'string') {\n      throw new InvalidArgumentError('upgrade must be a string')\n    }\n\n    if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('invalid headersTimeout')\n    }\n\n    if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('invalid bodyTimeout')\n    }\n\n    this.headersTimeout = headersTimeout\n\n    this.bodyTimeout = bodyTimeout\n\n    this.method = method\n\n    if (body == null) {\n      this.body = null\n    } else if (util.isStream(body)) {\n      this.body = body\n    } else if (body instanceof DataView) {\n      // TODO: Why is DataView special?\n      this.body = body.buffer.byteLength ? Buffer.from(body.buffer) : null\n    } else if (body instanceof ArrayBuffer || ArrayBuffer.isView(body)) {\n      this.body = body.byteLength ? Buffer.from(body) : null\n    } else if (util.isBuffer(body)) {\n      this.body = body.byteLength ? body : null\n    } else if (typeof body === 'string') {\n      this.body = body.length ? Buffer.from(body) : null\n    } else if (util.isIterable(body) || util.isBlobLike(body)) {\n      this.body = body\n    } else {\n      throw new InvalidArgumentError('body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable')\n    }\n\n    this.completed = false\n\n    this.aborted = false\n\n    this.upgrade = upgrade || null\n\n    this.path = path\n\n    this.origin = origin\n\n    this.idempotent = idempotent == null\n      ? method === 'HEAD' || method === 'GET'\n      : idempotent\n\n    this.blocking = blocking == null ? false : blocking\n\n    this.host = null\n\n    this.contentLength = null\n\n    this.contentType = null\n\n    this.headers = ''\n\n    if (Array.isArray(headers)) {\n      if (headers.length % 2 !== 0) {\n        throw new InvalidArgumentError('headers array must be even')\n      }\n      for (let i = 0; i < headers.length; i += 2) {\n        processHeader(this, headers[i], headers[i + 1])\n      }\n    } else if (headers && typeof headers === 'object') {\n      const keys = Object.keys(headers)\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i]\n        processHeader(this, key, headers[key])\n      }\n    } else if (headers != null) {\n      throw new InvalidArgumentError('headers must be an object or an array')\n    }\n\n    if (util.isBlobLike(body) && this.contentType == null && body.type) {\n      this.contentType = body.type\n      this.headers += `content-type: ${body.type}\\r\\n`\n    }\n\n    util.validateHandler(handler, method, upgrade)\n\n    this.servername = util.getServerName(this.host)\n\n    this[kHandler] = handler\n\n    if (channels.create.hasSubscribers) {\n      channels.create.publish({ request: this })\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this[kHandler].onBodySent) {\n      try {\n        this[kHandler].onBodySent(chunk)\n      } catch (err) {\n        this.onError(err)\n      }\n    }\n  }\n\n  onRequestSent () {\n    if (channels.bodySent.hasSubscribers) {\n      channels.bodySent.publish({ request: this })\n    }\n  }\n\n  onConnect (abort) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onConnect(abort)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    if (channels.headers.hasSubscribers) {\n      channels.headers.publish({ request: this, response: { statusCode, headers, statusText } })\n    }\n\n    return this[kHandler].onHeaders(statusCode, headers, resume, statusText)\n  }\n\n  onData (chunk) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onData(chunk)\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    assert(!this.aborted)\n    assert(!this.completed)\n\n    return this[kHandler].onUpgrade(statusCode, headers, socket)\n  }\n\n  onComplete (trailers) {\n    assert(!this.aborted)\n\n    this.completed = true\n    if (channels.trailers.hasSubscribers) {\n      channels.trailers.publish({ request: this, trailers })\n    }\n    return this[kHandler].onComplete(trailers)\n  }\n\n  onError (error) {\n    if (channels.error.hasSubscribers) {\n      channels.error.publish({ request: this, error })\n    }\n\n    if (this.aborted) {\n      return\n    }\n    this.aborted = true\n    return this[kHandler].onError(error)\n  }\n\n  addHeader (key, value) {\n    processHeader(this, key, value)\n    return this\n  }\n}\n\nfunction processHeader (request, key, val) {\n  if (val && typeof val === 'object') {\n    throw new InvalidArgumentError(`invalid ${key} header`)\n  } else if (val === undefined) {\n    return\n  }\n\n  if (\n    request.host === null &&\n    key.length === 4 &&\n    key.toLowerCase() === 'host'\n  ) {\n    // Consumed by Client\n    request.host = val\n  } else if (\n    request.contentLength === null &&\n    key.length === 14 &&\n    key.toLowerCase() === 'content-length'\n  ) {\n    request.contentLength = parseInt(val, 10)\n    if (!Number.isFinite(request.contentLength)) {\n      throw new InvalidArgumentError('invalid content-length header')\n    }\n  } else if (\n    request.contentType === null &&\n    key.length === 12 &&\n    key.toLowerCase() === 'content-type'\n  ) {\n    request.contentType = val\n    request.headers += `${key}: ${val}\\r\\n`\n  } else if (\n    key.length === 17 &&\n    key.toLowerCase() === 'transfer-encoding'\n  ) {\n    throw new InvalidArgumentError('invalid transfer-encoding header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'connection'\n  ) {\n    throw new InvalidArgumentError('invalid connection header')\n  } else if (\n    key.length === 10 &&\n    key.toLowerCase() === 'keep-alive'\n  ) {\n    throw new InvalidArgumentError('invalid keep-alive header')\n  } else if (\n    key.length === 7 &&\n    key.toLowerCase() === 'upgrade'\n  ) {\n    throw new InvalidArgumentError('invalid upgrade header')\n  } else if (\n    key.length === 6 &&\n    key.toLowerCase() === 'expect'\n  ) {\n    throw new NotSupportedError('expect header not supported')\n  } else {\n    request.headers += `${key}: ${val}\\r\\n`\n  }\n}\n\nmodule.exports = Request\n","module.exports = {\n  kUrl: Symbol('url'),\n  kWriting: Symbol('writing'),\n  kResuming: Symbol('resuming'),\n  kQueue: Symbol('queue'),\n  kConnect: Symbol('connect'),\n  kConnecting: Symbol('connecting'),\n  kHeadersList: Symbol('headers list'),\n  kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),\n  kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),\n  kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),\n  kKeepAliveTimeoutValue: Symbol('keep alive timeout'),\n  kKeepAlive: Symbol('keep alive'),\n  kHeadersTimeout: Symbol('headers timeout'),\n  kBodyTimeout: Symbol('body timeout'),\n  kServerName: Symbol('server name'),\n  kHost: Symbol('host'),\n  kNoRef: Symbol('no ref'),\n  kBodyUsed: Symbol('used'),\n  kRunning: Symbol('running'),\n  kBlocking: Symbol('blocking'),\n  kPending: Symbol('pending'),\n  kSize: Symbol('size'),\n  kBusy: Symbol('busy'),\n  kConnected: Symbol('connected'),\n  kClosed: Symbol('closed'),\n  kNeedDrain: Symbol('need drain'),\n  kReset: Symbol('reset'),\n  kDestroyed: Symbol('destroyed'),\n  kMaxHeadersSize: Symbol('max headers size'),\n  kRunningIdx: Symbol('running index'),\n  kPendingIdx: Symbol('pending index'),\n  kError: Symbol('error'),\n  kClients: Symbol('clients'),\n  kClient: Symbol('client'),\n  kParser: Symbol('parser'),\n  kOnDestroyed: Symbol('destroy callbacks'),\n  kPipelining: Symbol('pipelinig'),\n  kSocket: Symbol('socket'),\n  kHostHeader: Symbol('host header'),\n  kConnector: Symbol('connector'),\n  kStrictContentLength: Symbol('strict content length'),\n  kMaxRedirections: Symbol('maxRedirections'),\n  kMaxRequests: Symbol('maxRequestsPerClient'),\n  kProxy: Symbol('proxy agent options'),\n  kCounter: Symbol('socket request counter')\n}\n","'use strict'\n\nconst assert = require('assert')\nconst { kDestroyed, kBodyUsed } = require('./symbols')\nconst { IncomingMessage } = require('http')\nconst stream = require('stream')\nconst net = require('net')\nconst { InvalidArgumentError } = require('./errors')\nconst { Blob } = require('buffer')\nconst nodeUtil = require('util')\n\nfunction nop () {}\n\nfunction isStream (obj) {\n  return obj && typeof obj.pipe === 'function'\n}\n\n// based on https://github.com/node-fetch/fetch-blob/blob/8ab587d34080de94140b54f07168451e7d0b655e/index.js#L229-L241 (MIT License)\nfunction isBlobLike (object) {\n  return (Blob && object instanceof Blob) || (\n    object &&\n    typeof object === 'object' &&\n    (typeof object.stream === 'function' ||\n      typeof object.arrayBuffer === 'function') &&\n    /^(Blob|File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\nfunction parseURL (url) {\n  if (typeof url === 'string') {\n    url = new URL(url)\n  }\n\n  if (!url || typeof url !== 'object') {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {\n    throw new InvalidArgumentError('invalid port')\n  }\n\n  if (url.path != null && typeof url.path !== 'string') {\n    throw new InvalidArgumentError('invalid path')\n  }\n\n  if (url.pathname != null && typeof url.pathname !== 'string') {\n    throw new InvalidArgumentError('invalid pathname')\n  }\n\n  if (url.hostname != null && typeof url.hostname !== 'string') {\n    throw new InvalidArgumentError('invalid hostname')\n  }\n\n  if (url.origin != null && typeof url.origin !== 'string') {\n    throw new InvalidArgumentError('invalid origin')\n  }\n\n  if (!/^https?:/.test(url.origin || url.protocol)) {\n    throw new InvalidArgumentError('invalid protocol')\n  }\n\n  if (!(url instanceof URL)) {\n    const port = url.port != null\n      ? url.port\n      : (url.protocol === 'https:' ? 443 : 80)\n    const origin = url.origin != null\n      ? url.origin\n      : `${url.protocol}//${url.hostname}:${port}`\n    const path = url.path != null\n      ? url.path\n      : `${url.pathname || ''}${url.search || ''}`\n\n    url = new URL(path, origin)\n  }\n\n  return url\n}\n\nfunction parseOrigin (url) {\n  url = parseURL(url)\n\n  if (url.pathname !== '/' || url.search || url.hash) {\n    throw new InvalidArgumentError('invalid url')\n  }\n\n  return url\n}\n\nfunction getHostname (host) {\n  if (host[0] === '[') {\n    const idx = host.indexOf(']')\n\n    assert(idx !== -1)\n    return host.substr(1, idx - 1)\n  }\n\n  const idx = host.indexOf(':')\n  if (idx === -1) return host\n\n  return host.substr(0, idx)\n}\n\n// IP addresses are not valid server names per RFC6066\n// > Currently, the only server names supported are DNS hostnames\nfunction getServerName (host) {\n  if (!host) {\n    return null\n  }\n\n  assert.strictEqual(typeof host, 'string')\n\n  const servername = getHostname(host)\n  if (net.isIP(servername)) {\n    return ''\n  }\n\n  return servername\n}\n\nfunction deepClone (obj) {\n  return JSON.parse(JSON.stringify(obj))\n}\n\nfunction isAsyncIterable (obj) {\n  return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function')\n}\n\nfunction isIterable (obj) {\n  return !!(obj != null && (typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function'))\n}\n\nfunction bodyLength (body) {\n  if (body == null) {\n    return 0\n  } else if (isStream(body)) {\n    const state = body._readableState\n    return state && state.ended === true && Number.isFinite(state.length)\n      ? state.length\n      : null\n  } else if (isBlobLike(body)) {\n    return body.size != null ? body.size : null\n  } else if (isBuffer(body)) {\n    return body.byteLength\n  }\n\n  return null\n}\n\nfunction isDestroyed (stream) {\n  return !stream || !!(stream.destroyed || stream[kDestroyed])\n}\n\nfunction isReadableAborted (stream) {\n  const state = stream && stream._readableState\n  return isDestroyed(stream) && state && !state.endEmitted\n}\n\nfunction destroy (stream, err) {\n  if (!isStream(stream) || isDestroyed(stream)) {\n    return\n  }\n\n  if (typeof stream.destroy === 'function') {\n    if (Object.getPrototypeOf(stream).constructor === IncomingMessage) {\n      // See: https://github.com/nodejs/node/pull/38505/files\n      stream.socket = null\n    }\n    stream.destroy(err)\n  } else if (err) {\n    process.nextTick((stream, err) => {\n      stream.emit('error', err)\n    }, stream, err)\n  }\n\n  if (stream.destroyed !== true) {\n    stream[kDestroyed] = true\n  }\n}\n\nconst KEEPALIVE_TIMEOUT_EXPR = /timeout=(\\d+)/\nfunction parseKeepAliveTimeout (val) {\n  const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR)\n  return m ? parseInt(m[1], 10) * 1000 : null\n}\n\nfunction parseHeaders (headers, obj = {}) {\n  for (let i = 0; i < headers.length; i += 2) {\n    const key = headers[i].toString().toLowerCase()\n    let val = obj[key]\n    if (!val) {\n      obj[key] = headers[i + 1].toString()\n    } else {\n      if (!Array.isArray(val)) {\n        val = [val]\n        obj[key] = val\n      }\n      val.push(headers[i + 1].toString())\n    }\n  }\n  return obj\n}\n\nfunction isBuffer (buffer) {\n  // See, https://github.com/mcollina/undici/pull/319\n  return buffer instanceof Uint8Array || Buffer.isBuffer(buffer)\n}\n\nfunction validateHandler (handler, method, upgrade) {\n  if (!handler || typeof handler !== 'object') {\n    throw new InvalidArgumentError('handler must be an object')\n  }\n\n  if (typeof handler.onConnect !== 'function') {\n    throw new InvalidArgumentError('invalid onConnect method')\n  }\n\n  if (typeof handler.onError !== 'function') {\n    throw new InvalidArgumentError('invalid onError method')\n  }\n\n  if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== undefined) {\n    throw new InvalidArgumentError('invalid onBodySent method')\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    if (typeof handler.onUpgrade !== 'function') {\n      throw new InvalidArgumentError('invalid onUpgrade method')\n    }\n  } else {\n    if (typeof handler.onHeaders !== 'function') {\n      throw new InvalidArgumentError('invalid onHeaders method')\n    }\n\n    if (typeof handler.onData !== 'function') {\n      throw new InvalidArgumentError('invalid onData method')\n    }\n\n    if (typeof handler.onComplete !== 'function') {\n      throw new InvalidArgumentError('invalid onComplete method')\n    }\n  }\n}\n\n// A body is disturbed if it has been read from and it cannot\n// be re-used without losing state or data.\nfunction isDisturbed (body) {\n  return !!(body && (\n    stream.isDisturbed\n      ? stream.isDisturbed(body) || body[kBodyUsed] // TODO (fix): Why is body[kBodyUsed] needed?\n      : body[kBodyUsed] ||\n        body.readableDidRead ||\n        (body._readableState && body._readableState.dataEmitted) ||\n        isReadableAborted(body)\n  ))\n}\n\nfunction isErrored (body) {\n  return !!(body && (\n    stream.isErrored\n      ? stream.isErrored(body)\n      : /state: 'errored'/.test(nodeUtil.inspect(body)\n  )))\n}\n\nfunction isReadable (body) {\n  return !!(body && (\n    stream.isReadable\n      ? stream.isReadable(body)\n      : /state: 'readable'/.test(nodeUtil.inspect(body)\n  )))\n}\n\nfunction getSocketInfo (socket) {\n  return {\n    localAddress: socket.localAddress,\n    localPort: socket.localPort,\n    remoteAddress: socket.remoteAddress,\n    remotePort: socket.remotePort,\n    remoteFamily: socket.remoteFamily,\n    timeout: socket.timeout,\n    bytesWritten: socket.bytesWritten,\n    bytesRead: socket.bytesRead\n  }\n}\n\nlet ReadableStream\nfunction ReadableStreamFrom (iterable) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  if (ReadableStream.from) {\n    // https://github.com/whatwg/streams/pull/1083\n    return ReadableStream.from(iterable)\n  }\n\n  let iterator\n  return new ReadableStream(\n    {\n      async start () {\n        iterator = iterable[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { done, value } = await iterator.next()\n        if (done) {\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          const buf = Buffer.isBuffer(value) ? value : Buffer.from(value)\n          controller.enqueue(new Uint8Array(buf))\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    },\n    0\n  )\n}\n\nconst kEnumerableProperty = Object.create(null)\nkEnumerableProperty.enumerable = true\n\nmodule.exports = {\n  kEnumerableProperty,\n  nop,\n  isDisturbed,\n  isErrored,\n  isReadable,\n  toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),\n  isReadableAborted,\n  isBlobLike,\n  parseOrigin,\n  parseURL,\n  getServerName,\n  isStream,\n  isIterable,\n  isAsyncIterable,\n  isDestroyed,\n  parseHeaders,\n  parseKeepAliveTimeout,\n  destroy,\n  bodyLength,\n  deepClone,\n  ReadableStreamFrom,\n  isBuffer,\n  validateHandler,\n  getSocketInfo\n}\n","'use strict'\n\nconst EventEmitter = require('events')\n\nclass Dispatcher extends EventEmitter {\n  dispatch () {\n    throw new Error('not implemented')\n  }\n\n  close () {\n    throw new Error('not implemented')\n  }\n\n  destroy () {\n    throw new Error('not implemented')\n  }\n}\n\nmodule.exports = Dispatcher\n","'use strict'\n\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString, isBlobLike } = require('./util')\nconst { FormData } = require('./formdata')\nconst { kState } = require('./symbols')\nconst { Blob } = require('buffer')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { NotSupportedError } = require('../core/errors')\nconst { isErrored } = require('../core/util')\nconst { isUint8Array } = require('util/types')\n\nlet ReadableStream\n\nasync function * blobGen (blob) {\n  if (blob.stream) {\n    yield * blob.stream()\n  } else {\n    // istanbul ignore next: node < 16.7\n    yield await blob.arrayBuffer()\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-bodyinit-extract\nfunction extractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // 1. Let stream be object if object is a ReadableStream object.\n  // Otherwise, let stream be a new ReadableStream, and set up stream.\n  let stream = null\n\n  // 2. Let action be null.\n  let action = null\n\n  // 3. Let source be null.\n  let source = null\n\n  // 4. Let length be null.\n  let length = null\n\n  // 5. Let Content-Type be null.\n  let contentType = null\n\n  // 6. Switch on object:\n  if (object == null) {\n    // Note: The IDL processor cannot handle this situation. See\n    // https://crbug.com/335871.\n  } else if (object instanceof URLSearchParams) {\n    // URLSearchParams\n\n    // spec says to run application/x-www-form-urlencoded on body.list\n    // this is implemented in Node.js as apart of an URLSearchParams instance toString method\n    // See: https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L490\n    // and https://github.com/nodejs/node/blob/e46c680bf2b211bbd52cf959ca17ee98c7f657f5/lib/internal/url.js#L1100\n\n    // Set source to the result of running the application/x-www-form-urlencoded serializer with object’s list.\n    source = object.toString()\n\n    // Set Content-Type to `application/x-www-form-urlencoded;charset=UTF-8`.\n    contentType = 'application/x-www-form-urlencoded;charset=UTF-8'\n  } else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {\n    // BufferSource\n\n    if (object instanceof DataView) {\n      // TODO: Blob doesn't seem to work with DataView?\n      object = object.buffer\n    }\n\n    // Set source to a copy of the bytes held by object.\n    source = new Uint8Array(object)\n  } else if (object instanceof FormData) {\n    const boundary = '----formdata-undici-' + Math.random()\n    const prefix = `--${boundary}\\r\\nContent-Disposition: form-data`\n\n    /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */\n    const escape = (str) =>\n      str.replace(/\\n/g, '%0A').replace(/\\r/g, '%0D').replace(/\"/g, '%22')\n    const normalizeLinefeeds = (value) => value.replace(/\\r?\\n|\\r/g, '\\r\\n')\n\n    // Set action to this step: run the multipart/form-data\n    // encoding algorithm, with object’s entry list and UTF-8.\n    action = async function * (object) {\n      const enc = new TextEncoder()\n\n      for (const [name, value] of object) {\n        if (typeof value === 'string') {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              `\\r\\n\\r\\n${normalizeLinefeeds(value)}\\r\\n`\n          )\n        } else {\n          yield enc.encode(\n            prefix +\n              `; name=\"${escape(normalizeLinefeeds(name))}\"` +\n              (value.name ? `; filename=\"${escape(value.name)}\"` : '') +\n              '\\r\\n' +\n              `Content-Type: ${\n                value.type || 'application/octet-stream'\n              }\\r\\n\\r\\n`\n          )\n\n          yield * blobGen(value)\n\n          yield enc.encode('\\r\\n')\n        }\n      }\n\n      yield enc.encode(`--${boundary}--`)\n    }\n\n    // Set source to object.\n    source = object\n\n    // Set length to unclear, see html/6424 for improving this.\n    // TODO\n\n    // Set Content-Type to `multipart/form-data; boundary=`,\n    // followed by the multipart/form-data boundary string generated\n    // by the multipart/form-data encoding algorithm.\n    contentType = 'multipart/form-data; boundary=' + boundary\n  } else if (isBlobLike(object)) {\n    // Blob\n\n    // Set action to this step: read object.\n    action = blobGen\n\n    // Set source to object.\n    source = object\n\n    // Set length to object’s size.\n    length = object.size\n\n    // If object’s type attribute is not the empty byte sequence, set\n    // Content-Type to its value.\n    if (object.type) {\n      contentType = object.type\n    }\n  } else if (typeof object[Symbol.asyncIterator] === 'function') {\n    // If keepalive is true, then throw a TypeError.\n    if (keepalive) {\n      throw new TypeError('keepalive')\n    }\n\n    // If object is disturbed or locked, then throw a TypeError.\n    if (util.isDisturbed(object) || object.locked) {\n      throw new TypeError(\n        'Response body object should not be disturbed or locked'\n      )\n    }\n\n    stream =\n      object instanceof ReadableStream ? object : ReadableStreamFrom(object)\n  } else {\n    // TODO: byte sequence?\n    // TODO: scalar value string?\n    // TODO: else?\n    source = toUSVString(object)\n    contentType = 'text/plain;charset=UTF-8'\n  }\n\n  // 7. If source is a byte sequence, then set action to a\n  // step that returns source and length to source’s length.\n  // TODO: What is a \"byte sequence?\"\n  if (typeof source === 'string' || util.isBuffer(source)) {\n    length = Buffer.byteLength(source)\n  }\n\n  // 8. If action is non-null, then run these steps in in parallel:\n  if (action != null) {\n    // Run action.\n    let iterator\n    stream = new ReadableStream({\n      async start () {\n        iterator = action(object)[Symbol.asyncIterator]()\n      },\n      async pull (controller) {\n        const { value, done } = await iterator.next()\n        if (done) {\n          // When running action is done, close stream.\n          queueMicrotask(() => {\n            controller.close()\n          })\n        } else {\n          // Whenever one or more bytes are available and stream is not errored,\n          // enqueue a Uint8Array wrapping an ArrayBuffer containing the available\n          // bytes into stream.\n          if (!isErrored(stream)) {\n            controller.enqueue(new Uint8Array(value))\n          }\n        }\n        return controller.desiredSize > 0\n      },\n      async cancel (reason) {\n        await iterator.return()\n      }\n    })\n  } else if (!stream) {\n    // TODO: Spec doesn't say anything about this?\n    stream = new ReadableStream({\n      async pull (controller) {\n        controller.enqueue(\n          typeof source === 'string' ? new TextEncoder().encode(source) : source\n        )\n        queueMicrotask(() => {\n          controller.close()\n        })\n      }\n    })\n  }\n\n  // 9. Let body be a body whose stream is stream, source is source,\n  // and length is length.\n  const body = { stream, source, length }\n\n  // 10. Return body and Content-Type.\n  return [body, contentType]\n}\n\n// https://fetch.spec.whatwg.org/#bodyinit-safely-extract\nfunction safelyExtractBody (object, keepalive = false) {\n  if (!ReadableStream) {\n    // istanbul ignore next\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  // To safely extract a body and a `Content-Type` value from\n  // a byte sequence or BodyInit object object, run these steps:\n\n  // 1. If object is a ReadableStream object, then:\n  if (object instanceof ReadableStream) {\n    // Assert: object is neither disturbed nor locked.\n    // istanbul ignore next\n    assert(!util.isDisturbed(object), 'disturbed')\n    // istanbul ignore next\n    assert(!object.locked, 'locked')\n  }\n\n  // 2. Return the results of extracting object.\n  return extractBody(object, keepalive)\n}\n\nfunction cloneBody (body) {\n  // To clone a body body, run these steps:\n\n  // https://fetch.spec.whatwg.org/#concept-body-clone\n\n  // 1. Let « out1, out2 » be the result of teeing body’s stream.\n  const [out1, out2] = body.stream.tee()\n\n  // 2. Set body’s stream to out1.\n  body.stream = out1\n\n  // 3. Return a body whose stream is out2 and other members are copied from body.\n  return {\n    stream: out2,\n    length: body.length,\n    source: body.source\n  }\n}\n\nconst methods = {\n  async blob () {\n    const chunks = []\n\n    if (this[kState].body) {\n      if (isUint8Array(this[kState].body)) {\n        chunks.push(this[kState].body)\n      } else {\n        const stream = this[kState].body.stream\n\n        if (util.isDisturbed(stream)) {\n          throw new TypeError('disturbed')\n        }\n\n        if (stream.locked) {\n          throw new TypeError('locked')\n        }\n\n        // Compat.\n        stream[kBodyUsed] = true\n\n        for await (const chunk of stream) {\n          chunks.push(chunk)\n        }\n      }\n    }\n\n    return new Blob(chunks, { type: this.headers.get('Content-Type') || '' })\n  },\n\n  async arrayBuffer () {\n    const blob = await this.blob()\n    return await blob.arrayBuffer()\n  },\n\n  async text () {\n    const blob = await this.blob()\n    return toUSVString(await blob.text())\n  },\n\n  async json () {\n    return JSON.parse(await this.text())\n  },\n\n  async formData () {\n    const contentType = this.headers.get('Content-Type')\n\n    // If mimeType’s essence is \"multipart/form-data\", then:\n    if (/multipart\\/form-data/.test(contentType)) {\n      throw new NotSupportedError('multipart/form-data not supported')\n    } else if (/application\\/x-www-form-urlencoded/.test(contentType)) {\n      // Otherwise, if mimeType’s essence is \"application/x-www-form-urlencoded\", then:\n\n      // 1. Let entries be the result of parsing bytes.\n      let entries\n      try {\n        entries = new URLSearchParams(await this.text())\n      } catch (err) {\n        // istanbul ignore next: Unclear when new URLSearchParams can fail on a string.\n        // 2. If entries is failure, then throw a TypeError.\n        throw Object.assign(new TypeError(), { cause: err })\n      }\n\n      // 3. Return a new FormData object whose entries are entries.\n      const formData = new FormData()\n      for (const [name, value] of entries) {\n        formData.append(name, value)\n      }\n      return formData\n    } else {\n      // Otherwise, throw a TypeError.\n      throw new TypeError()\n    }\n  }\n}\n\nconst properties = {\n  body: {\n    enumerable: true,\n    get () {\n      return this[kState].body ? this[kState].body.stream : null\n    }\n  },\n  bodyUsed: {\n    enumerable: true,\n    get () {\n      return this[kState].body && util.isDisturbed(this[kState].body.stream)\n    }\n  }\n}\n\nfunction mixinBody (prototype) {\n  Object.assign(prototype, methods)\n  Object.defineProperties(prototype, properties)\n}\n\nmodule.exports = {\n  extractBody,\n  safelyExtractBody,\n  cloneBody,\n  mixinBody\n}\n","'use strict'\n\nconst forbiddenHeaderNames = [\n  'accept-charset',\n  'accept-encoding',\n  'access-control-request-headers',\n  'access-control-request-method',\n  'connection',\n  'content-length',\n  'cookie',\n  'cookie2',\n  'date',\n  'dnt',\n  'expect',\n  'host',\n  'keep-alive',\n  'origin',\n  'referer',\n  'te',\n  'trailer',\n  'transfer-encoding',\n  'upgrade',\n  'via'\n]\n\nconst corsSafeListedMethods = ['GET', 'HEAD', 'POST']\n\nconst nullBodyStatus = [101, 204, 205, 304]\n\nconst redirectStatus = [301, 302, 303, 307, 308]\n\nconst referrerPolicy = [\n  '',\n  'no-referrer',\n  'no-referrer-when-downgrade',\n  'same-origin',\n  'origin',\n  'strict-origin',\n  'origin-when-cross-origin',\n  'strict-origin-when-cross-origin',\n  'unsafe-url'\n]\n\nconst requestRedirect = ['follow', 'manual', 'error']\n\nconst safeMethods = ['GET', 'HEAD', 'OPTIONS', 'TRACE']\n\nconst requestMode = ['navigate', 'same-origin', 'no-cors', 'cors']\n\nconst requestCredentials = ['omit', 'same-origin', 'include']\n\nconst requestCache = [\n  'default',\n  'no-store',\n  'reload',\n  'no-cache',\n  'force-cache',\n  'only-if-cached'\n]\n\n// https://fetch.spec.whatwg.org/#forbidden-response-header-name\nconst forbiddenResponseHeaderNames = ['set-cookie', 'set-cookie2']\n\nconst requestBodyHeader = [\n  'content-encoding',\n  'content-language',\n  'content-location',\n  'content-type'\n]\n\n// http://fetch.spec.whatwg.org/#forbidden-method\nconst forbiddenMethods = ['CONNECT', 'TRACE', 'TRACK']\n\nconst subresource = [\n  'audio',\n  'audioworklet',\n  'font',\n  'image',\n  'manifest',\n  'paintworklet',\n  'script',\n  'style',\n  'track',\n  'video',\n  'xslt',\n  ''\n]\n\nmodule.exports = {\n  subresource,\n  forbiddenResponseHeaderNames,\n  forbiddenMethods,\n  requestBodyHeader,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache,\n  forbiddenHeaderNames,\n  redirectStatus,\n  corsSafeListedMethods,\n  nullBodyStatus,\n  safeMethods\n}\n","const assert = require('assert')\nconst { atob } = require('buffer')\n\nconst encoder = new TextEncoder()\n\n// https://fetch.spec.whatwg.org/#data-url-processor\n/** @param {URL} dataURL */\nfunction dataURLProcessor (dataURL) {\n  // 1. Assert: dataURL’s scheme is \"data\".\n  assert(dataURL.protocol === 'data:')\n\n  // 2. Let input be the result of running the URL\n  // serializer on dataURL with exclude fragment\n  // set to true.\n  let input = URLSerializer(dataURL, true)\n\n  // 3. Remove the leading \"data:\" string from input.\n  input = input.slice(5)\n\n  // 4. Let position point at the start of input.\n  const position = { position: 0 }\n\n  // 5. Let mimeType be the result of collecting a\n  // sequence of code points that are not equal\n  // to U+002C (,), given position.\n  let mimeType = collectASequenceOfCodePoints(\n    (char) => char !== ',',\n    input,\n    position\n  )\n\n  // 6. Strip leading and trailing ASCII whitespace\n  // from mimeType.\n  // Note: This will only remove U+0020 SPACE code\n  // points, if any.\n  // Undici implementation note: we need to store the\n  // length because if the mimetype has spaces removed,\n  // the wrong amount will be sliced from the input in\n  // step #9\n  const mimeTypeLength = mimeType.length\n  mimeType = mimeType.replace(/^(\\u0020)+|(\\u0020)+$/g, '')\n\n  // 7. If position is past the end of input, then\n  // return failure\n  if (position.position >= input.length) {\n    return 'failure'\n  }\n\n  // 8. Advance position by 1.\n  position.position++\n\n  // 9. Let encodedBody be the remainder of input.\n  const encodedBody = input.slice(mimeTypeLength + 1)\n\n  // 10. Let body be the percent-decoding of encodedBody.\n  /** @type {Uint8Array|string} */\n  let body = stringPercentDecode(encodedBody)\n\n  // 11. If mimeType ends with U+003B (;), followed by\n  // zero or more U+0020 SPACE, followed by an ASCII\n  // case-insensitive match for \"base64\", then:\n  if (/;(\\u0020){0,}base64$/i.test(mimeType)) {\n    // 1. Let stringBody be the isomorphic decode of body.\n    const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body))\n    // 2. Set body to the forgiving-base64 decode of\n    // stringBody.\n    body = forgivingBase64(stringBody)\n\n    // 3. If body is failure, then return failure.\n    if (body === 'failure') {\n      return 'failure'\n    }\n\n    // 4. Remove the last 6 code points from mimeType.\n    mimeType = mimeType.slice(0, -6)\n\n    // 5. Remove trailing U+0020 SPACE code points from mimeType,\n    // if any.\n    mimeType = mimeType.replace(/(\\u0020)+$/, '')\n\n    // 6. Remove the last U+003B (;) code point from mimeType.\n    mimeType = mimeType.slice(0, -1)\n  }\n\n  // 12. If mimeType starts with U+003B (;), then prepend\n  // \"text/plain\" to mimeType.\n  if (mimeType.startsWith(';')) {\n    mimeType = 'text/plain' + mimeType\n  }\n\n  // 13. Let mimeTypeRecord be the result of parsing\n  // mimeType.\n  let mimeTypeRecord = parseMIMEType(mimeType)\n\n  // 14. If mimeTypeRecord is failure, then set\n  // mimeTypeRecord to text/plain;charset=US-ASCII.\n  if (mimeTypeRecord === 'failure') {\n    mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII')\n  }\n\n  // 15. Return a new data: URL struct whose MIME\n  // type is mimeTypeRecord and body is body.\n  // https://fetch.spec.whatwg.org/#data-url-struct\n  return { mimeType: mimeTypeRecord, body }\n}\n\n// https://url.spec.whatwg.org/#concept-url-serializer\n/**\n * @param {URL} url\n * @param {boolean} excludeFragment\n */\nfunction URLSerializer (url, excludeFragment = false) {\n  // 1. Let output be url’s scheme and U+003A (:) concatenated.\n  let output = url.protocol\n\n  // 2. If url’s host is non-null:\n  if (url.host.length > 0) {\n    // 1. Append \"//\" to output.\n    output += '//'\n\n    // 2. If url includes credentials, then:\n    if (url.username.length > 0 || url.password.length > 0) {\n      // 1. Append url’s username to output.\n      output += url.username\n\n      // 2. If url’s password is not the empty string, then append U+003A (:),\n      // followed by url’s password, to output.\n      if (url.password.length > 0) {\n        output += ':' + url.password\n      }\n\n      // 3. Append U+0040 (@) to output.\n      output += '@'\n    }\n\n    // 3. Append url’s host, serialized, to output.\n    output += decodeURIComponent(url.host)\n\n    // 4. If url’s port is non-null, append U+003A (:) followed by url’s port,\n    // serialized, to output.\n    if (url.port.length > 0) {\n      output += ':' + url.port\n    }\n  }\n\n  // 3. If url’s host is null, url does not have an opaque path,\n  // url’s path’s size is greater than 1, and url’s path[0]\n  // is the empty string, then append U+002F (/) followed by\n  // U+002E (.) to output.\n  // Note: This prevents web+demo:/.//not-a-host/ or web+demo:/path/..//not-a-host/,\n  // when parsed and then serialized, from ending up as web+demo://not-a-host/\n  // (they end up as web+demo:/.//not-a-host/).\n  // Undici implementation note: url's path[0] can never be an\n  // empty string, so we have to slightly alter what the spec says.\n  if (\n    url.host.length === 0 &&\n    url.pathname.length > 1 &&\n    url.href.slice(url.protocol.length + 1)[0] === '.'\n  ) {\n    output += '/.'\n  }\n\n  // 4. Append the result of URL path serializing url to output.\n  output += url.pathname\n\n  // 5. If url’s query is non-null, append U+003F (?),\n  // followed by url’s query, to output.\n  if (url.search.length > 0) {\n    output += url.search\n  }\n\n  // 6. If exclude fragment is false and url’s fragment is non-null,\n  // then append U+0023 (#), followed by url’s fragment, to output.\n  if (excludeFragment === false && url.hash.length > 0) {\n    output += url.hash\n  }\n\n  // 7. Return output.\n  return output\n}\n\n// https://infra.spec.whatwg.org/#collect-a-sequence-of-code-points\n/**\n * @param {(char: string) => boolean} condition\n * @param {string} input\n * @param {{ position: number }} position\n */\nfunction collectASequenceOfCodePoints (condition, input, position) {\n  // 1. Let result be the empty string.\n  let result = ''\n\n  // 2. While position doesn’t point past the end of input and the\n  // code point at position within input meets the condition condition:\n  while (position.position < input.length && condition(input[position.position])) {\n    // 1. Append that code point to the end of result.\n    result += input[position.position]\n\n    // 2. Advance position by 1.\n    position.position++\n  }\n\n  // 3. Return result.\n  return result\n}\n\n// https://url.spec.whatwg.org/#string-percent-decode\n/** @param {string} input */\nfunction stringPercentDecode (input) {\n  // 1. Let bytes be the UTF-8 encoding of input.\n  const bytes = encoder.encode(input)\n\n  // 2. Return the percent-decoding of bytes.\n  return percentDecode(bytes)\n}\n\n// https://url.spec.whatwg.org/#percent-decode\n/** @param {Uint8Array} input */\nfunction percentDecode (input) {\n  // 1. Let output be an empty byte sequence.\n  /** @type {number[]} */\n  const output = []\n\n  // 2. For each byte byte in input:\n  for (let i = 0; i < input.length; i++) {\n    const byte = input[i]\n\n    // 1. If byte is not 0x25 (%), then append byte to output.\n    if (byte !== 0x25) {\n      output.push(byte)\n    }\n\n    // 2. Otherwise, if byte is 0x25 (%) and the next two bytes\n    // after byte in input are not in the ranges\n    // 0x30 (0) to 0x39 (9), 0x41 (A) to 0x46 (F),\n    // and 0x61 (a) to 0x66 (f), all inclusive, append byte\n    // to output.\n    else if (\n      byte === 0x25 &&\n      !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))\n    ) {\n      output.push(0x25)\n    }\n\n    // 3. Otherwise:\n    else {\n      // 1. Let bytePoint be the two bytes after byte in input,\n      // decoded, and then interpreted as hexadecimal number.\n      const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2])\n      const bytePoint = Number.parseInt(nextTwoBytes, 16)\n\n      // 2. Append a byte whose value is bytePoint to output.\n      output.push(bytePoint)\n\n      // 3. Skip the next two bytes in input.\n      i += 2\n    }\n  }\n\n  // 3. Return output.\n  return Uint8Array.of(...output)\n}\n\n// https://mimesniff.spec.whatwg.org/#parse-a-mime-type\n/** @param {string} input */\nfunction parseMIMEType (input) {\n  // 1. Remove any leading and trailing HTTP whitespace\n  // from input.\n  input = input.trim()\n\n  // 2. Let position be a position variable for input,\n  // initially pointing at the start of input.\n  const position = { position: 0 }\n\n  // 3. Let type be the result of collecting a sequence\n  // of code points that are not U+002F (/) from\n  // input, given position.\n  const type = collectASequenceOfCodePoints(\n    (char) => char !== '/',\n    input,\n    position\n  )\n\n  // 4. If type is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  // https://mimesniff.spec.whatwg.org/#http-token-code-point\n  if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {\n    return 'failure'\n  }\n\n  // 5. If position is past the end of input, then return\n  // failure\n  if (position.position > input.length) {\n    return 'failure'\n  }\n\n  // 6. Advance position by 1. (This skips past U+002F (/).)\n  position.position++\n\n  // 7. Let subtype be the result of collecting a sequence of\n  // code points that are not U+003B (;) from input, given\n  // position.\n  let subtype = collectASequenceOfCodePoints(\n    (char) => char !== ';',\n    input,\n    position\n  )\n\n  // 8. Remove any trailing HTTP whitespace from subtype.\n  subtype = subtype.trim()\n\n  // 9. If subtype is the empty string or does not solely\n  // contain HTTP token code points, then return failure.\n  if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {\n    return 'failure'\n  }\n\n  // 10. Let mimeType be a new MIME type record whose type\n  // is type, in ASCII lowercase, and subtype is subtype,\n  // in ASCII lowercase.\n  // https://mimesniff.spec.whatwg.org/#mime-type\n  const mimeType = {\n    type: type.toLowerCase(),\n    subtype: subtype.toLowerCase(),\n    /** @type {Map<string, string>} */\n    parameters: new Map()\n  }\n\n  // 11. While position is not past the end of input:\n  while (position.position < input.length) {\n    // 1. Advance position by 1. (This skips past U+003B (;).)\n    position.position++\n\n    // 2. Collect a sequence of code points that are HTTP\n    // whitespace from input given position.\n    collectASequenceOfCodePoints(\n      // https://fetch.spec.whatwg.org/#http-whitespace\n      (char) => /(\\u000A|\\u000D|\\u0009|\\u0020)/.test(char),\n      input,\n      position\n    )\n\n    // 3. Let parameterName be the result of collecting a\n    // sequence of code points that are not U+003B (;)\n    // or U+003D (=) from input, given position.\n    let parameterName = collectASequenceOfCodePoints(\n      (char) => char !== ';' && char !== '=',\n      input,\n      position\n    )\n\n    // 4. Set parameterName to parameterName, in ASCII\n    // lowercase.\n    parameterName = parameterName.toLowerCase()\n\n    // 5. If position is not past the end of input, then:\n    if (position.position < input.length) {\n      // 1. If the code point at position within input is\n      // U+003B (;), then continue.\n      if (input[position.position] === ';') {\n        continue\n      }\n\n      // 2. Advance position by 1. (This skips past U+003D (=).)\n      position.position++\n    }\n\n    // 6. If position is past the end of input, then break.\n    if (position.position > input.length) {\n      break\n    }\n\n    // 7. Let parameterValue be null.\n    let parameterValue = null\n\n    // 8. If the code point at position within input is\n    // U+0022 (\"), then:\n    if (input[position.position] === '\"') {\n      // 1. Set parameterValue to the result of collecting\n      // an HTTP quoted string from input, given position\n      // and the extract-value flag.\n      // Undici implementation note: extract-value is never\n      // defined or mentioned anywhere.\n      parameterValue = collectAnHTTPQuotedString(input, position/*, extractValue */)\n\n      // 2. Collect a sequence of code points that are not\n      // U+003B (;) from input, given position.\n      collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n    }\n\n    // 9. Otherwise:\n    else {\n      // 1. Set parameterValue to the result of collecting\n      // a sequence of code points that are not U+003B (;)\n      // from input, given position.\n      parameterValue = collectASequenceOfCodePoints(\n        (char) => char !== ';',\n        input,\n        position\n      )\n\n      // 2. Remove any trailing HTTP whitespace from parameterValue.\n      parameterValue = parameterValue.trim()\n\n      // 3. If parameterValue is the empty string, then continue.\n      if (parameterValue.length === 0) {\n        continue\n      }\n    }\n\n    // 10. If all of the following are true\n    // - parameterName is not the empty string\n    // - parameterName solely contains HTTP token code points\n    // - parameterValue solely contains HTTP quoted-string token code points\n    // - mimeType’s parameters[parameterName] does not exist\n    // then set mimeType’s parameters[parameterName] to parameterValue.\n    if (\n      parameterName.length !== 0 &&\n      /^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&\n      // https://mimesniff.spec.whatwg.org/#http-quoted-string-token-code-point\n      !/^(\\u0009|\\x{0020}-\\x{007E}|\\x{0080}-\\x{00FF})+$/.test(parameterValue) &&\n      !mimeType.parameters.has(parameterName)\n    ) {\n      mimeType.parameters.set(parameterName, parameterValue)\n    }\n  }\n\n  // 12. Return mimeType.\n  return mimeType\n}\n\n// https://infra.spec.whatwg.org/#forgiving-base64-decode\n/** @param {string} data */\nfunction forgivingBase64 (data) {\n  // 1. Remove all ASCII whitespace from data.\n  data = data.replace(/[\\u0009\\u000A\\u000C\\u000D\\u0020]/g, '')\n\n  // 2. If data’s code point length divides by 4 leaving\n  // no remainder, then:\n  if (data.length % 4 === 0) {\n    // 1. If data ends with one or two U+003D (=) code points,\n    // then remove them from data.\n    data = data.replace(/=?=$/, '')\n  }\n\n  // 3. If data’s code point length divides by 4 leaving\n  // a remainder of 1, then return failure.\n  if (data.length % 4 === 1) {\n    return 'failure'\n  }\n\n  // 4. If data contains a code point that is not one of\n  //  U+002B (+)\n  //  U+002F (/)\n  //  ASCII alphanumeric\n  // then return failure.\n  if (/[^+/0-9A-Za-z]/.test(data)) {\n    return 'failure'\n  }\n\n  const binary = atob(data)\n  const bytes = new Uint8Array(binary.length)\n\n  for (let byte = 0; byte < binary.length; byte++) {\n    bytes[byte] = binary.charCodeAt(byte)\n  }\n\n  return bytes\n}\n\n// https://fetch.spec.whatwg.org/#collect-an-http-quoted-string\n// tests: https://fetch.spec.whatwg.org/#example-http-quoted-string\n/**\n * @param {string} input\n * @param {{ position: number }} position\n * @param {boolean?} extractValue\n */\nfunction collectAnHTTPQuotedString (input, position, extractValue) {\n  // 1. Let positionStart be position.\n  const positionStart = position.position\n\n  // 2. Let value be the empty string.\n  let value = ''\n\n  // 3. Assert: the code point at position within input\n  // is U+0022 (\").\n  assert(input[position.position] === '\"')\n\n  // 4. Advance position by 1.\n  position.position++\n\n  // 5. While true:\n  while (true) {\n    // 1. Append the result of collecting a sequence of code points\n    // that are not U+0022 (\") or U+005C (\\) from input, given\n    // position, to value.\n    value += collectASequenceOfCodePoints(\n      (char) => char !== '\"' && char !== '\\\\',\n      input,\n      position\n    )\n\n    // 2. If position is past the end of input, then break.\n    if (position.position >= input.length) {\n      break\n    }\n\n    // 3. Let quoteOrBackslash be the code point at position within\n    // input.\n    const quoteOrBackslash = input[position.position]\n\n    // 4. Advance position by 1.\n    position.position++\n\n    // 5. If quoteOrBackslash is U+005C (\\), then:\n    if (quoteOrBackslash === '\\\\') {\n      // 1. If position is past the end of input, then append\n      // U+005C (\\) to value and break.\n      if (position.position >= input.length) {\n        value += '\\\\'\n        break\n      }\n\n      // 2. Append the code point at position within input to value.\n      value += input[position.position]\n\n      // 3. Advance position by 1.\n      position.position++\n    }\n\n    // 6. Otherwise:\n    else {\n      // 1. Assert: quoteOrBackslash is U+0022 (\").\n      assert(quoteOrBackslash === '\"')\n\n      // 2. Break.\n      break\n    }\n  }\n\n  // 6. If the extract-value flag is set, then return value.\n  if (extractValue) {\n    return value\n  }\n\n  // 7. Return the code points from positionStart to position,\n  // inclusive, within input.\n  return input.slice(positionStart, position.position)\n}\n\nmodule.exports = {\n  dataURLProcessor,\n  URLSerializer,\n  collectASequenceOfCodePoints,\n  stringPercentDecode,\n  parseMIMEType,\n  collectAnHTTPQuotedString\n}\n","'use strict'\n\nconst { Blob } = require('buffer')\nconst { kState } = require('./symbols')\n\nclass File extends Blob {\n  constructor (fileBits, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    super(fileBits, { type: t })\n    this[kState] = {\n      name: n,\n      lastModified: d\n    }\n  }\n\n  get name () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof File)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n}\n\nclass FileLike {\n  constructor (blobLike, fileName, options = {}) {\n    // TODO: argument idl type check\n\n    // The File constructor is invoked with two or three parameters, depending\n    // on whether the optional dictionary parameter is used. When the File()\n    // constructor is invoked, user agents must run the following steps:\n\n    // 1. Let bytes be the result of processing blob parts given fileBits and\n    // options.\n\n    // 2. Let n be the fileName argument to the constructor.\n    const n = fileName\n\n    // 3. Process FilePropertyBag dictionary argument by running the following\n    // substeps:\n\n    //    1. If the type member is provided and is not the empty string, let t\n    //    be set to the type dictionary member. If t contains any characters\n    //    outside the range U+0020 to U+007E, then set t to the empty string\n    //    and return from these substeps.\n    //    TODO\n    const t = options.type\n\n    //    2. Convert every character in t to ASCII lowercase.\n    //    TODO\n\n    //    3. If the lastModified member is provided, let d be set to the\n    //    lastModified dictionary member. If it is not provided, set d to the\n    //    current date and time represented as the number of milliseconds since\n    //    the Unix Epoch (which is the equivalent of Date.now() [ECMA-262]).\n    const d = options.lastModified ?? Date.now()\n\n    // 4. Return a new File object F such that:\n    // F refers to the bytes byte sequence.\n    // F.size is set to the number of total bytes in bytes.\n    // F.name is set to n.\n    // F.type is set to t.\n    // F.lastModified is set to d.\n\n    this[kState] = {\n      blobLike,\n      name: n,\n      type: t,\n      lastModified: d\n    }\n  }\n\n  stream (...args) {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.stream(...args)\n  }\n\n  arrayBuffer (...args) {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.arrayBuffer(...args)\n  }\n\n  slice (...args) {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.slice(...args)\n  }\n\n  text (...args) {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.text(...args)\n  }\n\n  get size () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.size\n  }\n\n  get type () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].blobLike.type\n  }\n\n  get name () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].name\n  }\n\n  get lastModified () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kState].lastModified\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof FileLike)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return 'File'\n  }\n}\n\nmodule.exports = { File: globalThis.File ?? File, FileLike }\n","'use strict'\n\nconst { isBlobLike, isFileLike, toUSVString } = require('./util')\nconst { kState } = require('./symbols')\nconst { File, FileLike } = require('./file')\nconst { Blob } = require('buffer')\n\nclass FormData {\n  constructor (...args) {\n    if (args.length > 0 && !(args[0]?.constructor?.name === 'HTMLFormElement')) {\n      throw new TypeError(\n        \"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'\"\n      )\n    }\n\n    this[kState] = []\n  }\n\n  append (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with\n    // name, value, and filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. Append entry to this’s entry list.\n    this[kState].push(entry)\n  }\n\n  delete (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The delete(name) method steps are to remove all entries whose name\n    // is name from this’s entry list.\n    const next = []\n    for (const entry of this[kState]) {\n      if (entry.name !== name) {\n        next.push(entry)\n      }\n    }\n\n    this[kState] = next\n  }\n\n  get (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return null.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx === -1) {\n      return null\n    }\n\n    // 2. Return the value of the first entry whose name is name from\n    // this’s entry list.\n    return this[kState][idx].value\n  }\n\n  getAll (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // 1. If there is no entry whose name is name in this’s entry list,\n    // then return the empty list.\n    // 2. Return the values of all entries whose name is name, in order,\n    // from this’s entry list.\n    return this[kState]\n      .filter((entry) => entry.name === name)\n      .map((entry) => entry.value)\n  }\n\n  has (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'FormData': 1 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const name = toUSVString(args[0])\n\n    // The has(name) method steps are to return true if there is an entry\n    // whose name is name in this’s entry list; otherwise false.\n    return this[kState].findIndex((entry) => entry.name === name) !== -1\n  }\n\n  set (...args) {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'FormData': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    if (args.length === 3 && !isBlobLike(args[1])) {\n      throw new TypeError(\n        \"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'\"\n      )\n    }\n    const name = toUSVString(args[0])\n    const filename = args.length === 3 ? toUSVString(args[2]) : undefined\n\n    // The set(name, value) and set(name, blobValue, filename) method steps\n    // are:\n\n    // 1. Let value be value if given; otherwise blobValue.\n    const value = isBlobLike(args[1]) ? args[1] : toUSVString(args[1])\n\n    // 2. Let entry be the result of creating an entry with name, value, and\n    // filename if given.\n    const entry = makeEntry(name, value, filename)\n\n    // 3. If there are entries in this’s entry list whose name is name, then\n    // replace the first such entry with entry and remove the others.\n    const idx = this[kState].findIndex((entry) => entry.name === name)\n    if (idx !== -1) {\n      this[kState] = [\n        ...this[kState].slice(0, idx),\n        entry,\n        ...this[kState].slice(idx + 1).filter((entry) => entry.name !== name)\n      ]\n    } else {\n      // 4. Otherwise, append entry to this’s entry list.\n      this[kState].push(entry)\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  * entries () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const pair of this) {\n      yield pair\n    }\n  }\n\n  * keys () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [key] of this) {\n      yield key\n    }\n  }\n\n  * values () {\n    if (!(this instanceof FormData)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    for (const [, value] of this) {\n      yield value\n    }\n  }\n\n  * [Symbol.iterator] () {\n    // The value pairs to iterate over are this’s entry list’s entries with\n    // the key being the name and the value being the value.\n    for (const { name, value } of this[kState]) {\n      yield [name, value]\n    }\n  }\n}\n\nfunction makeEntry (name, value, filename) {\n  // To create an entry for name, value, and optionally a filename, run these\n  // steps:\n\n  // 1. Let entry be a new entry.\n  const entry = {\n    name: null,\n    value: null\n  }\n\n  // 2. Set entry’s name to name.\n  entry.name = name\n\n  // 3. If value is a Blob object and not a File object, then set value to a new File\n  // object, representing the same bytes, whose name attribute value is \"blob\".\n  if (isBlobLike(value) && !isFileLike(value)) {\n    value = value instanceof Blob\n      ? new File([value], 'blob')\n      : new FileLike(value, 'blob')\n  }\n\n  // 4. If value is (now) a File object and filename is given, then set value to a\n  // new File object, representing the same bytes, whose name attribute value is\n  // filename.\n  // TODO: This is a bit weird... What if passed value is a File?\n  // Do we just override the name attribute? Since it says \"if value is (now)\"\n  // does that mean that this lives inside the previous condition? In which case\n  // creating one more File instance doesn't make much sense....\n  if (isFileLike(value) && filename != null) {\n    value = value instanceof File\n      ? new File([value], filename)\n      : new FileLike(value, filename)\n  }\n\n  // 5. Set entry’s value to value.\n  entry.value = value\n\n  // 6. Return entry.\n  return entry\n}\n\nmodule.exports = { FormData: globalThis.FormData ?? FormData }\n","// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { validateHeaderName, validateHeaderValue } = require('http')\nconst { kHeadersList } = require('../core/symbols')\nconst { kGuard } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = require('./constants')\n\nfunction binarySearch (arr, val) {\n  let low = 0\n  let high = Math.floor(arr.length / 2)\n\n  while (high > low) {\n    const mid = (high + low) >>> 1\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n\n  return low * 2\n}\n\nfunction normalizeAndValidateHeaderName (name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`)\n  }\n  const normalizedHeaderName = name.toLocaleLowerCase()\n  validateHeaderName(normalizedHeaderName)\n  return normalizedHeaderName\n}\n\nfunction normalizeAndValidateHeaderValue (name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name)\n  }\n  const normalizedHeaderValue = `${value}`.replace(\n    /^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g,\n    ''\n  )\n  validateHeaderValue(name, normalizedHeaderValue)\n  return normalizedHeaderValue\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header]\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError()\n      }\n\n      // 2. Append header’s first item/header’s second item to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1])\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError()\n  }\n}\n\n// TODO: Composition over inheritence? Or helper methods?\nclass HeadersList extends Array {\n  append (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n\n  delete (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2)\n    }\n  }\n\n  get (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      return this[index + 1]\n    }\n\n    return null\n  }\n\n  has (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    return this[index] === normalizedName\n  }\n\n  set (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n}\n\nclass Headers {\n  constructor (...args) {\n    if (\n      args[0] !== undefined &&\n      !(typeof args[0] === 'object' && args[0] != null) &&\n      !Array.isArray(args[0])\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\"\n      )\n    }\n    const init = args.length >= 1 ? args[0] ?? {} : {}\n\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    fill(this, init)\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  toString () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return Object.prototype.toString.call(this)\n  }\n\n  append (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].append(String(args[0]), String(args[1]))\n  }\n\n  delete (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].delete(String(args[0]))\n  }\n\n  get (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].get(String(args[0]))\n  }\n\n  has (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].has(String(args[0]))\n  }\n\n  set (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].set(String(args[0]), String(args[1]))\n  }\n\n  * keys () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * values () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * entries () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]]\n    }\n  }\n\n  forEach (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (typeof args[0] !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n    const callback = args[0]\n    const thisArg = args[1]\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(\n        thisArg,\n        this[kHeadersList][index + 1],\n        this[kHeadersList][index],\n        this\n      )\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n})\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n}\n","// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst {\n  Response,\n  makeNetworkError,\n  filterResponse,\n  makeResponse\n} = require('./response')\nconst { Headers } = require('./headers')\nconst { Request, makeRequest } = require('./request')\nconst zlib = require('zlib')\nconst {\n  ServiceWorkerGlobalScope,\n  Window,\n  matchRequestIntegrity,\n  makePolicyContainer,\n  clonePolicyContainer,\n  requestBadPort,\n  TAOCheck,\n  appendRequestOriginHeader,\n  responseLocationURL,\n  requestCurrentURL,\n  setRequestReferrerPolicyOnRedirect,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  createOpaqueTimingInfo,\n  appendFetchMetadata,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  determineRequestsReferrer,\n  coarsenedSharedCurrentTime,\n  createDeferredPromise,\n  isBlobLike,\n  CORBCheck,\n  sameOrigin\n} = require('./util')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { AbortError } = require('../core/errors')\nconst assert = require('assert')\nconst { safelyExtractBody, extractBody } = require('./body')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  safeMethods,\n  requestBodyHeader,\n  subresource\n} = require('./constants')\nconst { kHeadersList } = require('../core/symbols')\nconst EE = require('events')\nconst { PassThrough, pipeline } = require('stream')\nconst { isErrored, isReadable } = require('../core/util')\nconst { kIsMockActive } = require('../mock/mock-symbols')\nconst { dataURLProcessor } = require('./dataURL')\n\n/** @type {import('buffer').resolveObjectURL} */\nlet resolveObjectURL\nlet ReadableStream\n\nclass Fetch extends EE {\n  constructor (dispatcher) {\n    super()\n\n    this.dispatcher = dispatcher\n    this.terminated = null\n    this.connection = null\n    this.dump = false\n  }\n\n  terminate ({ reason, aborted } = {}) {\n    if (this.terminated) {\n      return\n    }\n    this.terminated = { aborted, reason }\n\n    this.connection?.destroy(reason)\n\n    this.emit('terminated', reason)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-method\nasync function fetch (...args) {\n  if (args.length < 1) {\n    throw new TypeError(\n      `Failed to execute 'fetch' on 'Window': 1 argument required, but only ${args.length} present.`\n    )\n  }\n  if (\n    args.length >= 1 &&\n    typeof args[1] !== 'object' &&\n    args[1] !== undefined\n  ) {\n    throw new TypeError(\n      \"Failed to execute 'fetch' on 'Window': cannot convert to dictionary.\"\n    )\n  }\n\n  const resource = args[0]\n  const init = args.length >= 1 ? args[1] ?? {} : {}\n\n  const context = new Fetch(this)\n\n  // 1. Let p be a new promise.\n  const p = createDeferredPromise()\n\n  // 2. Let requestObject be the result of invoking the initial value of\n  // Request as constructor with input and init as arguments. If this throws\n  // an exception, reject p with it and return p.\n  const requestObject = new Request(resource, init)\n\n  // 3. Let request be requestObject’s request.\n  const request = requestObject[kState]\n\n  // 4. If requestObject’s signal’s aborted flag is set, then:\n  if (requestObject.signal.aborted) {\n    // 1. Abort fetch with p, request, and null.\n    abortFetch.call(context, p, request, null)\n\n    // 2. Return p.\n    return p.promise\n  }\n\n  // 5. Let globalObject be request’s client’s global object.\n  // TODO: What if request.client is null?\n  const globalObject = request.client?.globalObject\n\n  // 6. If globalObject is a ServiceWorkerGlobalScope object, then set\n  // request’s service-workers mode to \"none\".\n  if (globalObject instanceof ServiceWorkerGlobalScope) {\n    request.serviceWorkers = 'none'\n  }\n\n  // 7. Let responseObject be null.\n  let responseObject = null\n\n  // 8. Let relevantRealm be this’s relevant Realm.\n  const relevantRealm = null\n\n  // 9. Let locallyAborted be false.\n  let locallyAborted = false\n\n  // 10. Add the following abort steps to requestObject’s signal:\n  requestObject.signal.addEventListener(\n    'abort',\n    () => {\n      // 1. Set locallyAborted to true.\n      locallyAborted = true\n\n      // 2. Abort fetch with p, request, and responseObject.\n      abortFetch.call(context, p, request, responseObject)\n\n      // 3. Terminate the ongoing fetch with the aborted flag set.\n      context.terminate({ aborted: true })\n    },\n    { once: true }\n  )\n\n  // 11. Let handleFetchDone given response response be to finalize and\n  // report timing with response, globalObject, and \"fetch\".\n  const handleFetchDone = (response) =>\n    finalizeAndReportTiming(response, 'fetch')\n\n  // 12. Fetch request with processResponseEndOfBody set to handleFetchDone,\n  // and processResponse given response being these substeps:\n  const processResponse = (response) => {\n    // 1. If locallyAborted is true, terminate these substeps.\n    if (locallyAborted) {\n      return\n    }\n\n    // 2. If response’s aborted flag is set, then abort fetch with p,\n    // request, and responseObject, and terminate these substeps.\n    if (response.aborted) {\n      abortFetch.call(context, p, request, responseObject)\n      return\n    }\n\n    // 3. If response is a network error, then reject p with a TypeError\n    // and terminate these substeps.\n    if (response.type === 'error') {\n      p.reject(\n        Object.assign(new TypeError('fetch failed'), { cause: response.error })\n      )\n      return\n    }\n\n    // 4. Set responseObject to the result of creating a Response object,\n    // given response, \"immutable\", and relevantRealm.\n    responseObject = new Response()\n    responseObject[kState] = response\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = response.headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Resolve p with responseObject.\n    p.resolve(responseObject)\n  }\n\n  fetching\n    .call(context, {\n      request,\n      processResponseEndOfBody: handleFetchDone,\n      processResponse\n    })\n    .catch((err) => {\n      p.reject(err)\n    })\n\n  // 13. Return p.\n  return p.promise\n}\n\n// https://fetch.spec.whatwg.org/#finalize-and-report-timing\nfunction finalizeAndReportTiming (response, initiatorType = 'other') {\n  // 1. If response is an aborted network error, then return.\n  if (response.type === 'error' && response.aborted) {\n    return\n  }\n\n  // 2. If response’s URL list is null or empty, then return.\n  if (!response.urlList?.length) {\n    return\n  }\n\n  // 3. Let originalURL be response’s URL list[0].\n  const originalURL = response.urlList[0]\n\n  // 4. Let timingInfo be response’s timing info.\n  let timingInfo = response.timingInfo\n\n  // 5. Let cacheState be response’s cache state.\n  let cacheState = response.cacheState\n\n  // 6. If originalURL’s scheme is not an HTTP(S) scheme, then return.\n  if (!/^https?:/.test(originalURL.protocol)) {\n    return\n  }\n\n  // 7. If timingInfo is null, then return.\n  if (timingInfo === null) {\n    return\n  }\n\n  // 8. If response’s timing allow passed flag is not set, then:\n  if (!timingInfo.timingAllowPassed) {\n    //  1. Set timingInfo to a the result of creating an opaque timing info for timingInfo.\n    timingInfo = createOpaqueTimingInfo({\n      startTime: timingInfo.startTime\n    })\n\n    //  2. Set cacheState to the empty string.\n    cacheState = ''\n  }\n\n  // 9. Set timingInfo’s end time to the coarsened shared current time\n  // given global’s relevant settings object’s cross-origin isolated\n  // capability.\n  // TODO: given global’s relevant settings object’s cross-origin isolated\n  // capability?\n  response.timingInfo.endTime = coarsenedSharedCurrentTime()\n\n  // 10. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 11. Mark resource timing for timingInfo, originalURL, initiatorType,\n  // global, and cacheState.\n  markResourceTiming(\n    timingInfo,\n    originalURL,\n    initiatorType,\n    globalThis,\n    cacheState\n  )\n}\n\n// https://w3c.github.io/resource-timing/#dfn-mark-resource-timing\nfunction markResourceTiming () {\n  // TODO\n}\n\n// https://fetch.spec.whatwg.org/#abort-fetch\nfunction abortFetch (p, request, responseObject) {\n  // 1. Let error be an \"AbortError\" DOMException.\n  const error = new AbortError()\n\n  // 2. Reject promise with error.\n  p.reject(error)\n\n  // 3. If request’s body is not null and is readable, then cancel request’s\n  // body with error.\n  if (request.body != null && isReadable(request.body?.stream)) {\n    request.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n\n  // 4. If responseObject is null, then return.\n  if (responseObject == null) {\n    return\n  }\n\n  // 5. Let response be responseObject’s response.\n  const response = responseObject[kState]\n\n  // 6. If response’s body is not null and is readable, then error response’s\n  // body with error.\n  if (response.body != null && isReadable(response.body?.stream)) {\n    response.body.stream.cancel(error).catch((err) => {\n      if (err.code === 'ERR_INVALID_STATE') {\n        // Node bug?\n        return\n      }\n      throw err\n    })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetching\nfunction fetching ({\n  request,\n  processRequestBodyChunkLength,\n  processRequestEndOfBody,\n  processResponse,\n  processResponseEndOfBody,\n  processResponseConsumeBody,\n  useParallelQueue = false,\n}) {\n  // 1. Let taskDestination be null.\n  let taskDestination = null\n\n  // 2. Let crossOriginIsolatedCapability be false.\n  let crossOriginIsolatedCapability = false\n\n  // 3. If request’s client is non-null, then:\n  if (request.client != null) {\n    // 1. Set taskDestination to request’s client’s global object.\n    taskDestination = request.client.globalObject\n\n    // 2. Set crossOriginIsolatedCapability to request’s client’s cross-origin\n    // isolated capability.\n    crossOriginIsolatedCapability =\n      request.client.crossOriginIsolatedCapability\n  }\n\n  // 4. If useParallelQueue is true, then set taskDestination to the result of\n  // starting a new parallel queue.\n  // TODO\n\n  // 5. Let timingInfo be a new fetch timing info whose start time and\n  // post-redirect start time are the coarsened shared current time given\n  // crossOriginIsolatedCapability.\n  const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability)\n  const timingInfo = createOpaqueTimingInfo({\n    startTime: currenTime\n  })\n\n  // 6. Let fetchParams be a new fetch params whose\n  // request is request,\n  // timing info is timingInfo,\n  // process request body chunk length is processRequestBodyChunkLength,\n  // process request end-of-body is processRequestEndOfBody,\n  // process response is processResponse,\n  // process response consume body is processResponseConsumeBody,\n  // process response end-of-body is processResponseEndOfBody,\n  // task destination is taskDestination,\n  // and cross-origin isolated capability is crossOriginIsolatedCapability.\n  const fetchParams = {\n    request,\n    timingInfo,\n    processRequestBodyChunkLength,\n    processRequestEndOfBody,\n    processResponse,\n    processResponseConsumeBody,\n    processResponseEndOfBody,\n    taskDestination,\n    crossOriginIsolatedCapability\n  }\n\n  // 7. If request’s body is a byte sequence, then set request’s body to the\n  // first return value of safely extracting request’s body.\n  // NOTE: Since fetching is only called from fetch, body should already be\n  // extracted.\n  assert(!request.body || request.body.stream)\n\n  // 8. If request’s window is \"client\", then set request’s window to request’s\n  // client, if request’s client’s global object is a Window object; otherwise\n  // \"no-window\".\n  if (request.window === 'client') {\n    // TODO: What if request.client is null?\n    request.window =\n      request.client?.globalObject instanceof Window\n        ? request.client\n        : 'no-window'\n  }\n\n  // 9. If request’s origin is \"client\", then set request’s origin to request’s\n  // client’s origin.\n  if (request.origin === 'client') {\n    // TODO: What if request.client is null?\n    request.origin = request.client?.origin\n  }\n\n  // 10. If request’s policy container is \"client\", then:\n  if (request.policyContainer === 'client') {\n    // 1. If request’s client is non-null, then set request’s policy\n    // container to a clone of request’s client’s policy container. [HTML]\n    if (request.client != null) {\n      request.policyContainer = clonePolicyContainer(\n        request.client.policyContainer\n      )\n    } else {\n      // 2. Otherwise, set request’s policy container to a new policy\n      // container.\n      request.policyContainer = makePolicyContainer()\n    }\n  }\n\n  // 11. If request’s header list does not contain `Accept`, then:\n  if (!request.headersList.has('accept')) {\n    // 1. Let value be `*/*`.\n    const value = '*/*'\n\n    // 2. A user agent should set value to the first matching statement, if\n    // any, switching on request’s destination:\n    // \"document\"\n    // \"frame\"\n    // \"iframe\"\n    // `text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8`\n    // \"image\"\n    // `image/png,image/svg+xml,image/*;q=0.8,*/*;q=0.5`\n    // \"style\"\n    // `text/css,*/*;q=0.1`\n    // TODO\n\n    // 3. Append `Accept`/value to request’s header list.\n    request.headersList.append('accept', value)\n  }\n\n  // 12. If request’s header list does not contain `Accept-Language`, then\n  // user agents should append `Accept-Language`/an appropriate value to\n  // request’s header list.\n  if (!request.headersList.has('accept-language')) {\n    request.headersList.append('accept-language', '*')\n  }\n\n  // 13. If request’s priority is null, then use request’s initiator and\n  // destination appropriately in setting request’s priority to a\n  // user-agent-defined object.\n  if (request.priority === null) {\n    // TODO\n  }\n\n  // 14. If request is a subresource request, then:\n  if (subresource.includes(request.destination)) {\n    // 1. Let record be a new fetch record consisting of request and this\n    // instance of the fetch algorithm.\n    // TODO\n    // 2. Append record to request’s client’s fetch group list of fetch\n    // records.\n    // TODO\n  }\n\n  // 15. Run main fetch given fetchParams.\n  return mainFetch.call(this, fetchParams)\n}\n\n// https://fetch.spec.whatwg.org/#concept-main-fetch\nasync function mainFetch (fetchParams, recursive = false) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. If request’s local-URLs-only flag is set and request’s current URL is\n  // not local, then set response to a network error.\n  if (\n    request.localURLsOnly &&\n    !/^(about|blob|data):/.test(requestCurrentURL(request).protocol)\n  ) {\n    response = makeNetworkError('local URLs only')\n  }\n\n  // 4. Run report Content Security Policy violations for request.\n  // TODO\n\n  // 5. Upgrade request to a potentially trustworthy URL, if appropriate.\n  tryUpgradeRequestToAPotentiallyTrustworthyURL(request)\n\n  // 6. If should request be blocked due to a bad port, should fetching request\n  // be blocked as mixed content, or should request be blocked by Content\n  // Security Policy returns blocked, then set response to a network error.\n  if (requestBadPort(request) === 'blocked') {\n    response = makeNetworkError('bad port')\n  }\n  // TODO: should fetching request be blocked as mixed content?\n  // TODO: should request be blocked by Content Security Policy?\n\n  // 7. If request’s referrer policy is the empty string, then set request’s\n  // referrer policy to request’s policy container’s referrer policy.\n  if (request.referrerPolicy === '') {\n    request.referrerPolicy = request.policyContainer.referrerPolicy\n  }\n\n  // 8. If request’s referrer is not \"no-referrer\", then set request’s\n  // referrer to the result of invoking determine request’s referrer.\n  if (request.referrer !== 'no-referrer') {\n    request.referrer = determineRequestsReferrer(request)\n  }\n\n  // 9. Set request’s current URL’s scheme to \"https\" if all of the following\n  // conditions are true:\n  // - request’s current URL’s scheme is \"http\"\n  // - request’s current URL’s host is a domain\n  // - Matching request’s current URL’s host per Known HSTS Host Domain Name\n  //   Matching results in either a superdomain match with an asserted\n  //   includeSubDomains directive or a congruent match (with or without an\n  //   asserted includeSubDomains directive). [HSTS]\n  // TODO\n\n  // 10. If recursive is false, then run the remaining steps in parallel.\n  // TODO\n\n  // 11. If response is null, then set response to the result of running\n  // the steps corresponding to the first matching statement:\n  if (response === null) {\n    response = await (async () => {\n      const currentURL = requestCurrentURL(request)\n\n      if (\n        // - request’s current URL’s origin is same origin with request’s origin,\n        //   and request’s response tainting is \"basic\"\n        (sameOrigin(currentURL, request.url) && request.responseTainting === 'basic') ||\n        // request’s current URL’s scheme is \"data\"\n        (currentURL.protocol === 'data:') ||\n        // - request’s mode is \"navigate\" or \"websocket\"\n        (request.mode === 'navigate' || request.mode === 'websocket')\n      ) {\n        // 1. Set request’s response tainting to \"basic\".\n        request.responseTainting = 'basic'\n\n        // 2. Return the result of running scheme fetch given fetchParams.\n        return await schemeFetch\n          .call(this, fetchParams)\n      }\n\n      // request’s mode is \"same-origin\"\n      if (request.mode === 'same-origin') {\n        // 1. Return a network error.\n        return makeNetworkError('request mode cannot be \"same-origin\"')\n      }\n\n      // request’s mode is \"no-cors\"\n      if (request.mode === 'no-cors') {\n        // 1. If request’s redirect mode is not \"follow\", then return a network\n        // error.\n        if (request.redirect !== 'follow') {\n          return makeNetworkError(\n            'redirect mode cannot be \"follow\" for \"no-cors\" request'\n          )\n        }\n\n        // 2. Set request’s response tainting to \"opaque\".\n        request.responseTainting = 'opaque'\n\n        // 3. Let noCorsResponse be the result of running scheme fetch given\n        // fetchParams.\n        const noCorsResponse = await schemeFetch\n          .call(this, fetchParams)\n\n        // 4. If noCorsResponse is a filtered response or the CORB check with\n        // request and noCorsResponse returns allowed, then return noCorsResponse.\n        if (noCorsResponse.status === 0 || CORBCheck(request, noCorsResponse) === 'allowed') {\n          return noCorsResponse\n        }\n\n        // 5. Return a new response whose status is noCorsResponse’s status.\n        return makeResponse({ status: noCorsResponse.status })\n      }\n\n      // request’s current URL’s scheme is not an HTTP(S) scheme\n      if (!/^https?:/.test(requestCurrentURL(request).protocol)) {\n        // Return a network error.\n        return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n      }\n\n      // - request’s use-CORS-preflight flag is set\n      // - request’s unsafe-request flag is set and either request’s method is\n      //   not a CORS-safelisted method or CORS-unsafe request-header names with\n      //   request’s header list is not empty\n      //    1. Set request’s response tainting to \"cors\".\n      //    2. Let corsWithPreflightResponse be the result of running HTTP fetch\n      //    given fetchParams and true.\n      //    3. If corsWithPreflightResponse is a network error, then clear cache\n      //    entries using request.\n      //    4. Return corsWithPreflightResponse.\n      // TODO\n\n      // Otherwise\n      //    1. Set request’s response tainting to \"cors\".\n      request.responseTainting = 'cors'\n\n      //    2. Return the result of running HTTP fetch given fetchParams.\n      return await httpFetch\n        .call(this, fetchParams)\n        .catch((err) => makeNetworkError(err))\n    })()\n  }\n\n  // 12. If recursive is true, then return response.\n  if (recursive) {\n    return response\n  }\n\n  // 13. If response is not a network error and response is not a filtered\n  // response, then:\n  if (response.status !== 0 && !response.internalResponse) {\n    // If request’s response tainting is \"cors\", then:\n    if (request.responseTainting === 'cors') {\n      // 1. Let headerNames be the result of extracting header list values\n      // given `Access-Control-Expose-Headers` and response’s header list.\n      // TODO\n      // 2. If request’s credentials mode is not \"include\" and headerNames\n      // contains `*`, then set response’s CORS-exposed header-name list to\n      // all unique header names in response’s header list.\n      // TODO\n      // 3. Otherwise, if headerNames is not null or failure, then set\n      // response’s CORS-exposed header-name list to headerNames.\n      // TODO\n    }\n\n    // Set response to the following filtered response with response as its\n    // internal response, depending on request’s response tainting:\n    if (request.responseTainting === 'basic') {\n      response = filterResponse(response, 'basic')\n    } else if (request.responseTainting === 'cors') {\n      response = filterResponse(response, 'cors')\n    } else if (request.responseTainting === 'opaque') {\n      response = filterResponse(response, 'opaque')\n    } else {\n      assert(false)\n    }\n  }\n\n  // 14. Let internalResponse be response, if response is a network error,\n  // and response’s internal response otherwise.\n  let internalResponse =\n    response.status === 0 ? response : response.internalResponse\n\n  // 15. If internalResponse’s URL list is empty, then set it to a clone of\n  // request’s URL list.\n  if (internalResponse.urlList.length === 0) {\n    internalResponse.urlList.push(...request.urlList)\n  }\n\n  // 16. If request’s timing allow failed flag is unset, then set\n  // internalResponse’s timing allow passed flag.\n  if (!request.timingAllowFailed) {\n    response.timingAllowPassed = true\n  }\n\n  // 17. If response is not a network error and any of the following returns\n  // blocked\n  // - should internalResponse to request be blocked as mixed content\n  // - should internalResponse to request be blocked by Content Security Policy\n  // - should internalResponse to request be blocked due to its MIME type\n  // - should internalResponse to request be blocked due to nosniff\n  // TODO\n\n  // 18. If response’s type is \"opaque\", internalResponse’s status is 206,\n  // internalResponse’s range-requested flag is set, and request’s header\n  // list does not contain `Range`, then set response and internalResponse\n  // to a network error.\n  if (\n    response.type === 'opaque' &&\n    internalResponse.status === 206 &&\n    internalResponse.rangeRequested &&\n    !request.headers.has('range')\n  ) {\n    response = internalResponse = makeNetworkError()\n  }\n\n  // 19. If response is not a network error and either request’s method is\n  // `HEAD` or `CONNECT`, or internalResponse’s status is a null body status,\n  // set internalResponse’s body to null and disregard any enqueuing toward\n  // it (if any).\n  if (\n    response.status !== 0 &&\n    (request.method === 'HEAD' ||\n      request.method === 'CONNECT' ||\n      nullBodyStatus.includes(internalResponse.status))\n  ) {\n    internalResponse.body = null\n    context.dump = true\n  }\n\n  // 20. If request’s integrity metadata is not the empty string, then:\n  if (request.integrity) {\n    // 1. Let processBodyError be this step: run fetch finale given fetchParams\n    // and a network error.\n    const processBodyError = (reason) =>\n      fetchFinale.call(context, fetchParams, makeNetworkError(reason))\n\n    // 2. If request’s response tainting is \"opaque\", or response’s body is null,\n    // then run processBodyError and abort these steps.\n    if (request.responseTainting === 'opaque' || response.body == null) {\n      processBodyError(response.error)\n      return\n    }\n\n    // 3. Let processBody given bytes be these steps:\n    const processBody = (bytes) => {\n      // 1. If bytes do not match request’s integrity metadata,\n      // then run processBodyError and abort these steps. [SRI]\n      if (!matchRequestIntegrity(request, bytes)) {\n        processBodyError('integrity mismatch')\n        return\n      }\n\n      // 2. Set response’s body to the first return value of safely\n      // extracting bytes.\n      response.body = safelyExtractBody(bytes)[0]\n\n      // 3. Run fetch finale given fetchParams and response.\n      fetchFinale.call(context, fetchParams, response)\n    }\n\n    // 4. Fully read response’s body given processBody and processBodyError.\n    try {\n      processBody(await response.arrayBuffer())\n    } catch (err) {\n      processBodyError(err)\n    }\n  } else {\n    // 21. Otherwise, run fetch finale given fetchParams and response.\n    fetchFinale.call(context, fetchParams, response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#concept-scheme-fetch\n// given a fetch params fetchParams\nasync function schemeFetch (fetchParams) {\n  const context = this\n\n  // let request be fetchParams’s request\n  const { request } = fetchParams\n\n  const {\n    protocol: scheme,\n    pathname: path\n  } = new URL(requestCurrentURL(request))\n\n  // switch on request’s current URL’s scheme, and run the associated steps:\n  switch (scheme) {\n    case 'about:': {\n      // If request’s current URL’s path is the string \"blank\", then return a new response\n      // whose status message is `OK`, header list is « (`Content-Type`, `text/html;charset=utf-8`) », \n      // and body is the empty byte sequence. \n      if (path === 'blank') {\n        const resp = makeResponse({\n          statusText: 'OK',\n          headersList: [\n            'content-type', 'text/html;charset=utf-8'\n          ]\n        })\n        \n        resp.urlList = [new URL('about:blank')]\n        return resp\n      }\n\n      // Otherwise, return a network error.\n      return makeNetworkError('invalid path called')\n    }\n    case 'blob:': {\n      resolveObjectURL ??= require('buffer').resolveObjectURL\n\n      context.on('terminated', onRequestAborted)\n\n      // 1. Run these steps, but abort when the ongoing fetch is terminated: \n      //  1a. Let blob be request’s current URL’s blob URL entry’s object.\n      //      https://w3c.github.io/FileAPI/#blob-url-entry\n      //      P.S. Thank God this method is available in node.\n      const currentURL = requestCurrentURL(request)\n      \n      // https://github.com/web-platform-tests/wpt/blob/7b0ebaccc62b566a1965396e5be7bb2bc06f841f/FileAPI/url/resources/fetch-tests.js#L52-L56\n      // Buffer.resolveObjectURL does not ignore URL queries.\n      if (currentURL.search.length !== 0) {\n        return makeNetworkError('NetworkError when attempting to fetch resource.')\n      }\n\n      const blob = resolveObjectURL(currentURL.toString())\n\n      //  2a. If request’s method is not `GET` or blob is not a Blob object, then return a network error. [FILEAPI]\n      if (request.method !== 'GET' || !isBlobLike(blob)) {\n        return makeNetworkError('invalid method')\n      }\n\n      //  3a. Let response be a new response whose status message is `OK`. \n      const response = makeResponse({ statusText: 'OK', urlList: [currentURL] })\n\n      //  4a. Append (`Content-Length`, blob’s size attribute value) to response’s header list.\n      response.headersList.set('content-length', `${blob.size}`)\n\n      //  5a. Append (`Content-Type`, blob’s type attribute value) to response’s header list.\n      response.headersList.set('content-type', blob.type)\n\n      //  6a. Set response’s body to the result of performing the read operation on blob.\n      response.body = extractBody(blob)[0]\n\n      // since the request has not been aborted, we can safely remove the listener.\n      context.off('terminated', onRequestAborted)\n\n      //  7a. Return response.\n      return response\n\n      // 2. If aborted, then:\n      function onRequestAborted () {\n        // 1. Let aborted be the termination’s aborted flag.\n        const aborted = context.terminated.aborted\n\n        // 2. If aborted is set, then return an aborted network error.\n        if (aborted) {\n          return makeNetworkError(new AbortError())\n        }\n\n        // 3. Return a network error.\n        return makeNetworkError(context.terminated.reason)\n      }\n    }\n    case 'data:': {\n      // 1. Let dataURLStruct be the result of running the\n      //    data: URL processor on request’s current URL.\n      const currentURL = requestCurrentURL(request)\n      const dataURLStruct = dataURLProcessor(currentURL)\n\n      // 2. If dataURLStruct is failure, then return a\n      //    network error.\n      if (dataURLStruct === 'failure') {\n        return makeNetworkError('failed to fetch the data URL')\n      }\n\n      // 3. Let mimeType be dataURLStruct’s MIME type, serialized.\n      const { mimeType } = dataURLStruct\n\n      /** @type {string} */\n      let contentType = `${mimeType.type}/${mimeType.subtype}`\n      const contentTypeParams = []\n\n      if (mimeType.parameters.size > 0) {\n        contentType += ';'\n      }\n\n      for (const [key, value] of mimeType.parameters) {\n        if (value.length > 0) {\n          contentTypeParams.push(`${key}=${value}`)\n        } else {\n          contentTypeParams.push(key)\n        }\n      }\n\n      contentType += contentTypeParams.join(',')\n\n      // 4. Return a response whose status message is `OK`,\n      //    header list is « (`Content-Type`, mimeType) »,\n      //    and body is dataURLStruct’s body.\n      return makeResponse({\n        statusText: 'OK',\n        headersList: [\n          'content-type', contentType\n        ],\n        body: dataURLStruct.body\n      })\n    }\n    case 'file:': {\n      // For now, unfortunate as it is, file URLs are left as an exercise for the reader.\n      // When in doubt, return a network error.\n      return makeNetworkError('not implemented... yet...')\n    }\n    case 'http:':\n    case 'https:': {\n      // Return the result of running HTTP fetch given fetchParams.\n\n      return await httpFetch\n        .call(this, fetchParams)\n        .catch((err) => makeNetworkError(err))\n    }\n    default: {\n      return makeNetworkError('unknown scheme')\n    }\n  }\n}\n\n// https://fetch.spec.whatwg.org/#finalize-response\nfunction finalizeResponse (fetchParams, response) {\n  // 1. Set fetchParams’s request’s done flag.\n  fetchParams.request.done = true\n\n  // 2, If fetchParams’s process response done is not null, then queue a fetch\n  // task to run fetchParams’s process response done given response, with\n  // fetchParams’s task destination.\n  if (fetchParams.processResponseDone != null) {\n    fetchParams.processResponseDone(response)\n  }\n}\n\n// https://fetch.spec.whatwg.org/#fetch-finale\nfunction fetchFinale (fetchParams, response) {\n  const context = this\n\n  // 1. If response is a network error, then:\n  if (response.type === 'error') {\n    // 1. Set response’s URL list to « fetchParams’s request’s URL list[0] ».\n    response.urlList = [fetchParams.request.urlList[0]]\n\n    // 2. Set response’s timing info to the result of creating an opaque timing\n    // info for fetchParams’s timing info.\n    response.timingInfo = createOpaqueTimingInfo({\n      startTime: fetchParams.timingInfo.startTime\n    })\n  }\n\n  // 2. Let processResponseEndOfBody be the following steps:\n  // TODO\n\n  // 3. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  if (fetchParams.processResponse != null) {\n    fetchParams.processResponse(response)\n  }\n\n  // 4. If fetchParams’s process response is non-null, then queue a fetch task\n  // to run fetchParams’s process response given response, with fetchParams’s\n  // task destination.\n  // TODO\n\n  // 5. If response’s body is null, then run processResponseEndOfBody.\n  // TODO\n\n  // 6. Otherwise:\n  // TODO\n\n  // 7. If fetchParams’s process response consume body is non-null, then:\n  // TODO\n\n  // TODO: This is a workaround. Until the above has been implemented, i.e.\n  // we need to either fully consume the body or terminate the fetch.\n  if (response.type === 'error') {\n    context.terminate({ reason: response.error })\n  }\n}\n\n// https://fetch.spec.whatwg.org/#http-fetch\nasync function httpFetch (fetchParams) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let response be null.\n  let response = null\n\n  // 3. Let actualResponse be null.\n  let actualResponse = null\n\n  // 4. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 5. If request’s service-workers mode is \"all\", then:\n  if (request.serviceWorkers === 'all') {\n    // TODO\n  }\n\n  // 6. If response is null, then:\n  if (response === null) {\n    // 1. If makeCORSPreflight is true and one of these conditions is true:\n    // TODO\n\n    // 2. If request’s redirect mode is \"follow\", then set request’s\n    // service-workers mode to \"none\".\n    if (request.redirect === 'follow') {\n      request.serviceWorkers = 'none'\n    }\n\n    // 3. Set response and actualResponse to the result of running\n    // HTTP-network-or-cache fetch given fetchParams.\n    actualResponse = response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams\n    )\n\n    // 4. If request’s response tainting is \"cors\" and a CORS check\n    // for request and response returns failure, then return a network error.\n    if (\n      request.responseTainting === 'cors' &&\n      corsCheck(request, response) === 'failure'\n    ) {\n      return makeNetworkError('cors failure')\n    }\n\n    // 5. If the TAO check for request and response returns failure, then set\n    // request’s timing allow failed flag.\n    if (TAOCheck(request, response) === 'failure') {\n      request.timingAllowFailed = true\n    }\n  }\n\n  // 7. If either request’s response tainting or response’s type\n  // is \"opaque\", and the cross-origin resource policy check with\n  // request’s origin, request’s client, request’s destination,\n  // and actualResponse returns blocked, then return a network error.\n  if (\n    (request.responseTainting === 'opaque' || response.type === 'opaque') &&\n    crossOriginResourcePolicyCheck(\n      request.origin,\n      request.client,\n      request.destination,\n      actualResponse\n    ) === 'blocked'\n  ) {\n    return makeNetworkError('blocked')\n  }\n\n  // 8. If actualResponse’s status is a redirect status, then:\n  if (redirectStatus.includes(actualResponse.status)) {\n    // 1. If actualResponse’s status is not 303, request’s body is not null,\n    // and the connection uses HTTP/2, then user agents may, and are even\n    // encouraged to, transmit an RST_STREAM frame.\n    // See, https://github.com/whatwg/fetch/issues/1288\n    context.connection.destroy()\n\n    // 2. Switch on request’s redirect mode:\n    if (request.redirect === 'error') {\n      // Set response to a network error.\n      response = makeNetworkError()\n    } else if (request.redirect === 'manual') {\n      // Set response to an opaque-redirect filtered response whose internal\n      // response is actualResponse.\n      // NOTE(spec): On the web this would return an `opaqueredirect` response,\n      // but that doesn't make sense server side.\n      // See https://github.com/nodejs/undici/issues/1193.\n      response = actualResponse\n    } else if (request.redirect === 'follow') {\n      // Set response to the result of running HTTP-redirect fetch given\n      // fetchParams and response.\n      response = await httpRedirectFetch.call(this, fetchParams, response)\n    } else {\n      assert(false)\n    }\n  }\n\n  // 9. Set response’s timing info to timingInfo.\n  response.timingInfo = timingInfo\n\n  // 10. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-redirect-fetch\nasync function httpRedirectFetch (fetchParams, response) {\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let actualResponse be response, if response is not a filtered response,\n  // and response’s internal response otherwise.\n  const actualResponse = response.internalResponse\n    ? response.internalResponse\n    : response\n\n  // 3. Let locationURL be actualResponse’s location URL given request’s current\n  // URL’s fragment.\n  let locationURL\n\n  try {\n    locationURL = responseLocationURL(\n      actualResponse,\n      requestCurrentURL(request).hash\n    )\n\n    // 4. If locationURL is null, then return response.\n    if (locationURL == null) {\n      return response\n    }\n  } catch (err) {\n    // 5. If locationURL is failure, then return a network error.\n    return makeNetworkError(err)\n  }\n\n  // 6. If locationURL’s scheme is not an HTTP(S) scheme, then return a network\n  // error.\n  if (!/^https?:/.test(locationURL.protocol)) {\n    return makeNetworkError('URL scheme must be a HTTP(S) scheme')\n  }\n\n  // 7. If request’s redirect count is twenty, return a network error.\n  if (request.redirectCount === 20) {\n    return makeNetworkError('redirect count exceeded')\n  }\n\n  // 8. Increase request’s redirect count by one.\n  request.redirectCount += 1\n\n  // 9. If request’s mode is \"cors\", locationURL includes credentials, and\n  // request’s origin is not same origin with locationURL’s origin, then return\n  //  a network error.\n  if (\n    request.mode === 'cors' &&\n    (locationURL.username || locationURL.password) &&\n    !sameOrigin(request, locationURL)\n  ) {\n    return makeNetworkError('cross origin not allowed for request mode \"cors\"')\n  }\n\n  // 10. If request’s response tainting is \"cors\" and locationURL includes\n  // credentials, then return a network error.\n  if (\n    request.responseTainting === 'cors' &&\n    (locationURL.username || locationURL.password)\n  ) {\n    return makeNetworkError(\n      'URL cannot contain credentials for request mode \"cors\"'\n    )\n  }\n\n  // 11. If actualResponse’s status is not 303, request’s body is non-null,\n  // and request’s body’s source is null, then return a network error.\n  if (\n    actualResponse.status !== 303 &&\n    request.body != null &&\n    request.body.source == null\n  ) {\n    return makeNetworkError()\n  }\n\n  // 12. If one of the following is true\n  // - actualResponse’s status is 301 or 302 and request’s method is `POST`\n  // - actualResponse’s status is 303 and request’s method is not `GET` or `HEAD`\n  if (\n    ([301, 302].includes(actualResponse.status) && request.method === 'POST') ||\n    (actualResponse.status === 303 &&\n      !['GET', 'HEADER'].includes(request.method))\n  ) {\n    // then:\n    // 1. Set request’s method to `GET` and request’s body to null.\n    request.method = 'GET'\n    request.body = null\n\n    // 2. For each headerName of request-body-header name, delete headerName from\n    // request’s header list.\n    for (const headerName of requestBodyHeader) {\n      request.headersList.delete(headerName)\n    }\n  }\n\n  // 13. If request’s body is non-null, then set request’s body to the first return\n  // value of safely extracting request’s body’s source.\n  if (request.body != null) {\n    assert(request.body.source)\n    request.body = safelyExtractBody(request.body.source)[0]\n  }\n\n  // 14. Let timingInfo be fetchParams’s timing info.\n  const timingInfo = fetchParams.timingInfo\n\n  // 15. Set timingInfo’s redirect end time and post-redirect start time to the\n  // coarsened shared current time given fetchParams’s cross-origin isolated\n  // capability.\n  timingInfo.redirectEndTime = timingInfo.postRedirectStartTime =\n    coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability)\n\n  // 16. If timingInfo’s redirect start time is 0, then set timingInfo’s\n  //  redirect start time to timingInfo’s start time.\n  if (timingInfo.redirectStartTime === 0) {\n    timingInfo.redirectStartTime = timingInfo.startTime\n  }\n\n  // 17. Append locationURL to request’s URL list.\n  request.urlList.push(locationURL)\n\n  // 18. Invoke set request’s referrer policy on redirect on request and\n  // actualResponse.\n  setRequestReferrerPolicyOnRedirect(request, actualResponse)\n\n  // 19. Return the result of running main fetch given fetchParams and true.\n  return mainFetch.call(this, fetchParams, true)\n}\n\n// https://fetch.spec.whatwg.org/#http-network-or-cache-fetch\nasync function httpNetworkOrCacheFetch (\n  fetchParams,\n  isAuthenticationFetch = false,\n  isNewConnectionFetch = false\n) {\n  const context = this\n\n  // 1. Let request be fetchParams’s request.\n  const request = fetchParams.request\n\n  // 2. Let httpFetchParams be null.\n  let httpFetchParams = null\n\n  // 3. Let httpRequest be null.\n  let httpRequest = null\n\n  // 4. Let response be null.\n  let response = null\n\n  // 5. Let storedResponse be null.\n  // TODO: cache\n\n  // 6. Let httpCache be null.\n  const httpCache = null\n\n  // 7. Let the revalidatingFlag be unset.\n  const revalidatingFlag = false\n\n  // 8. Run these steps, but abort when the ongoing fetch is terminated:\n\n  //    1. If request’s window is \"no-window\" and request’s redirect mode is\n  //    \"error\", then set httpFetchParams to fetchParams and httpRequest to\n  //    request.\n  if (request.window === 'no-window' && request.redirect === 'error') {\n    httpFetchParams = fetchParams\n    httpRequest = request\n  } else {\n    // Otherwise:\n\n    // 1. Set httpRequest to a clone of request.\n    httpRequest = makeRequest(request)\n\n    // 2. Set httpFetchParams to a copy of fetchParams.\n    httpFetchParams = { ...fetchParams }\n\n    // 3. Set httpFetchParams’s request to httpRequest.\n    httpFetchParams.request = httpRequest\n  }\n\n  //    3. Let includeCredentials be true if one of\n  const includeCredentials =\n    request.credentials === 'include' ||\n    (request.credentials === 'same-origin' &&\n      request.responseTainting === 'basic')\n\n  //    4. Let contentLength be httpRequest’s body’s length, if httpRequest’s\n  //    body is non-null; otherwise null.\n  const contentLength = httpRequest.body ? httpRequest.body.length : null\n\n  //    5. Let contentLengthHeaderValue be null.\n  let contentLengthHeaderValue = null\n\n  //    6. If httpRequest’s body is null and httpRequest’s method is `POST` or\n  //    `PUT`, then set contentLengthHeaderValue to `0`.\n  if (\n    httpRequest.body == null &&\n    ['POST', 'PUT'].includes(httpRequest.method)\n  ) {\n    contentLengthHeaderValue = '0'\n  }\n\n  //    7. If contentLength is non-null, then set contentLengthHeaderValue to\n  //    contentLength, serialized and isomorphic encoded.\n  if (contentLength != null) {\n    // TODO: isomorphic encoded\n    contentLengthHeaderValue = String(contentLength)\n  }\n\n  //    8. If contentLengthHeaderValue is non-null, then append\n  //    `Content-Length`/contentLengthHeaderValue to httpRequest’s header\n  //    list.\n  if (contentLengthHeaderValue != null) {\n    httpRequest.headersList.append('content-length', contentLengthHeaderValue)\n  }\n\n  //    9. If contentLength is non-null and httpRequest’s keepalive is true,\n  //    then:\n  if (contentLength != null && httpRequest.keepalive) {\n    // NOTE: keepalive is a noop outside of browser context.\n  }\n\n  //    10 .If httpRequest’s referrer is a URL, then append\n  //    `Referer`/httpRequest’s referrer, serialized and isomorphic encoded,\n  //     to httpRequest’s header list.\n  if (httpRequest.referrer instanceof URL) {\n    // TODO: isomorphic encoded\n    httpRequest.headersList.append('referer', httpRequest.referrer.href)\n  }\n\n  //    11. Append a request `Origin` header for httpRequest.\n  appendRequestOriginHeader(httpRequest)\n\n  //    12. Append the Fetch metadata headers for httpRequest. [FETCH-METADATA]\n  appendFetchMetadata(httpRequest)\n\n  //    13. If httpRequest’s header list does not contain `User-Agent`, then\n  //    user agents should append `User-Agent`/default `User-Agent` value to\n  //    httpRequest’s header list.\n  if (!httpRequest.headersList.has('user-agent')) {\n    httpRequest.headersList.append('user-agent', 'undici')\n  }\n\n  //    14. If httpRequest’s cache mode is \"default\" and httpRequest’s header\n  //    list contains `If-Modified-Since`, `If-None-Match`,\n  //    `If-Unmodified-Since`, `If-Match`, or `If-Range`, then set\n  //    httpRequest’s cache mode to \"no-store\".\n  if (\n    httpRequest.cache === 'default' &&\n    (httpRequest.headersList.has('if-modified-since') ||\n      httpRequest.headersList.has('if-none-match') ||\n      httpRequest.headersList.has('if-unmodified-since') ||\n      httpRequest.headersList.has('if-match') ||\n      httpRequest.headersList.has('if-range'))\n  ) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    15. If httpRequest’s cache mode is \"no-cache\", httpRequest’s prevent\n  //    no-cache cache-control header modification flag is unset, and\n  //    httpRequest’s header list does not contain `Cache-Control`, then append\n  //    `Cache-Control`/`max-age=0` to httpRequest’s header list.\n  if (\n    httpRequest.cache === 'no-cache' &&\n    !httpRequest.preventNoCacheCacheControlHeaderModification &&\n    !httpRequest.headersList.has('cache-control')\n  ) {\n    httpRequest.headersList.append('cache-control', 'max-age=0')\n  }\n\n  //    16. If httpRequest’s cache mode is \"no-store\" or \"reload\", then:\n  if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {\n    // 1. If httpRequest’s header list does not contain `Pragma`, then append\n    // `Pragma`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('pragma')) {\n      httpRequest.headersList.append('pragma', 'no-cache')\n    }\n\n    // 2. If httpRequest’s header list does not contain `Cache-Control`,\n    // then append `Cache-Control`/`no-cache` to httpRequest’s header list.\n    if (!httpRequest.headersList.has('cache-control')) {\n      httpRequest.headersList.append('cache-control', 'no-cache')\n    }\n  }\n\n  //    17. If httpRequest’s header list contains `Range`, then append\n  //    `Accept-Encoding`/`identity` to httpRequest’s header list.\n  if (httpRequest.headersList.has('range')) {\n    httpRequest.headersList.append('accept-encoding', 'identity')\n  }\n\n  //    18. Modify httpRequest’s header list per HTTP. Do not append a given\n  //    header if httpRequest’s header list contains that header’s name.\n  //    TODO: https://github.com/whatwg/fetch/issues/1285#issuecomment-896560129\n  if (!httpRequest.headersList.has('accept-encoding')) {\n    if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {\n      httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate')\n    } else {\n      httpRequest.headersList.append('accept-encoding', 'gzip, deflate')\n    }\n  }\n\n  //    19. If includeCredentials is true, then:\n  if (includeCredentials) {\n    // 1. If the user agent is not configured to block cookies for httpRequest\n    // (see section 7 of [COOKIES]), then:\n    // TODO: credentials\n    // 2. If httpRequest’s header list does not contain `Authorization`, then:\n    // TODO: credentials\n  }\n\n  //    20. If there’s a proxy-authentication entry, use it as appropriate.\n  //    TODO: proxy-authentication\n\n  //    21. Set httpCache to the result of determining the HTTP cache\n  //    partition, given httpRequest.\n  //    TODO: cache\n\n  //    22. If httpCache is null, then set httpRequest’s cache mode to\n  //    \"no-store\".\n  if (httpCache == null) {\n    httpRequest.cache = 'no-store'\n  }\n\n  //    23. If httpRequest’s cache mode is neither \"no-store\" nor \"reload\",\n  //    then:\n  if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload') {\n    // TODO: cache\n  }\n\n  // 9. If aborted, then:\n  // TODO\n\n  // 10. If response is null, then:\n  if (response == null) {\n    // 1. If httpRequest’s cache mode is \"only-if-cached\", then return a\n    // network error.\n    if (httpRequest.mode === 'only-if-cached') {\n      return makeNetworkError('only if cached')\n    }\n\n    // 2. Let forwardResponse be the result of running HTTP-network fetch\n    // given httpFetchParams, includeCredentials, and isNewConnectionFetch.\n    const forwardResponse = await httpNetworkFetch.call(\n      this,\n      httpFetchParams,\n      includeCredentials,\n      isNewConnectionFetch\n    )\n\n    // 3. If httpRequest’s method is unsafe and forwardResponse’s status is\n    // in the range 200 to 399, inclusive, invalidate appropriate stored\n    // responses in httpCache, as per the \"Invalidation\" chapter of HTTP\n    // Caching, and set storedResponse to null. [HTTP-CACHING]\n    if (\n      !safeMethods.includes(httpRequest.method) &&\n      forwardResponse.status >= 200 &&\n      forwardResponse.status <= 399\n    ) {\n      // TODO: cache\n    }\n\n    // 4. If the revalidatingFlag is set and forwardResponse’s status is 304,\n    // then:\n    if (revalidatingFlag && forwardResponse.status === 304) {\n      // TODO: cache\n    }\n\n    // 5. If response is null, then:\n    if (response == null) {\n      // 1. Set response to forwardResponse.\n      response = forwardResponse\n\n      // 2. Store httpRequest and forwardResponse in httpCache, as per the\n      // \"Storing Responses in Caches\" chapter of HTTP Caching. [HTTP-CACHING]\n      // TODO: cache\n    }\n  }\n\n  // 11. Set response’s URL list to a clone of httpRequest’s URL list.\n  response.urlList = [...httpRequest.urlList]\n\n  // 12. If httpRequest’s header list contains `Range`, then set response’s\n  // range-requested flag.\n  if (httpRequest.headersList.has('range')) {\n    response.rangeRequested = true\n  }\n\n  // 13. If response’s status is 401, httpRequest’s response tainting is not\n  // \"cors\", includeCredentials is true, and request’s window is an environment\n  // settings object, then:\n  // TODO\n\n  // 14. If response’s status is 407, then:\n  if (response.status === 407) {\n    // 1. If request’s window is \"no-window\", then return a network error.\n    if (request.window === 'no-window') {\n      return makeNetworkError()\n    }\n\n    // 2. ???\n\n    // 3. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 4. Prompt the end user as appropriate in request’s window and store\n    // the result as a proxy-authentication entry. [HTTP-AUTH]\n    // TODO: Invoke some kind of callback?\n\n    // 5. Set response to the result of running HTTP-network-or-cache fetch given\n    // fetchParams.\n    // TODO\n    return makeNetworkError('proxy authentication required')\n  }\n\n  // 15. If all of the following are true\n  if (\n    // response’s status is 421\n    response.status === 421 &&\n    // isNewConnectionFetch is false\n    !isNewConnectionFetch &&\n    // request’s body is null, or request’s body is non-null and request’s body’s source is non-null\n    (request.body == null || request.body.source != null)\n  ) {\n    // then:\n\n    // 1. If the ongoing fetch is terminated, then:\n    if (context.terminated) {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = context.terminated.aborted\n\n      // 2. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return makeNetworkError(new AbortError())\n      }\n\n      // 3. Return a network error.\n      return makeNetworkError(context.terminated.reason)\n    }\n\n    // 2. Set response to the result of running HTTP-network-or-cache\n    // fetch given fetchParams, isAuthenticationFetch, and true.\n\n    // TODO (spec): The spec doesn't specify this but we need to cancel\n    // the active response before we can start a new one.\n    // https://github.com/whatwg/fetch/issues/1293\n    context.connection.destroy()\n\n    response = await httpNetworkOrCacheFetch.call(\n      this,\n      fetchParams,\n      isAuthenticationFetch,\n      true\n    )\n  }\n\n  // 16. If isAuthenticationFetch is true, then create an authentication entry\n  if (isAuthenticationFetch) {\n    // TODO\n  }\n\n  // 17. Return response.\n  return response\n}\n\n// https://fetch.spec.whatwg.org/#http-network-fetch\nfunction httpNetworkFetch (\n  fetchParams,\n  includeCredentials = false,\n  forceNewConnection = false\n) {\n  const context = this\n\n  return new Promise((resolve) => {\n    assert(!context.connection || context.connection.destroyed)\n\n    context.connection = {\n      abort: null,\n      destroyed: false,\n      destroy (err) {\n        if (!this.destroyed) {\n          this.destroyed = true\n          this.abort?.(err ?? new AbortError())\n        }\n      }\n    }\n\n    // 1. Let request be fetchParams’s request.\n    const request = fetchParams.request\n\n    // 2. Let response be null.\n    let response = null\n\n    // 3. Let timingInfo be fetchParams’s timing info.\n    const timingInfo = fetchParams.timingInfo\n\n    // 4. Let httpCache be the result of determining the HTTP cache partition,\n    // given request.\n    // TODO: cache\n    const httpCache = null\n\n    // 5. If httpCache is null, then set request’s cache mode to \"no-store\".\n    if (httpCache == null) {\n      request.cache = 'no-store'\n    }\n\n    // 6. Let networkPartitionKey be the result of determining the network\n    // partition key given request.\n    // TODO\n\n    // 7. Switch on request’s mode:\n    if (request.mode === 'websocket') {\n      // Let connection be the result of obtaining a WebSocket connection,\n      // given request’s current URL.\n      // TODO\n    } else {\n      // Let connection be the result of obtaining a connection, given\n      // networkPartitionKey, request’s current URL’s origin,\n      // includeCredentials, and forceNewConnection.\n      // TODO\n    }\n\n    // 8. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO: When do we cleanup this listener?\n    context.on('terminated', onRequestAborted)\n\n    //    5. Set response to the result of making an HTTP request over connection\n    //    using request with the following caveats:\n\n    //    Follow the relevant requirements from HTTP. [HTTP] [HTTP-SEMANTICS]\n    //    [HTTP-COND] [HTTP-CACHING] [HTTP-AUTH]\n\n    //    If request’s body is non-null, and request’s body’s source is null,\n    //    then the user agent may have a buffer of up to 64 kibibytes and store\n    //    a part of request’s body in that buffer. If the user agent reads from\n    //    request’s body beyond that buffer’s size and the user agent needs to\n    //    resend request, then instead return a network error.\n    //    TODO\n\n    //    Set timingInfo’s final network-response start time to the coarsened\n    //    shared current time given fetchParams’s cross-origin isolated capability,\n    //    immediately after the user agent’s HTTP parser receives the first byte\n    //    of the response (e.g., frame header bytes for HTTP/2 or response status\n    //    line for HTTP/1.x).\n    //    TODO\n\n    //    Wait until all the headers are transmitted.\n\n    //    Any responses whose status is in the range 100 to 199, inclusive,\n    //    and is not 101, are to be ignored, except for the purposes of setting\n    //    timingInfo’s final network-response start time above.\n\n    //    If request’s header list contains `Transfer-Encoding`/`chunked` and\n    //    response is transferred via HTTP/1.0 or older, then return a network\n    //    error.\n\n    //    If the HTTP request results in a TLS client certificate dialog, then:\n\n    //        1. If request’s window is an environment settings object, make the\n    //        dialog available in request’s window.\n\n    //        2. Otherwise, return a network error.\n\n    // To transmit request’s body body, run these steps:\n    const body = (async function * () {\n      try {\n        // 1. If body is null and fetchParams’s process request end-of-body is\n        // non-null, then queue a fetch task given fetchParams’s process request\n        // end-of-body and fetchParams’s task destination.\n        if (request.body === null) {\n          fetchParams.processEndOfBody?.()\n          return\n        }\n\n        // 2. Otherwise, if body is non-null:\n\n        //    1. Let processBodyChunk given bytes be these steps:\n        for await (const bytes of request.body.stream) {\n          // 1. If the ongoing fetch is terminated, then abort these steps.\n          if (context.terminated) {\n            return\n          }\n\n          // 2. Run this step in parallel: transmit bytes.\n          yield bytes\n\n          // 3. If fetchParams’s process request body is non-null, then run\n          // fetchParams’s process request body given bytes’s length.\n          fetchParams.processRequestBody?.(bytes.byteLength)\n        }\n\n        // 2. Let processEndOfBody be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If fetchParams’s process request end-of-body is non-null,\n        //    then run fetchParams’s process request end-of-body.\n        fetchParams.processRequestEndOfBody?.()\n      } catch (e) {\n        // 3. Let processBodyError given e be these steps:\n\n        //    1. If the ongoing fetch is terminated, then abort these steps.\n        if (context.terminated) {\n          return\n        }\n\n        //    2. If e is an \"AbortError\" DOMException, then terminate the ongoing fetch with the aborted flag set.\n        //    3. Otherwise, terminate the ongoing fetch.\n        context.terminate({\n          aborted: e.name === 'AbortError',\n          reason: e\n        })\n      }\n    })()\n\n    // 9. If aborted, then:\n    function onRequestAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      this.connection.destroy()\n\n      // 3. If aborted is set, then return an aborted network error.\n      if (aborted) {\n        return resolve(makeNetworkError(new AbortError()))\n      }\n\n      // 4. Return a network error.\n      return resolve(makeNetworkError(this.terminated.reason))\n    }\n\n    // 10. Let pullAlgorithm be an action that resumes the ongoing fetch\n    // if it is suspended.\n    let pullAlgorithm\n\n    // 11. Let cancelAlgorithm be an action that terminates the ongoing\n    // fetch with the aborted flag set.\n    const cancelAlgorithm = () => {\n      context.terminate({ aborted: true })\n    }\n\n    // 12. Let highWaterMark be a non-negative, non-NaN number, chosen by\n    // the user agent.\n    const highWaterMark = 64 * 1024 // Same as nodejs fs streams.\n\n    // 13. Let sizeAlgorithm be an algorithm that accepts a chunk object\n    // and returns a non-negative, non-NaN, non-infinite number, chosen by the user agent.\n    // TODO\n\n    // 14. Let stream be a new ReadableStream.\n    // 15. Set up stream with pullAlgorithm set to pullAlgorithm,\n    // cancelAlgorithm set to cancelAlgorithm, highWaterMark set to\n    // highWaterMark, and sizeAlgorithm set to sizeAlgorithm.\n    if (!ReadableStream) {\n      ReadableStream = require('stream/web').ReadableStream\n    }\n\n    let pullResolve\n\n    const stream = new ReadableStream(\n      {\n        async start (controller) {\n          context.controller = controller\n        },\n        async pull (controller) {\n          if (!pullAlgorithm) {\n            await new Promise((resolve) => {\n              pullResolve = resolve\n            })\n          }\n          await pullAlgorithm(controller)\n        },\n        async cancel (reason) {\n          await cancelAlgorithm(reason)\n        }\n      },\n      { highWaterMark }\n    )\n\n    // 16. Run these steps, but abort when the ongoing fetch is terminated:\n    // TODO\n\n    // 17. If aborted, then:\n    // TODO: How can this happen? The steps above are not async?\n\n    // 18. Run these steps in parallel:\n    //    1. Run these steps, but abort when the ongoing fetch is terminated:\n    //        1. While true:\n    //            1. If one or more bytes have been transmitted from response’s\n    //            message body, then:\n    //            NOTE: See onHeaders\n    //            2. Otherwise, if the bytes transmission for response’s message\n    //            body is done normally and stream is readable, then close stream,\n    //            finalize response for fetchParams and response, and abort these\n    //            in-parallel steps.\n    //            NOTE: See onHeaders\n\n    //    2. If aborted, then:\n    function onResponseAborted () {\n      // 1. Let aborted be the termination’s aborted flag.\n      const aborted = this.terminated.aborted\n\n      // 2. If aborted is set, then:\n      if (aborted) {\n        // 1. Set response’s aborted flag.\n        response.aborted = true\n\n        // 2. If stream is readable, error stream with an \"AbortError\" DOMException.\n        if (isReadable(stream)) {\n          this.controller.error(new AbortError())\n        }\n      } else {\n        // 3. Otherwise, if stream is readable, error stream with a TypeError.\n        if (isReadable(stream)) {\n          this.controller.error(new TypeError('terminated'))\n        }\n      }\n\n      // 4. If connection uses HTTP/2, then transmit an RST_STREAM frame.\n      // 5. Otherwise, the user agent should close connection unless it would be bad for performance to do so.\n      this.connection.destroy()\n    }\n\n    // 19. Return response.\n    // NOTE: See onHeaders\n\n    // Implementation\n    const url = requestCurrentURL(request)\n    context.dispatcher.dispatch(\n      {\n        path: url.pathname + url.search,\n        origin: url.origin,\n        method: request.method,\n        body: context.dispatcher[kIsMockActive] ? request.body && request.body.source : body,\n        headers: request.headersList,\n        maxRedirections: 0\n      },\n      {\n        decoder: null,\n        abort: null,\n        context,\n\n        onConnect (abort) {\n          // TODO (fix): Do we need connection here?\n          const { connection } = this.context\n\n          if (connection.destroyed) {\n            abort(new AbortError())\n          } else {\n            this.abort = connection.abort = abort\n          }\n        },\n\n        onHeaders (status, headersList, resume, statusText) {\n          if (status < 200) {\n            return\n          }\n\n          const headers = new Headers()\n          for (let n = 0; n < headersList.length; n += 2) {\n            headers.append(\n              headersList[n + 0].toString(),\n              headersList[n + 1].toString()\n            )\n          }\n\n          response = makeResponse({\n            status,\n            statusText,\n            headersList: headers[kHeadersList],\n            body: { stream }\n          })\n\n          this.context.on('terminated', onResponseAborted)\n\n          const codings =\n            headers\n              .get('content-encoding')\n              ?.toLowerCase()\n              .split(',')\n              .map((x) => x.trim()) ?? []\n\n          const decoders = []\n\n          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\n          for (const coding of codings) {\n            if (/(x-)?gzip/.test(coding)) {\n              decoders.push(zlib.createGunzip())\n            } else if (/(x-)?deflate/.test(coding)) {\n              decoders.push(zlib.createInflate())\n            } else if (coding === 'br') {\n              decoders.push(zlib.createBrotliDecompress())\n            } else {\n              decoders.length = 0\n              break\n            }\n          }\n\n          if (decoders.length > 1) {\n            pipeline(...decoders, () => {})\n          } else if (decoders.length === 0) {\n            // TODO (perf): Avoid intermediate.\n            decoders.push(new PassThrough())\n          }\n\n          this.decoder = decoders[0].on('drain', resume)\n\n          const iterator = decoders[decoders.length - 1][Symbol.asyncIterator]()\n\n          pullAlgorithm = async (controller) => {\n            // 4. Set bytes to the result of handling content codings given\n            // codings and bytes.\n            let bytes\n            try {\n              const { done, value } = await iterator.next()\n              bytes = done ? undefined : value\n            } catch (err) {\n              if (this.decoder.writableEnded && !timingInfo.encodedBodySize) {\n                // zlib doesn't like empty streams.\n                bytes = undefined\n              } else {\n                bytes = err\n              }\n            }\n\n            if (bytes === undefined) {\n              // 2. Otherwise, if the bytes transmission for response’s message\n              // body is done normally and stream is readable, then close\n              // stream, finalize response for fetchParams and response, and\n              // abort these in-parallel steps.\n              finalizeResponse(fetchParams, response)\n\n              controller.close()\n\n              return\n            }\n\n            // 5. Increase timingInfo’s decoded body size by bytes’s length.\n            timingInfo.decodedBodySize += bytes?.byteLength ?? 0\n\n            // 6. If bytes is failure, then terminate the ongoing fetch.\n            if (bytes instanceof Error) {\n              this.context.terminate({ reason: bytes })\n              return\n            }\n\n            // 7. Enqueue a Uint8Array wrapping an ArrayBuffer containing bytes\n            // into stream.\n            controller.enqueue(new Uint8Array(bytes))\n\n            // 8. If stream is errored, then terminate the ongoing fetch.\n            if (isErrored(stream)) {\n              this.context.terminate()\n              return\n            }\n\n            // 9. If stream doesn’t need more data ask the user agent to suspend\n            // the ongoing fetch.\n            return controller.desiredSize > 0\n          }\n\n          if (pullResolve) {\n            pullResolve()\n            pullResolve = null\n          }\n\n          resolve(response)\n\n          return true\n        },\n\n        onData (chunk) {\n          if (this.context.dump) {\n            return\n          }\n\n          //  1. If one or more bytes have been transmitted from response’s\n          //  message body, then:\n\n          // 1. Let bytes be the transmitted bytes.\n          const bytes = chunk\n\n          // 2. Let codings be the result of extracting header list values\n          // given `Content-Encoding` and response’s header list.\n          // See pullAlgorithm.\n\n          // 3. Increase timingInfo’s encoded body size by bytes’s length.\n          timingInfo.encodedBodySize += bytes.byteLength\n\n          // 4. See pullAlgorithm...\n\n          return this.decoder.write(bytes)\n        },\n\n        onComplete () {\n          this.decoder.end()\n        },\n\n        onError (error) {\n          this.decoder?.destroy(error)\n\n          this.context.terminate({ reason: error })\n\n          if (!response) {\n            resolve(makeNetworkError(error))\n          }\n        }\n      }\n    )\n  })\n}\n\nmodule.exports = fetch\n","/* globals AbortController */\n\n'use strict'\n\nconst { extractBody, mixinBody, cloneBody } = require('./body')\nconst { Headers, fill: fillHeaders, HeadersList } = require('./headers')\nconst util = require('../core/util')\nconst {\n  isValidHTTPToken,\n  EnvironmentSettingsObject,\n  toUSVString\n} = require('./util')\nconst {\n  forbiddenMethods,\n  corsSafeListedMethods,\n  referrerPolicy,\n  requestRedirect,\n  requestMode,\n  requestCredentials,\n  requestCache\n} = require('./constants')\nconst { kEnumerableProperty } = util\nconst { kHeaders, kSignal, kState, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\nlet TransformStream\n\nconst kInit = Symbol('init')\n\nconst requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {\n  signal.removeEventListener('abort', abort)\n})\n\n// https://fetch.spec.whatwg.org/#request-class\nclass Request {\n  // https://fetch.spec.whatwg.org/#dom-request\n  constructor (...args) {\n    if (args[0] === kInit) {\n      return\n    }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to construct 'Request': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n    const input = args[0] instanceof Request ? args[0] : toUSVString(args[0])\n    const init = args.length >= 1 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. Let request be null.\n    let request = null\n\n    // 2. Let fallbackMode be null.\n    let fallbackMode = null\n\n    // 3. Let baseURL be this’s relevant settings object’s API base URL.\n    const baseUrl = this[kRealm].settingsObject.baseUrl\n\n    // 4. Let signal be null.\n    let signal = null\n\n    // 5. If input is a string, then:\n    if (typeof input === 'string') {\n      // 1. Let parsedURL be the result of parsing input with baseURL.\n      // 2. If parsedURL is failure, then throw a TypeError.\n      let parsedURL\n      try {\n        parsedURL = new URL(input, baseUrl)\n      } catch (err) {\n        const error = new TypeError('Failed to parse URL from ' + input)\n        error.cause = err\n        throw error\n      }\n\n      // 3. If parsedURL includes credentials, then throw a TypeError.\n      if (parsedURL.username || parsedURL.password) {\n        throw new TypeError(\n          'Request cannot be constructed from a URL that includes credentials: ' +\n            input\n        )\n      }\n\n      // 4. Set request to a new request whose URL is parsedURL.\n      request = makeRequest({ urlList: [parsedURL] })\n\n      // 5. Set fallbackMode to \"cors\".\n      fallbackMode = 'cors'\n    } else {\n      // 6. Otherwise:\n\n      // 7. Assert: input is a Request object.\n      assert(input instanceof Request)\n\n      // 8. Set request to input’s request.\n      request = input[kState]\n\n      // 9. Set signal to input’s signal.\n      signal = input[kSignal]\n    }\n\n    // 7. Let origin be this’s relevant settings object’s origin.\n    const origin = this[kRealm].settingsObject.origin\n\n    // 8. Let window be \"client\".\n    let window = 'client'\n\n    // 9. If request’s window is an environment settings object and its origin\n    // is same origin with origin, then set window to request’s window.\n    if (\n      request.window instanceof EnvironmentSettingsObject &&\n      sameOrigin(request.window, origin)\n    ) {\n      window = request.window\n    }\n\n    // 10. If init[\"window\"] exists and is non-null, then throw a TypeError.\n    if ('window' in init && window != null) {\n      throw new TypeError(`'window' option '${window}' must be null`)\n    }\n\n    // 11. If init[\"window\"] exists, then set window to \"no-window\".\n    if ('window' in init) {\n      window = 'no-window'\n    }\n\n    // 12. Set request to a new request with the following properties:\n    request = makeRequest({\n      // URL request’s URL.\n      // undici implementation note: this is set as the first item in request's urlList in makeRequest\n      // method request’s method.\n      method: request.method,\n      // header list A copy of request’s header list.\n      // undici implementation note: headersList is cloned in makeRequest\n      headersList: request.headersList,\n      // unsafe-request flag Set.\n      unsafeRequest: request.unsafeRequest,\n      // client This’s relevant settings object.\n      client: request.client,\n      // window window.\n      window,\n      // priority request’s priority.\n      priority: request.priority,\n      // origin request’s origin. The propagation of the origin is only significant for navigation requests\n      // being handled by a service worker. In this scenario a request can have an origin that is different\n      // from the current client.\n      origin: request.origin,\n      // referrer request’s referrer.\n      referrer: request.referrer,\n      // referrer policy request’s referrer policy.\n      referrerPolicy: request.referrerPolicy,\n      // mode request’s mode.\n      mode: request.mode,\n      // credentials mode request’s credentials mode.\n      credentials: request.credentials,\n      // cache mode request’s cache mode.\n      cache: request.cache,\n      // redirect mode request’s redirect mode.\n      redirect: request.redirect,\n      // integrity metadata request’s integrity metadata.\n      integrity: request.integrity,\n      // keepalive request’s keepalive.\n      keepalive: request.keepalive,\n      // reload-navigation flag request’s reload-navigation flag.\n      reloadNavigation: request.reloadNavigation,\n      // history-navigation flag request’s history-navigation flag.\n      historyNavigation: request.historyNavigation,\n      // URL list A clone of request’s URL list.\n      // undici implementation note: urlList is cloned in makeRequest\n      urlList: request.urlList\n    })\n\n    // 13. If init is not empty, then:\n    if (Object.keys(init).length > 0) {\n      // 1. If request’s mode is \"navigate\", then set it to \"same-origin\".\n      if (request.mode === 'navigate') {\n        request.mode = 'same-origin'\n      }\n\n      // 2. Unset request’s reload-navigation flag.\n      request.reloadNavigation = false\n\n      // 3. Unset request’s history-navigation flag.\n      request.historyNavigation = false\n\n      // 4. Set request’s origin to \"client\".\n      request.origin = 'client'\n\n      // 5. Set request’s referrer to \"client\"\n      request.referrer = 'client'\n\n      // 6. Set request’s referrer policy to the empty string.\n      request.referrerPolicy = ''\n\n      // 7. Set request’s URL to request’s current URL.\n      request.url = request.urlList[request.urlList.length - 1]\n\n      // 8. Set request’s URL list to « request’s URL ».\n      request.urlList = [request.url]\n    }\n\n    // 14. If init[\"referrer\"] exists, then:\n    if ('referrer' in init) {\n      // 1. Let referrer be init[\"referrer\"].\n      const referrer = init.referrer\n\n      // 2. If referrer is the empty string, then set request’s referrer to \"no-referrer\".\n      if (referrer === '') {\n        request.referrer = 'no-referrer'\n      } else {\n        // 1. Let parsedReferrer be the result of parsing referrer with\n        // baseURL.\n        // 2. If parsedReferrer is failure, then throw a TypeError.\n        let parsedReferrer\n        try {\n          parsedReferrer = new URL(referrer, baseUrl)\n        } catch (err) {\n          const error = new TypeError(\n            `Referrer \"${referrer}\" is not a valid URL.`\n          )\n          error.cause = err\n          throw error\n        }\n\n        // 3. If one of the following is true\n        // parsedReferrer’s cannot-be-a-base-URL is true, scheme is \"about\",\n        // and path contains a single string \"client\"\n        // parsedReferrer’s origin is not same origin with origin\n        // then set request’s referrer to \"client\".\n        // TODO\n\n        // 4. Otherwise, set request’s referrer to parsedReferrer.\n        request.referrer = parsedReferrer\n      }\n    }\n\n    // 15. If init[\"referrerPolicy\"] exists, then set request’s referrer policy\n    // to it.\n    if ('referrerPolicy' in init) {\n      request.referrerPolicy = init.referrerPolicy\n      if (!referrerPolicy.includes(request.referrerPolicy)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`\n        )\n      }\n    }\n\n    // 16. Let mode be init[\"mode\"] if it exists, and fallbackMode otherwise.\n    let mode\n    if ('mode' in init) {\n      mode = init.mode\n      if (!requestMode.includes(mode)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.mode}' is not a valid enum value of type RequestMode.`\n        )\n      }\n    } else {\n      mode = fallbackMode\n    }\n\n    // 17. If mode is \"navigate\", then throw a TypeError.\n    if (mode === 'navigate') {\n      throw new TypeError()\n    }\n\n    // 18. If mode is non-null, set request’s mode to mode.\n    if (mode != null) {\n      request.mode = mode\n    }\n\n    // 19. If init[\"credentials\"] exists, then set request’s credentials mode\n    // to it.\n    if ('credentials' in init) {\n      request.credentials = init.credentials\n      if (!requestCredentials.includes(request.credentials)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.credentials}' is not a valid enum value of type RequestCredentials.`\n        )\n      }\n    }\n\n    // 18. If init[\"cache\"] exists, then set request’s cache mode to it.\n    if ('cache' in init) {\n      request.cache = init.cache\n      if (!requestCache.includes(request.cache)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.cache}' is not a valid enum value of type RequestCache.`\n        )\n      }\n    }\n\n    // 21. If request’s cache mode is \"only-if-cached\" and request’s mode is\n    // not \"same-origin\", then throw a TypeError.\n    if (request.cache === 'only-if-cached' && request.mode !== 'same-origin') {\n      throw new TypeError(\n        \"'only-if-cached' can be set only with 'same-origin' mode\"\n      )\n    }\n\n    // 22. If init[\"redirect\"] exists, then set request’s redirect mode to it.\n    if ('redirect' in init) {\n      request.redirect = init.redirect\n      if (!requestRedirect.includes(request.redirect)) {\n        throw new TypeError(\n          `Failed to construct 'Request': The provided value '${request.redirect}' is not a valid enum value of type RequestRedirect.`\n        )\n      }\n    }\n\n    // 23. If init[\"integrity\"] exists, then set request’s integrity metadata to it.\n    if ('integrity' in init && init.integrity != null) {\n      request.integrity = String(init.integrity)\n    }\n\n    // 24. If init[\"keepalive\"] exists, then set request’s keepalive to it.\n    if ('keepalive' in init) {\n      request.keepalive = Boolean(init.keepalive)\n    }\n\n    // 25. If init[\"method\"] exists, then:\n    if ('method' in init) {\n      // 1. Let method be init[\"method\"].\n      let method = init.method\n\n      // 2. If method is not a method or method is a forbidden method, then\n      // throw a TypeError.\n      if (!isValidHTTPToken(init.method)) {\n        throw TypeError(`'${init.method}' is not a valid HTTP method.`)\n      }\n\n      if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {\n        throw TypeError(`'${init.method}' HTTP method is unsupported.`)\n      }\n\n      // 3. Normalize method.\n      // https://fetch.spec.whatwg.org/#concept-method-normalize\n      method = init.method.toUpperCase()\n\n      // 4. Set request’s method to method.\n      request.method = method\n    }\n\n    // 26. If init[\"signal\"] exists, then set signal to it.\n    if ('signal' in init) {\n      signal = init.signal\n    }\n\n    // 27. Set this’s request to request.\n    this[kState] = request\n\n    // 28. Set this’s signal to a new AbortSignal object with this’s relevant\n    // Realm.\n    const ac = new AbortController()\n    this[kSignal] = ac.signal\n    this[kSignal][kRealm] = this[kRealm]\n\n    // 29. If signal is not null, then make this’s signal follow signal.\n    if (signal != null) {\n      if (\n        !signal ||\n        typeof signal.aborted !== 'boolean' ||\n        typeof signal.addEventListener !== 'function'\n      ) {\n        throw new TypeError(\n          \"Failed to construct 'Request': member signal is not of type AbortSignal.\"\n        )\n      }\n\n      if (signal.aborted) {\n        ac.abort()\n      } else {\n        const abort = () => ac.abort()\n        signal.addEventListener('abort', abort, { once: true })\n        requestFinalizer.register(this, { signal, abort })\n      }\n    }\n\n    // 30. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is request’s header list and guard is\n    // \"request\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'request'\n    this[kHeaders][kHeadersList] = request.headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 31. If this’s request’s mode is \"no-cors\", then:\n    if (mode === 'no-cors') {\n      // 1. If this’s request’s method is not a CORS-safelisted method,\n      // then throw a TypeError.\n      if (!corsSafeListedMethods.includes(request.method)) {\n        throw new TypeError(\n          `'${request.method} is unsupported in no-cors mode.`\n        )\n      }\n\n      // 2. Set this’s headers’s guard to \"request-no-cors\".\n      this[kHeaders][kGuard] = 'request-no-cors'\n    }\n\n    // 32. If init is not empty, then:\n    if (Object.keys(init).length !== 0) {\n      // 1. Let headers be a copy of this’s headers and its associated header\n      // list.\n      let headers = new Headers(this.headers)\n\n      // 2. If init[\"headers\"] exists, then set headers to init[\"headers\"].\n      if ('headers' in init) {\n        headers = init.headers\n      }\n\n      // 3. Empty this’s headers’s header list.\n      this[kState].headersList = new HeadersList()\n      this[kHeaders][kHeadersList] = this[kState].headersList\n\n      // 4. If headers is a Headers object, then for each header in its header\n      // list, append header’s name/header’s value to this’s headers.\n      if (headers instanceof Headers) {\n        this[kState].headersList.push(...headers[kHeadersList])\n      } else {\n        // 5. Otherwise, fill this’s headers with headers.\n        fillHeaders(this[kState].headersList, headers)\n      }\n    }\n\n    // 33. Let inputBody be input’s request’s body if input is a Request\n    // object; otherwise null.\n    const inputBody = input instanceof Request ? input[kState].body : null\n\n    // 34. If either init[\"body\"] exists and is non-null or inputBody is\n    // non-null, and request’s method is `GET` or `HEAD`, then throw a\n    // TypeError.\n    if (\n      (('body' in init && init.body != null) || inputBody != null) &&\n      (request.method === 'GET' || request.method === 'HEAD')\n    ) {\n      throw new TypeError('Request with GET/HEAD method cannot have body.')\n    }\n\n    // 35. Let initBody be null.\n    let initBody = null\n\n    // 36. If init[\"body\"] exists and is non-null, then:\n    if ('body' in init && init.body != null) {\n      // 1. Let Content-Type be null.\n      // 2. Set initBody and Content-Type to the result of extracting\n      // init[\"body\"], with keepalive set to request’s keepalive.\n      const [extractedBody, contentType] = extractBody(\n        init.body,\n        request.keepalive\n      )\n      initBody = extractedBody\n\n      // 3, If Content-Type is non-null and this’s headers’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type to\n      // this’s headers.\n      if (contentType && !this[kHeaders].has('content-type')) {\n        this[kHeaders].append('content-type', contentType)\n      }\n    }\n\n    // 37. Let inputOrInitBody be initBody if it is non-null; otherwise\n    // inputBody.\n    const inputOrInitBody = initBody ?? inputBody\n\n    // 38. If inputOrInitBody is non-null and inputOrInitBody’s source is\n    // null, then:\n    if (inputOrInitBody != null && inputOrInitBody.source == null) {\n      // 1. If this’s request’s mode is neither \"same-origin\" nor \"cors\",\n      // then throw a TypeError.\n      if (request.mode !== 'same-origin' && request.mode !== 'cors') {\n        throw new TypeError(\n          'If request is made from ReadableStream, mode should be \"same-origin\" or \"cors\"'\n        )\n      }\n\n      // 2. Set this’s request’s use-CORS-preflight flag.\n      request.useCORSPreflightFlag = true\n    }\n\n    // 39. Let finalBody be inputOrInitBody.\n    let finalBody = inputOrInitBody\n\n    // 40. If initBody is null and inputBody is non-null, then:\n    if (initBody == null && inputBody != null) {\n      // 1. If input is unusable, then throw a TypeError.\n      if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {\n        throw new TypeError(\n          'Cannot construct a Request with a Request object that has already been used.'\n        )\n      }\n\n      // 2. Set finalBody to the result of creating a proxy for inputBody.\n      if (!TransformStream) {\n        TransformStream = require('stream/web').TransformStream\n      }\n\n      // https://streams.spec.whatwg.org/#readablestream-create-a-proxy\n      const identityTransform = new TransformStream()\n      inputBody.stream.pipeThrough(identityTransform)\n      finalBody = {\n        source: inputBody.source,\n        length: inputBody.length,\n        stream: identityTransform.readable\n      }\n    }\n\n    // 41. Set this’s request’s body to finalBody.\n    this[kState].body = finalBody\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns request’s HTTP method, which is \"GET\" by default.\n  get method () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The method getter steps are to return this’s request’s method.\n    return this[kState].method\n  }\n\n  // Returns the URL of request as a string.\n  get url () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return this’s request’s URL, serialized.\n    return this[kState].url.toString()\n  }\n\n  // Returns a Headers object consisting of the headers associated with request.\n  // Note that headers added in the network layer by the user agent will not\n  // be accounted for in this object, e.g., the \"Host\" header.\n  get headers () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns the kind of resource requested by request, e.g., \"document\"\n  // or \"script\".\n  get destination () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The destination getter are to return this’s request’s destination.\n    return this[kState].destination\n  }\n\n  // Returns the referrer of request. Its value can be a same-origin URL if\n  // explicitly set in init, the empty string to indicate no referrer, and\n  // \"about:client\" when defaulting to the global’s default. This is used\n  // during fetching to determine the value of the `Referer` header of the\n  // request being made.\n  get referrer () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this’s request’s referrer is \"no-referrer\", then return the\n    // empty string.\n    if (this[kState].referrer === 'no-referrer') {\n      return ''\n    }\n\n    // 2. If this’s request’s referrer is \"client\", then return\n    // \"about:client\".\n    if (this[kState].referrer === 'client') {\n      return 'about:client'\n    }\n\n    // Return this’s request’s referrer, serialized.\n    return this[kState].referrer.toString()\n  }\n\n  // Returns the referrer policy associated with request.\n  // This is used during fetching to compute the value of the request’s\n  // referrer.\n  get referrerPolicy () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The referrerPolicy getter steps are to return this’s request’s referrer policy.\n    return this[kState].referrerPolicy\n  }\n\n  // Returns the mode associated with request, which is a string indicating\n  // whether the request will use CORS, or will be restricted to same-origin\n  // URLs.\n  get mode () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The mode getter steps are to return this’s request’s mode.\n    return this[kState].mode\n  }\n\n  // Returns the credentials mode associated with request,\n  // which is a string indicating whether credentials will be sent with the\n  // request always, never, or only when sent to a same-origin URL.\n  get credentials () {\n    // The credentials getter steps are to return this’s request’s credentials mode.\n    return this[kState].credentials\n  }\n\n  // Returns the cache mode associated with request,\n  // which is a string indicating how the request will\n  // interact with the browser’s cache when fetching.\n  get cache () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The cache getter steps are to return this’s request’s cache mode.\n    return this[kState].cache\n  }\n\n  // Returns the redirect mode associated with request,\n  // which is a string indicating how redirects for the\n  // request will be handled during fetching. A request\n  // will follow redirects by default.\n  get redirect () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirect getter steps are to return this’s request’s redirect mode.\n    return this[kState].redirect\n  }\n\n  // Returns request’s subresource integrity metadata, which is a\n  // cryptographic hash of the resource being fetched. Its value\n  // consists of multiple hashes separated by whitespace. [SRI]\n  get integrity () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The integrity getter steps are to return this’s request’s integrity\n    // metadata.\n    return this[kState].integrity\n  }\n\n  // Returns a boolean indicating whether or not request can outlive the\n  // global in which it was created.\n  get keepalive () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The keepalive getter steps are to return this’s request’s keepalive.\n    return this[kState].keepalive\n  }\n\n  // Returns a boolean indicating whether or not request is for a reload\n  // navigation.\n  get isReloadNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isReloadNavigation getter steps are to return true if this’s\n    // request’s reload-navigation flag is set; otherwise false.\n    return this[kState].reloadNavigation\n  }\n\n  // Returns a boolean indicating whether or not request is for a history\n  // navigation (a.k.a. back-foward navigation).\n  get isHistoryNavigation () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The isHistoryNavigation getter steps are to return true if this’s request’s\n    // history-navigation flag is set; otherwise false.\n    return this[kState].historyNavigation\n  }\n\n  // Returns the signal associated with request, which is an AbortSignal\n  // object indicating whether or not request has been aborted, and its\n  // abort event handler.\n  get signal () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The signal getter steps are to return this’s signal.\n    return this[kSignal]\n  }\n\n  // Returns a clone of request.\n  clone () {\n    if (!(this instanceof Request)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError('unusable')\n    }\n\n    // 2. Let clonedRequest be the result of cloning this’s request.\n    const clonedRequest = cloneRequest(this[kState])\n\n    // 3. Let clonedRequestObject be the result of creating a Request object,\n    // given clonedRequest, this’s headers’s guard, and this’s relevant Realm.\n    const clonedRequestObject = new Request(kInit)\n    clonedRequestObject[kState] = clonedRequest\n    clonedRequestObject[kRealm] = this[kRealm]\n    clonedRequestObject[kHeaders] = new Headers()\n    clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList\n    clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    // 4. Make clonedRequestObject’s signal follow this’s signal.\n    const ac = new AbortController()\n    if (this.signal.aborted) {\n      ac.abort()\n    } else {\n      this.signal.addEventListener(\n        'abort',\n        function () {\n          ac.abort()\n        },\n        { once: true }\n      )\n    }\n    clonedRequestObject[kSignal] = ac.signal\n\n    // 4. Return clonedRequestObject.\n    return clonedRequestObject\n  }\n}\n\nmixinBody(Request.prototype)\n\nfunction makeRequest (init) {\n  // https://fetch.spec.whatwg.org/#requests\n  const request = {\n    method: 'GET',\n    localURLsOnly: false,\n    unsafeRequest: false,\n    body: null,\n    client: null,\n    reservedClient: null,\n    replacesClientId: '',\n    window: 'client',\n    keepalive: false,\n    serviceWorkers: 'all',\n    initiator: '',\n    destination: '',\n    priority: null,\n    origin: 'client',\n    policyContainer: 'client',\n    referrer: 'client',\n    referrerPolicy: '',\n    mode: 'no-cors',\n    useCORSPreflightFlag: false,\n    credentials: 'same-origin',\n    useCredentials: false,\n    cache: 'default',\n    redirect: 'follow',\n    integrity: '',\n    cryptoGraphicsNonceMetadata: '',\n    parserMetadata: '',\n    reloadNavigation: false,\n    historyNavigation: false,\n    userActivation: false,\n    taintedOrigin: false,\n    redirectCount: 0,\n    responseTainting: 'basic',\n    preventNoCacheCacheControlHeaderModification: false,\n    done: false,\n    timingAllowFailed: false,\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList.map((url) => new URL(url))] : []\n  }\n  request.url = request.urlList[0]\n  return request\n}\n\n// https://fetch.spec.whatwg.org/#concept-request-clone\nfunction cloneRequest (request) {\n  // To clone a request request, run these steps:\n\n  // 1. Let newRequest be a copy of request, except for its body.\n  const newRequest = makeRequest({ ...request, body: null })\n\n  // 2. If request’s body is non-null, set newRequest’s body to the\n  // result of cloning request’s body.\n  if (request.body != null) {\n    newRequest.body = cloneBody(request.body)\n  }\n\n  // 3. Return newRequest.\n  return newRequest\n}\n\nObject.defineProperties(Request.prototype, {\n  method: kEnumerableProperty,\n  url: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  redirect: kEnumerableProperty,\n  clone: kEnumerableProperty,\n  signal: kEnumerableProperty\n})\n\nmodule.exports = { Request, makeRequest }\n","'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst { responseURL, isValidReasonPhrase, toUSVString } = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenResponseHeaderNames\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (...args) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const status = args.length >= 2 ? args[1] : 302\n    const url = toUSVString(args[0])\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url)\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.push('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (...args) {\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n\n    const body = args.length >= 1 ? args[0] : null\n    const init = args.length >= 2 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError()\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(\n          `Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`\n        )\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText')\n      }\n    }\n\n    // 3. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 5. Set this’s response’s status to init[\"status\"].\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status\n    }\n\n    // 6. Set this’s response’s status message to init[\"statusText\"].\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText)\n    }\n\n    // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers)\n    }\n\n    // 8. If body is non-null, then:\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body')\n      }\n\n      // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n      const [extractedBody, contentType] = extractBody(body)\n      this[kState].body = extractedBody\n\n      // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType)\n      }\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError()\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\nmixinBody(Response.prototype)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error:\n      reason instanceof Error\n        ? reason\n        : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    const headers = []\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenResponseHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1])\n      }\n    }\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // TODO: This is not correct...\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'cors'\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\nmodule.exports = { makeNetworkError, makeResponse, filterResponse, Response }\n","'use strict'\n\nmodule.exports = {\n  kUrl: Symbol('url'),\n  kHeaders: Symbol('headers'),\n  kSignal: Symbol('signal'),\n  kState: Symbol('state'),\n  kGuard: Symbol('guard'),\n  kRealm: Symbol('realm')\n}\n","'use strict'\n\nconst { redirectStatus } = require('./constants')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\n\nlet File\n\n// https://fetch.spec.whatwg.org/#block-bad-port\nconst badPorts = [\n  '1', '7', '9', '11', '13', '15', '17', '19', '20', '21', '22', '23', '25', '37', '42', '43', '53', '69', '77', '79',\n  '87', '95', '101', '102', '103', '104', '109', '110', '111', '113', '115', '117', '119', '123', '135', '137',\n  '139', '143', '161', '179', '389', '427', '465', '512', '513', '514', '515', '526', '530', '531', '532',\n  '540', '548', '554', '556', '563', '587', '601', '636', '989', '990', '993', '995', '1719', '1720', '1723',\n  '2049', '3659', '4045', '5060', '5061', '6000', '6566', '6665', '6666', '6667', '6668', '6669', '6697',\n  '10080'\n]\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isFileLike (object) {\n  if (!File) {\n    File = require('./file').File\n  }\n  return object instanceof File || (\n    object &&\n    (typeof object.stream === 'function' ||\n     typeof object.arrayBuffer === 'function') &&\n    /^(File)$/.test(object[Symbol.toStringTag])\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n  // TODO:  https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header\n  const policy = ''\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.append('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // TODO\n  return 'no-referrer'\n}\n\nfunction matchRequestIntegrity (request, bytes) {\n  return false\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes, \n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\n// https://fetch.spec.whatwg.org/#corb-check\nfunction CORBCheck (request, response) {\n  // TODO\n  return 'allowed'\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nclass ServiceWorkerGlobalScope {} // dummy\nclass Window {} // dummy\nclass EnvironmentSettingsObject {} // dummy\n\nmodule.exports = {\n  ServiceWorkerGlobalScope,\n  Window,\n  EnvironmentSettingsObject,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  matchRequestIntegrity,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isFileLike,\n  isValidReasonPhrase,\n  sameOrigin,\n  CORBCheck\n}\n","'use strict'\n\nconst util = require('../core/util')\nconst { kBodyUsed } = require('../core/symbols')\nconst assert = require('assert')\nconst { InvalidArgumentError } = require('../core/errors')\nconst EE = require('events')\n\nconst redirectableStatusCodes = [300, 301, 302, 303, 307, 308]\n\nconst kBody = Symbol('body')\n\nclass BodyAsyncIterable {\n  constructor (body) {\n    this[kBody] = body\n    this[kBodyUsed] = false\n  }\n\n  async * [Symbol.asyncIterator] () {\n    assert(!this[kBodyUsed], 'disturbed')\n    this[kBodyUsed] = true\n    yield * this[kBody]\n  }\n}\n\nclass RedirectHandler {\n  constructor (dispatcher, maxRedirections, opts, handler) {\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    util.validateHandler(handler, opts.method, opts.upgrade)\n\n    this.dispatcher = dispatcher\n    this.location = null\n    this.abort = null\n    this.opts = { ...opts, maxRedirections: 0 } // opts must be a copy\n    this.maxRedirections = maxRedirections\n    this.handler = handler\n    this.history = []\n\n    if (util.isStream(this.opts.body)) {\n      // TODO (fix): Provide some way for the user to cache the file to e.g. /tmp\n      // so that it can be dispatched again?\n      // TODO (fix): Do we need 100-expect support to provide a way to do this properly?\n      if (util.bodyLength(this.opts.body) === 0) {\n        this.opts.body\n          .on('data', function () {\n            assert(false)\n          })\n      }\n\n      if (typeof this.opts.body.readableDidRead !== 'boolean') {\n        this.opts.body[kBodyUsed] = false\n        EE.prototype.on.call(this.opts.body, 'data', function () {\n          this[kBodyUsed] = true\n        })\n      }\n    } else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {\n      // TODO (fix): We can't access ReadableStream internal state\n      // to determine whether or not it has been disturbed. This is just\n      // a workaround.\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    } else if (\n      this.opts.body &&\n      typeof this.opts.body !== 'string' &&\n      !ArrayBuffer.isView(this.opts.body) &&\n      util.isIterable(this.opts.body)\n    ) {\n      // TODO: Should we allow re-using iterable if !this.opts.idempotent\n      // or through some other flag?\n      this.opts.body = new BodyAsyncIterable(this.opts.body)\n    }\n  }\n\n  onConnect (abort) {\n    this.abort = abort\n    this.handler.onConnect(abort, { history: this.history })\n  }\n\n  onUpgrade (statusCode, headers, socket) {\n    this.handler.onUpgrade(statusCode, headers, socket)\n  }\n\n  onError (error) {\n    this.handler.onError(error)\n  }\n\n  onHeaders (statusCode, headers, resume, statusText) {\n    this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body)\n      ? null\n      : parseLocation(statusCode, headers)\n\n    if (this.opts.origin) {\n      this.history.push(new URL(this.opts.path, this.opts.origin))\n    }\n\n    if (!this.location) {\n      return this.handler.onHeaders(statusCode, headers, resume, statusText)\n    }\n\n    const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin))\n    const path = search ? `${pathname}${search}` : pathname\n\n    // Remove headers referring to the original URL.\n    // By default it is Host only, unless it's a 303 (see below), which removes also all Content-* headers.\n    // https://tools.ietf.org/html/rfc7231#section-6.4\n    this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin)\n    this.opts.path = path\n    this.opts.origin = origin\n    this.opts.maxRedirections = 0\n\n    // https://tools.ietf.org/html/rfc7231#section-6.4.4\n    // In case of HTTP 303, always replace method to be either HEAD or GET\n    if (statusCode === 303 && this.opts.method !== 'HEAD') {\n      this.opts.method = 'GET'\n      this.opts.body = null\n    }\n  }\n\n  onData (chunk) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response bodies.\n\n        Redirection is used to serve the requested resource from another URL, so it is assumes that\n        no body is generated (and thus can be ignored). Even though generating a body is not prohibited.\n\n        For status 301, 302, 303, 307 and 308 (the latter from RFC 7238), the specs mention that the body usually\n        (which means it's optional and not mandated) contain just an hyperlink to the value of\n        the Location response header, so the body can be ignored safely.\n\n        For status 300, which is \"Multiple Choices\", the spec mentions both generating a Location\n        response header AND a response body with the other possible location to follow.\n        Since the spec explicitily chooses not to specify a format for such body and leave it to\n        servers and browsers implementors, we ignore the body as there is no specified way to eventually parse it.\n      */\n    } else {\n      return this.handler.onData(chunk)\n    }\n  }\n\n  onComplete (trailers) {\n    if (this.location) {\n      /*\n        https://tools.ietf.org/html/rfc7231#section-6.4\n\n        TLDR: undici always ignores 3xx response trailers as they are not expected in case of redirections\n        and neither are useful if present.\n\n        See comment on onData method above for more detailed informations.\n      */\n\n      this.location = null\n      this.abort = null\n\n      this.dispatcher.dispatch(this.opts, this)\n    } else {\n      this.handler.onComplete(trailers)\n    }\n  }\n\n  onBodySent (chunk) {\n    if (this.handler.onBodySent) {\n      this.handler.onBodySent(chunk)\n    }\n  }\n}\n\nfunction parseLocation (statusCode, headers) {\n  if (redirectableStatusCodes.indexOf(statusCode) === -1) {\n    return null\n  }\n\n  for (let i = 0; i < headers.length; i += 2) {\n    if (headers[i].toString().toLowerCase() === 'location') {\n      return headers[i + 1]\n    }\n  }\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4.4\nfunction shouldRemoveHeader (header, removeContent, unknownOrigin) {\n  return (\n    (header.length === 4 && header.toString().toLowerCase() === 'host') ||\n    (removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||\n    (unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization')\n  )\n}\n\n// https://tools.ietf.org/html/rfc7231#section-6.4\nfunction cleanRequestHeaders (headers, removeContent, unknownOrigin) {\n  const ret = []\n  if (Array.isArray(headers)) {\n    for (let i = 0; i < headers.length; i += 2) {\n      if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {\n        ret.push(headers[i], headers[i + 1])\n      }\n    }\n  } else if (headers && typeof headers === 'object') {\n    for (const key of Object.keys(headers)) {\n      if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {\n        ret.push(key, headers[key])\n      }\n    }\n  } else {\n    assert(headers == null, 'headers must be an object or an array')\n  }\n  return ret\n}\n\nmodule.exports = RedirectHandler\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;\nconst utils_1 = require(\"./utils\");\n// C headers\nvar ERROR;\n(function (ERROR) {\n    ERROR[ERROR[\"OK\"] = 0] = \"OK\";\n    ERROR[ERROR[\"INTERNAL\"] = 1] = \"INTERNAL\";\n    ERROR[ERROR[\"STRICT\"] = 2] = \"STRICT\";\n    ERROR[ERROR[\"LF_EXPECTED\"] = 3] = \"LF_EXPECTED\";\n    ERROR[ERROR[\"UNEXPECTED_CONTENT_LENGTH\"] = 4] = \"UNEXPECTED_CONTENT_LENGTH\";\n    ERROR[ERROR[\"CLOSED_CONNECTION\"] = 5] = \"CLOSED_CONNECTION\";\n    ERROR[ERROR[\"INVALID_METHOD\"] = 6] = \"INVALID_METHOD\";\n    ERROR[ERROR[\"INVALID_URL\"] = 7] = \"INVALID_URL\";\n    ERROR[ERROR[\"INVALID_CONSTANT\"] = 8] = \"INVALID_CONSTANT\";\n    ERROR[ERROR[\"INVALID_VERSION\"] = 9] = \"INVALID_VERSION\";\n    ERROR[ERROR[\"INVALID_HEADER_TOKEN\"] = 10] = \"INVALID_HEADER_TOKEN\";\n    ERROR[ERROR[\"INVALID_CONTENT_LENGTH\"] = 11] = \"INVALID_CONTENT_LENGTH\";\n    ERROR[ERROR[\"INVALID_CHUNK_SIZE\"] = 12] = \"INVALID_CHUNK_SIZE\";\n    ERROR[ERROR[\"INVALID_STATUS\"] = 13] = \"INVALID_STATUS\";\n    ERROR[ERROR[\"INVALID_EOF_STATE\"] = 14] = \"INVALID_EOF_STATE\";\n    ERROR[ERROR[\"INVALID_TRANSFER_ENCODING\"] = 15] = \"INVALID_TRANSFER_ENCODING\";\n    ERROR[ERROR[\"CB_MESSAGE_BEGIN\"] = 16] = \"CB_MESSAGE_BEGIN\";\n    ERROR[ERROR[\"CB_HEADERS_COMPLETE\"] = 17] = \"CB_HEADERS_COMPLETE\";\n    ERROR[ERROR[\"CB_MESSAGE_COMPLETE\"] = 18] = \"CB_MESSAGE_COMPLETE\";\n    ERROR[ERROR[\"CB_CHUNK_HEADER\"] = 19] = \"CB_CHUNK_HEADER\";\n    ERROR[ERROR[\"CB_CHUNK_COMPLETE\"] = 20] = \"CB_CHUNK_COMPLETE\";\n    ERROR[ERROR[\"PAUSED\"] = 21] = \"PAUSED\";\n    ERROR[ERROR[\"PAUSED_UPGRADE\"] = 22] = \"PAUSED_UPGRADE\";\n    ERROR[ERROR[\"PAUSED_H2_UPGRADE\"] = 23] = \"PAUSED_H2_UPGRADE\";\n    ERROR[ERROR[\"USER\"] = 24] = \"USER\";\n})(ERROR = exports.ERROR || (exports.ERROR = {}));\nvar TYPE;\n(function (TYPE) {\n    TYPE[TYPE[\"BOTH\"] = 0] = \"BOTH\";\n    TYPE[TYPE[\"REQUEST\"] = 1] = \"REQUEST\";\n    TYPE[TYPE[\"RESPONSE\"] = 2] = \"RESPONSE\";\n})(TYPE = exports.TYPE || (exports.TYPE = {}));\nvar FLAGS;\n(function (FLAGS) {\n    FLAGS[FLAGS[\"CONNECTION_KEEP_ALIVE\"] = 1] = \"CONNECTION_KEEP_ALIVE\";\n    FLAGS[FLAGS[\"CONNECTION_CLOSE\"] = 2] = \"CONNECTION_CLOSE\";\n    FLAGS[FLAGS[\"CONNECTION_UPGRADE\"] = 4] = \"CONNECTION_UPGRADE\";\n    FLAGS[FLAGS[\"CHUNKED\"] = 8] = \"CHUNKED\";\n    FLAGS[FLAGS[\"UPGRADE\"] = 16] = \"UPGRADE\";\n    FLAGS[FLAGS[\"CONTENT_LENGTH\"] = 32] = \"CONTENT_LENGTH\";\n    FLAGS[FLAGS[\"SKIPBODY\"] = 64] = \"SKIPBODY\";\n    FLAGS[FLAGS[\"TRAILING\"] = 128] = \"TRAILING\";\n    // 1 << 8 is unused\n    FLAGS[FLAGS[\"TRANSFER_ENCODING\"] = 512] = \"TRANSFER_ENCODING\";\n})(FLAGS = exports.FLAGS || (exports.FLAGS = {}));\nvar LENIENT_FLAGS;\n(function (LENIENT_FLAGS) {\n    LENIENT_FLAGS[LENIENT_FLAGS[\"HEADERS\"] = 1] = \"HEADERS\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"CHUNKED_LENGTH\"] = 2] = \"CHUNKED_LENGTH\";\n    LENIENT_FLAGS[LENIENT_FLAGS[\"KEEP_ALIVE\"] = 4] = \"KEEP_ALIVE\";\n})(LENIENT_FLAGS = exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));\nvar METHODS;\n(function (METHODS) {\n    METHODS[METHODS[\"DELETE\"] = 0] = \"DELETE\";\n    METHODS[METHODS[\"GET\"] = 1] = \"GET\";\n    METHODS[METHODS[\"HEAD\"] = 2] = \"HEAD\";\n    METHODS[METHODS[\"POST\"] = 3] = \"POST\";\n    METHODS[METHODS[\"PUT\"] = 4] = \"PUT\";\n    /* pathological */\n    METHODS[METHODS[\"CONNECT\"] = 5] = \"CONNECT\";\n    METHODS[METHODS[\"OPTIONS\"] = 6] = \"OPTIONS\";\n    METHODS[METHODS[\"TRACE\"] = 7] = \"TRACE\";\n    /* WebDAV */\n    METHODS[METHODS[\"COPY\"] = 8] = \"COPY\";\n    METHODS[METHODS[\"LOCK\"] = 9] = \"LOCK\";\n    METHODS[METHODS[\"MKCOL\"] = 10] = \"MKCOL\";\n    METHODS[METHODS[\"MOVE\"] = 11] = \"MOVE\";\n    METHODS[METHODS[\"PROPFIND\"] = 12] = \"PROPFIND\";\n    METHODS[METHODS[\"PROPPATCH\"] = 13] = \"PROPPATCH\";\n    METHODS[METHODS[\"SEARCH\"] = 14] = \"SEARCH\";\n    METHODS[METHODS[\"UNLOCK\"] = 15] = \"UNLOCK\";\n    METHODS[METHODS[\"BIND\"] = 16] = \"BIND\";\n    METHODS[METHODS[\"REBIND\"] = 17] = \"REBIND\";\n    METHODS[METHODS[\"UNBIND\"] = 18] = \"UNBIND\";\n    METHODS[METHODS[\"ACL\"] = 19] = \"ACL\";\n    /* subversion */\n    METHODS[METHODS[\"REPORT\"] = 20] = \"REPORT\";\n    METHODS[METHODS[\"MKACTIVITY\"] = 21] = \"MKACTIVITY\";\n    METHODS[METHODS[\"CHECKOUT\"] = 22] = \"CHECKOUT\";\n    METHODS[METHODS[\"MERGE\"] = 23] = \"MERGE\";\n    /* upnp */\n    METHODS[METHODS[\"M-SEARCH\"] = 24] = \"M-SEARCH\";\n    METHODS[METHODS[\"NOTIFY\"] = 25] = \"NOTIFY\";\n    METHODS[METHODS[\"SUBSCRIBE\"] = 26] = \"SUBSCRIBE\";\n    METHODS[METHODS[\"UNSUBSCRIBE\"] = 27] = \"UNSUBSCRIBE\";\n    /* RFC-5789 */\n    METHODS[METHODS[\"PATCH\"] = 28] = \"PATCH\";\n    METHODS[METHODS[\"PURGE\"] = 29] = \"PURGE\";\n    /* CalDAV */\n    METHODS[METHODS[\"MKCALENDAR\"] = 30] = \"MKCALENDAR\";\n    /* RFC-2068, section 19.6.1.2 */\n    METHODS[METHODS[\"LINK\"] = 31] = \"LINK\";\n    METHODS[METHODS[\"UNLINK\"] = 32] = \"UNLINK\";\n    /* icecast */\n    METHODS[METHODS[\"SOURCE\"] = 33] = \"SOURCE\";\n    /* RFC-7540, section 11.6 */\n    METHODS[METHODS[\"PRI\"] = 34] = \"PRI\";\n    /* RFC-2326 RTSP */\n    METHODS[METHODS[\"DESCRIBE\"] = 35] = \"DESCRIBE\";\n    METHODS[METHODS[\"ANNOUNCE\"] = 36] = \"ANNOUNCE\";\n    METHODS[METHODS[\"SETUP\"] = 37] = \"SETUP\";\n    METHODS[METHODS[\"PLAY\"] = 38] = \"PLAY\";\n    METHODS[METHODS[\"PAUSE\"] = 39] = \"PAUSE\";\n    METHODS[METHODS[\"TEARDOWN\"] = 40] = \"TEARDOWN\";\n    METHODS[METHODS[\"GET_PARAMETER\"] = 41] = \"GET_PARAMETER\";\n    METHODS[METHODS[\"SET_PARAMETER\"] = 42] = \"SET_PARAMETER\";\n    METHODS[METHODS[\"REDIRECT\"] = 43] = \"REDIRECT\";\n    METHODS[METHODS[\"RECORD\"] = 44] = \"RECORD\";\n    /* RAOP */\n    METHODS[METHODS[\"FLUSH\"] = 45] = \"FLUSH\";\n})(METHODS = exports.METHODS || (exports.METHODS = {}));\nexports.METHODS_HTTP = [\n    METHODS.DELETE,\n    METHODS.GET,\n    METHODS.HEAD,\n    METHODS.POST,\n    METHODS.PUT,\n    METHODS.CONNECT,\n    METHODS.OPTIONS,\n    METHODS.TRACE,\n    METHODS.COPY,\n    METHODS.LOCK,\n    METHODS.MKCOL,\n    METHODS.MOVE,\n    METHODS.PROPFIND,\n    METHODS.PROPPATCH,\n    METHODS.SEARCH,\n    METHODS.UNLOCK,\n    METHODS.BIND,\n    METHODS.REBIND,\n    METHODS.UNBIND,\n    METHODS.ACL,\n    METHODS.REPORT,\n    METHODS.MKACTIVITY,\n    METHODS.CHECKOUT,\n    METHODS.MERGE,\n    METHODS['M-SEARCH'],\n    METHODS.NOTIFY,\n    METHODS.SUBSCRIBE,\n    METHODS.UNSUBSCRIBE,\n    METHODS.PATCH,\n    METHODS.PURGE,\n    METHODS.MKCALENDAR,\n    METHODS.LINK,\n    METHODS.UNLINK,\n    METHODS.PRI,\n    // TODO(indutny): should we allow it with HTTP?\n    METHODS.SOURCE,\n];\nexports.METHODS_ICE = [\n    METHODS.SOURCE,\n];\nexports.METHODS_RTSP = [\n    METHODS.OPTIONS,\n    METHODS.DESCRIBE,\n    METHODS.ANNOUNCE,\n    METHODS.SETUP,\n    METHODS.PLAY,\n    METHODS.PAUSE,\n    METHODS.TEARDOWN,\n    METHODS.GET_PARAMETER,\n    METHODS.SET_PARAMETER,\n    METHODS.REDIRECT,\n    METHODS.RECORD,\n    METHODS.FLUSH,\n    // For AirPlay\n    METHODS.GET,\n    METHODS.POST,\n];\nexports.METHOD_MAP = utils_1.enumToMap(METHODS);\nexports.H_METHOD_MAP = {};\nObject.keys(exports.METHOD_MAP).forEach((key) => {\n    if (/^H/.test(key)) {\n        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];\n    }\n});\nvar FINISH;\n(function (FINISH) {\n    FINISH[FINISH[\"SAFE\"] = 0] = \"SAFE\";\n    FINISH[FINISH[\"SAFE_WITH_CB\"] = 1] = \"SAFE_WITH_CB\";\n    FINISH[FINISH[\"UNSAFE\"] = 2] = \"UNSAFE\";\n})(FINISH = exports.FINISH || (exports.FINISH = {}));\nexports.ALPHA = [];\nfor (let i = 'A'.charCodeAt(0); i <= 'Z'.charCodeAt(0); i++) {\n    // Upper case\n    exports.ALPHA.push(String.fromCharCode(i));\n    // Lower case\n    exports.ALPHA.push(String.fromCharCode(i + 0x20));\n}\nexports.NUM_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n};\nexports.HEX_MAP = {\n    0: 0, 1: 1, 2: 2, 3: 3, 4: 4,\n    5: 5, 6: 6, 7: 7, 8: 8, 9: 9,\n    A: 0XA, B: 0XB, C: 0XC, D: 0XD, E: 0XE, F: 0XF,\n    a: 0xa, b: 0xb, c: 0xc, d: 0xd, e: 0xe, f: 0xf,\n};\nexports.NUM = [\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',\n];\nexports.ALPHANUM = exports.ALPHA.concat(exports.NUM);\nexports.MARK = ['-', '_', '.', '!', '~', '*', '\\'', '(', ')'];\nexports.USERINFO_CHARS = exports.ALPHANUM\n    .concat(exports.MARK)\n    .concat(['%', ';', ':', '&', '=', '+', '$', ',']);\n// TODO(indutny): use RFC\nexports.STRICT_URL_CHAR = [\n    '!', '\"', '$', '%', '&', '\\'',\n    '(', ')', '*', '+', ',', '-', '.', '/',\n    ':', ';', '<', '=', '>',\n    '@', '[', '\\\\', ']', '^', '_',\n    '`',\n    '{', '|', '}', '~',\n].concat(exports.ALPHANUM);\nexports.URL_CHAR = exports.STRICT_URL_CHAR\n    .concat(['\\t', '\\f']);\n// All characters with 0x80 bit set to 1\nfor (let i = 0x80; i <= 0xff; i++) {\n    exports.URL_CHAR.push(i);\n}\nexports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);\n/* Tokens as defined by rfc 2616. Also lowercases them.\n *        token       = 1*<any CHAR except CTLs or separators>\n *     separators     = \"(\" | \")\" | \"<\" | \">\" | \"@\"\n *                    | \",\" | \";\" | \":\" | \"\\\" | <\">\n *                    | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\n *                    | \"{\" | \"}\" | SP | HT\n */\nexports.STRICT_TOKEN = [\n    '!', '#', '$', '%', '&', '\\'',\n    '*', '+', '-', '.',\n    '^', '_', '`',\n    '|', '~',\n].concat(exports.ALPHANUM);\nexports.TOKEN = exports.STRICT_TOKEN.concat([' ']);\n/*\n * Verify that a char is a valid visible (printable) US-ASCII\n * character or %x80-FF\n */\nexports.HEADER_CHARS = ['\\t'];\nfor (let i = 32; i <= 255; i++) {\n    if (i !== 127) {\n        exports.HEADER_CHARS.push(i);\n    }\n}\n// ',' = \\x44\nexports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);\nexports.MAJOR = exports.NUM_MAP;\nexports.MINOR = exports.MAJOR;\nvar HEADER_STATE;\n(function (HEADER_STATE) {\n    HEADER_STATE[HEADER_STATE[\"GENERAL\"] = 0] = \"GENERAL\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION\"] = 1] = \"CONNECTION\";\n    HEADER_STATE[HEADER_STATE[\"CONTENT_LENGTH\"] = 2] = \"CONTENT_LENGTH\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING\"] = 3] = \"TRANSFER_ENCODING\";\n    HEADER_STATE[HEADER_STATE[\"UPGRADE\"] = 4] = \"UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_KEEP_ALIVE\"] = 5] = \"CONNECTION_KEEP_ALIVE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_CLOSE\"] = 6] = \"CONNECTION_CLOSE\";\n    HEADER_STATE[HEADER_STATE[\"CONNECTION_UPGRADE\"] = 7] = \"CONNECTION_UPGRADE\";\n    HEADER_STATE[HEADER_STATE[\"TRANSFER_ENCODING_CHUNKED\"] = 8] = \"TRANSFER_ENCODING_CHUNKED\";\n})(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));\nexports.SPECIAL_HEADERS = {\n    'connection': HEADER_STATE.CONNECTION,\n    'content-length': HEADER_STATE.CONTENT_LENGTH,\n    'proxy-connection': HEADER_STATE.CONNECTION,\n    'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,\n    'upgrade': HEADER_STATE.UPGRADE,\n};\n//# sourceMappingURL=constants.js.map","module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGgtwQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVu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QZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELTwAgAEEYakIANwMAIABCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABBuAE2AhxBAAt7AQF/AkAgACgCDCIDDQACQCAAKAIERQ0AIAAgATYCBAsCQCAAIAEgAhC4gICAACIDDQAgACgCDA8LIAAgAzYCHEEAIQMgACgCBCIBRQ0AIAAgASACIAAoAggRgYCAgAAAIgFFDQAgACACNgIUIAAgATYCDCABIQMLIAML8soBAxl/A34FfyOAgICAAEEQayIDJICAgIAAIAEhBCABIQUgASEGIAEhByABIQggASEJIAEhCiABIQsgASEMIAEhDSABIQ4gASEPIAEhECABIREgASESIAEhEyABIRQgASEVIAEhFiABIRcgASEYIAEhGSABIRoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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QQEhGwwPC0GbASEbDA4LQZwBIRsMDQtBngEhGwwMC0GgASEbDAsLQZ8BIRsMCgtBoQEhGwwJC0GiASEbDAgLQaMBIRsMBwtBpAEhGwwGC0GlASEbDAULQaYBIRsMBAtBpwEhGwwDC0GoASEbDAILQakBIRsMAQtBrwEhGwsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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IAAgIDYCAAybAgsgAEEANgIAIB8gI2tBBWohAUEjIRsMswELAkAgASIEIAJHDQBB6wAhGwyaAgsCQAJAIAQtAABBtH9qDggAtgG2AbYBtgG2AbYBAbYBCyAEQQFqIQFB3QAhGwyPAgsgBEEBaiEBQd4AIRsMjgILAkAgASIEIAJHDQBB7AAhGwyZAgsgBC0AAEHFAEcNswEgBEEBaiEBDOQBC0HtACEbIAEiHyACRg2XAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBqLKAgABqLQAARw2zASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMmAILIABBADYCACAfICNrQQRqIQFBLSEbDLABC0HuACEbIAEiHyACRg2WAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFB8LKAgABqLQAARw2yASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlwILIABBADYCACAfICNrQQlqIQFBKSEbDK8BCwJAIAEiASACRw0AQe8AIRsMlgILQQEhGyABLQAAQd8ARw2uASABQQFqIQEM4gELQfAAIRsgASIfIAJGDZQCIAIgH2sgACgCACIjaiEgIB8hBCAjIQEDQCAELQAAIAFBrLKAgABqLQAARw2vASABQQFGDfoBIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADJQCC0HxACEbIAEiHyACRg2TAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBrrKAgABqLQAARw2vASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlAILIABBADYCACAfICNrQQNqIQFBAiEbDKwBC0HyACEbIAEiHyACRg2SAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkLOAgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMkwILIABBADYCACAfICNrQQJqIQFBHyEbDKsBC0HzACEbIAEiHyACRg2RAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkrOAgABqLQAARw2tASABQQFGDQEgAUEBaiEBIARBAWoiBCAC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c3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAE1LQUNUSVZJVFkAQ09QWQBOT1RJRlkAUExBWQBQVVQAQ0hFQ0tPVVQAUE9TVABSRVBPUlQASFBFX0lOVkFMSURfQ09OU1RBTlQAR0VUAEhQRV9TVFJJQ1QAUkVESVJFQ1QAQ09OTkVDVABIUEVfSU5WQUxJRF9TVEFUVVMAT1BUSU9OUwBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBIUEVfSU5WQUxJRF9VUkwATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAFBBVVNFAFBVUkdFAE1FUkdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QAUFJPUEZJTkQAVU5CSU5EAFJFQklORABIUEVfTEZfRVhQRUNURUQASFBFX1BBVVNFRABIRUFEAEV4cGVjdGVkIEhUVFAvAIwLAAB/CwAAgwoAADkNAADACwAADQsAAA8NAABlCwAAagoAACMLAABMCwAApQsAACMMAACfCgAAjAwAAPcLAAA3CwAAPwwAAG0MAADfCgAAVwwAAEkNAAC0DAAAxwwAANYKAACFDAAAfwoAAFQNAABeCgAAUQoAAJcKAACyCgAA7QwAAEAKAACcCwAAdQsAADoMAAAiDQAA5AsAAPALAACaCwAANA0AADINAAArDQAAewsAAGMKAAA1CgAAVQoAAK4MAADuCwAARQoAAP4MAAD8DAAA6AsAAKgMAADzCgAAlQsAAJMLAADdDAAAoQsAAPMMAADkDAAA/goAAEwKAACiDAAABAsAAMgKAAC6CgAAjgoAAAgNAADeCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv\";\n","module.exports = \"AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGgtwQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYK2aQCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAs+AQF7IAD9DAAAAAAAAAAAAAAAAAAAAAAiAf0LAgAgAEEwakIANwIAIABBIGogAf0LAgAgAEEQaiAB/QsCAAtnAQF/QQAhAQJAIAAoAgwNAAJAAkACQAJAIAAtAC8OAwEAAwILIAAoAjQiAUUNACABKAIcIgFFDQAgACABEYCAgIAAACIBDQMLQQAPCxC/gICAAAALIABBr5GAgAA2AhBBDiEBCyABCx4AAkAgACgCDA0AIABBtJOAgAA2AhAgAEEVNgIMCwsWAAJAIAAoAgxBFUcNACAAQQA2AgwLCxYAAkAgACgCDEEWRw0AIABBADYCDAsLBwAgACgCDAsHACAAKAIQCwkAIAAgATYCEAsHACAAKAIUCyIAAkAgAEEZSQ0AEL+AgIAAAAsgAEECdEHomoCAAGooAgALIgACQCAAQS5JDQAQv4CAgAAACyAAQQJ0QcybgIAAaigCAAsWACAAIAAtAC1B/gFxIAFBAEdyOgAtCxkAIAAgAC0ALUH9AXEgAUEAR0EBdHI6AC0LLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCACIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIEIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBnI6AgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAigiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCCCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQdKKgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIsIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAgwiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEGNk4CAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCMCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIQIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBw5CAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCFCIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIcIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAhgiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSiICAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCICIERQ0AIAAgBBGAgICAAAAhAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIkIgRFDQAgACAEEYCAgIAAACEDCyADC0UBAX8CQAJAIAAvATBBFHFBFEcNAEEBIQMgAC0AKEEBRg0BIAAvATJB5QBGIQMMAQsgAC0AKUEFRiEDCyAAIAM6AC5BAAv0AQEDf0EBIQMCQCAALwEwIgRBCHENACAAKQMgQgBSIQMLAkACQCAALQAuRQ0AQQEhBSAALQApQQVGDQFBASEFIARBwABxRSADcUEBRw0BC0EAIQUgBEHAAHENAEECIQUgBEEIcQ0AAkAgBEGABHFFDQACQCAALQAoQQFHDQBBBSEFIAAtAC1BAnFFDQILQQQPCwJAIARBIHENAAJAIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNAEEEIQUgBEGIBHFBgARGDQIgBEEocUUNAgtBAA8LQQBBAyAAKQMgUBshBQsgBQtdAQJ/QQAhAQJAIAAtAChBAUYNACAALwEyIgJBnH9qQeQASQ0AIAJBzAFGDQAgAkGwAkYNACAALwEwIgBBwABxDQBBASEBIABBiARxQYAERg0AIABBKHFFIQELIAELogEBA38CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhAyAALwEwIgRBAnFFDQEMAgtBACEDIAAvATAiBEEBcUUNAQtBASEDIAAtAChBAUYNACAALwEyIgVBnH9qQeQASQ0AIAVBzAFGDQAgBUGwAkYNACAEQcAAcQ0AQQAhAyAEQYgEcUGABEYNACAEQShxQQBHIQMLIABBADsBMCAAQQA6AC8gAwuUAQECfwJAAkACQCAALQAqRQ0AIAAtACtFDQBBACEBIAAvATAiAkECcUUNAQwCC0EAIQEgAC8BMCICQQFxRQ0BC0EBIQEgAC0AKEEBRg0AIAAvATIiAEGcf2pB5ABJDQAgAEHMAUYNACAAQbACRg0AIAJBwABxDQBBACEBIAJBiARxQYAERg0AIAJBKHFBAEchAQsgAQtIAQF7IABBEGr9DAAAAAAAAAAAAAAAAAAAAAAiAf0LAwAgACAB/QsDACAAQTBqQgA3AwAgAEEgaiAB/QsDACAAQbgBNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQuICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC/LKAQMZfwN+BX8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDyABIRAgASERIAEhEiABIRMgASEUIAEhFSABIRYgASEXIAEhGCABIRkgASEaAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhtBf2oOuAG1AQG0AQIDBAUGBwgJCgsMDQ4PELsBugEREhOzARQVFhcYGRobHB0eHyAhsgGxASIjJCUmJygpKissLS4vMDEyMzQ1Njc4OTq2ATs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAQC3AQtBACEbDK8BC0EQIRsMrgELQQ8hGwytAQtBESEbDKwBC0ESIRsMqwELQRUhGwyqAQtBFiEbDKkBC0EXIRsMqAELQRghGwynAQtBGSEbDKYBC0EIIRsMpQELQRohGwykAQtBGyEbDKMBC0EUIRsMogELQRMhGwyhAQtBHCEbDKABC0EdIRsMnwELQR4hGwyeAQtBHyEbDJ0BC0GqASEbDJwBC0GrASEbDJsBC0EhIRsMmgELQSIhGwyZAQtBIyEbDJgBC0EkIRsMlwELQSUhGwyWAQtBrQEhGwyVAQtBJiEbDJQBC0EqIRsMkwELQQ4hGwySAQtBJyEbDJEBC0EoIRsMkAELQSkhGwyPAQtBLiEbDI4BC0ErIRsMjQELQa4BIRsMjAELQQ0hGwyLAQtBDCEbDIoBC0EvIRsMiQELQQshGwyIAQtBLCEbDIcBC0EtIRsMhgELQQohGwyFAQtBMSEbDIQBC0EwIRsMgwELQQkhGwyCAQtBICEbDIEBC0EyIRsMgAELQTMhGwx/C0E0IRsMfgtBNSEbDH0LQTYhGwx8C0E3IRsMewtBOCEbDHoLQTkhGwx5C0E6IRsMeAtBrAEhGwx3C0E7IRsMdgtBPCEbDHULQT0hGwx0C0E+IRsMcwtBPyEbDHILQcAAIRsMcQtBwQAhGwxwC0HCACEbDG8LQcMAIRsMbgtBxAAhGwxtC0EHIRsMbAtBxQAhGwxrC0EGIRsMagtBxgAhGwxpC0EFIRsMaAtBxwAhGwxnC0EEIRsMZgtByAAhGwxlC0HJACEbDGQLQcoAIRsMYwtBywAhGwxiC0EDIRsMYQtBzAAhGwxgC0HNACEbDF8LQc4AIRsMXgtB0AAhGwxdC0HPACEbDFwLQdEAIRsMWwtB0gAhGwxaC0ECIRsMWQtB0wAhGwxYC0HUACEbDFcLQdUAIRsMVgtB1gAhGwxVC0HXACEbDFQLQdgAIRsMUwtB2QAhGwxSC0HaACEbDFELQdsAIRsMUAtB3AAhGwxPC0HdACEbDE4LQd4AIRsMTQtB3wAhGwxMC0HgACEbDEsLQeEAIRsMSgtB4gAhGwxJC0HjACEbDEgLQeQAIRsMRwtB5QAhGwxGC0HmACEbDEULQecAIRsMRAtB6AAhGwxDC0HpACEbDEILQeoAIRsMQQtB6wAhGwxAC0HsACEbDD8LQe0AIRsMPgtB7gAhGww9C0HvACEbDDwLQfAAIRsMOwtB8QAhGww6C0HyACEbDDkLQfMAIRsMOAtB9AAhGww3C0H1ACEbDDYLQfYAIRsMNQtB9wAhGww0C0H4ACEbDDMLQfkAIRsMMgtB+gAhGwwxC0H7ACEbDDALQfwAIRsMLwtB/QAhGwwuC0H+ACEbDC0LQf8AIRsMLAtBgAEhGwwrC0GBASEbDCoLQYIBIRsMKQtBgwEhGwwoC0GEASEbDCcLQYUBIRsMJgtBhgEhGwwlC0GHASEbDCQLQYgBIRsMIwtBiQEhGwwiC0GKASEbDCELQYsBIRsMIAtBjAEhGwwfC0GNASEbDB4LQY4BIRsMHQtBjwEhGwwcC0GQASEbDBsLQZEBIRsMGgtBkgEhGwwZC0GTASEbDBgLQZQBIRsMFwtBlQEhGwwWC0GWASEbDBULQZcBIRsMFAtBmAEhGwwTC0GZASEbDBILQZ0BIRsMEQtBmgEhGwwQC0EBIRsMDwtBmwEhGwwOC0GcASEbDA0LQZ4BIRsMDAtBoAEhGwwLC0GfASEbDAoLQaEBIRsMCQtBogEhGwwIC0GjASEbDAcLQaQBIRsMBgtBpQEhGwwFC0GmASEbDAQLQacBIRsMAwtBqAEhGwwCC0GpASEbDAELQa8BIRsLA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBsO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aG9kIGZvciBSVFNQL3gueCByZXF1ZXN0AEV4cGVjdGVkIFNPVVJDRSBtZXRob2QgZm9yIElDRS94LnggcmVxdWVzdABJbnZhbGlkIGNoYXIgaW4gdXJsIGZyYWdtZW50IHN0YXJ0AEV4cGVjdGVkIGRvdABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3N0YXR1cwBJbnZhbGlkIHJlc3BvbnNlIHN0YXR1cwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBwYXJhbWV0ZXJzAFVzZXIgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2hlYWRlcmAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfYmVnaW5gIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21lc3NhZ2VfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBJbnZhbGlkIG1pbm9yIHZlcnNpb24ASW52YWxpZCBtYWpvciB2ZXJzaW9uAEV4cGVjdGVkIHNwYWNlIGFmdGVyIHZlcnNpb24ARXhwZWN0ZWQgQ1JMRiBhZnRlciB2ZXJzaW9uAEludmFsaWQgaGVhZGVyIHRva2VuAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fdXJsAEludmFsaWQgY2hhcmFjdGVycyBpbiB1cmwAVW5leHBlY3RlZCBzdGFydCBjaGFyIGluIHVybABEb3VibGUgQCBpbiB1cmwARW1wdHkgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyYWN0ZXIgaW4gQ29udGVudC1MZW5ndGgARHVwbGljYXRlIENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhciBpbiB1cmwgcGF0aABDb250ZW50LUxlbmd0aCBjYW4ndCBiZSBwcmVzZW50IHdpdGggVHJhbnNmZXItRW5jb2RpbmcASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgc2l6ZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl92YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBQYXVzZWQgYnkgb25faGVhZGVyc19jb21wbGV0ZQBJbnZhbGlkIEVPRiBzdGF0ZQBvbl9jaHVua19oZWFkZXIgcGF1c2UAb25fbWVzc2FnZV9iZWdpbiBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9tZXNzYWdlX2NvbXBsZXRlIHBhdXNlAFBhdXNlIG9uIENPTk5FQ1QvVXBncmFkZQBQYXVzZSBvbiBQUkkvVXBncmFkZQBFeHBlY3RlZCBIVFRQLzIgQ29ubmVjdGlvbiBQcmVmYWNlAEV4cGVjdGVkIHNwYWNlIGFmdGVyIG1ldGhvZABTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2hlYWRlcl9maWVsZABQYXVzZWQASW52YWxpZCB3b3JkIGVuY291bnRlcmVkAEludmFsaWQgbWV0aG9kIGVuY291bnRlcmVkAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2NoZW1hAFJlcXVlc3QgaGFzIGludmFsaWQgYFRyYW5zZmVyLUVuY29kaW5nYABNS0FDVElWSVRZAENPUFkATk9USUZZAFBMQVkAUFVUAENIRUNLT1VUAFBPU1QAUkVQT1JUAEhQRV9JTlZBTElEX0NPTlNUQU5UAEdFVABIUEVfU1RSSUNUAFJFRElSRUNUAENPTk5FQ1QASFBFX0lOVkFMSURfU1RBVFVTAE9QVElPTlMAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABURUFSRE9XTgBIUEVfQ0xPU0VEX0NPTk5FQ1RJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASFBFX0lOVkFMSURfVVJMAE1LQ09MAEFDTABIUEVfSU5URVJOQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAEhQRV9JTlZBTElEX0NPTlRFTlRfTEVOR1RIAEhQRV9VTkVYUEVDVEVEX0NPTlRFTlRfTEVOR1RIAEZMVVNIAFBS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bmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==\";\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.enumToMap = void 0;\nfunction enumToMap(obj) {\n    const res = {};\n    Object.keys(obj).forEach((key) => {\n        const value = obj[key];\n        if (typeof value === 'number') {\n            res[key] = value;\n        }\n    });\n    return res;\n}\nexports.enumToMap = enumToMap;\n//# sourceMappingURL=utils.js.map","'use strict'\n\nconst { kClients } = require('../core/symbols')\nconst Agent = require('../agent')\nconst {\n  kAgent,\n  kMockAgentSet,\n  kMockAgentGet,\n  kDispatches,\n  kIsMockActive,\n  kNetConnect,\n  kGetNetConnect,\n  kOptions,\n  kFactory\n} = require('./mock-symbols')\nconst MockClient = require('./mock-client')\nconst MockPool = require('./mock-pool')\nconst { matchValue, buildMockOptions } = require('./mock-utils')\nconst { InvalidArgumentError } = require('../core/errors')\nconst Dispatcher = require('../dispatcher')\nconst { WeakRef } = require('../compat/dispatcher-weakref')()\n\nclass MockAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n\n    this[kNetConnect] = true\n    this[kIsMockActive] = true\n\n    // Instantiate Agent and encapsulate\n    if ((opts && opts.agent && typeof opts.agent.dispatch !== 'function')) {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n    const agent = opts && opts.agent ? opts.agent : new Agent(opts)\n    this[kAgent] = agent\n\n    this[kClients] = agent[kClients]\n    this[kOptions] = buildMockOptions(opts)\n  }\n\n  get (origin) {\n    let dispatcher = this[kMockAgentGet](origin)\n\n    if (!dispatcher) {\n      dispatcher = this[kFactory](origin)\n      this[kMockAgentSet](origin, dispatcher)\n    }\n    return dispatcher\n  }\n\n  dispatch (opts, handler) {\n    // Call MockAgent.get to perform additional setup before dispatching as normal\n    this.get(opts.origin)\n    return this[kAgent].dispatch(opts, handler)\n  }\n\n  async close () {\n    await this[kAgent].close()\n    this[kClients].clear()\n  }\n\n  deactivate () {\n    this[kIsMockActive] = false\n  }\n\n  activate () {\n    this[kIsMockActive] = true\n  }\n\n  enableNetConnect (matcher) {\n    if (typeof matcher === 'string' || typeof matcher === 'function' || matcher instanceof RegExp) {\n      if (Array.isArray(this[kNetConnect])) {\n        this[kNetConnect].push(matcher)\n      } else {\n        this[kNetConnect] = [matcher]\n      }\n    } else if (typeof matcher === 'undefined') {\n      this[kNetConnect] = true\n    } else {\n      throw new InvalidArgumentError('Unsupported matcher. Must be one of String|Function|RegExp.')\n    }\n  }\n\n  disableNetConnect () {\n    this[kNetConnect] = false\n  }\n\n  [kMockAgentSet] (origin, dispatcher) {\n    this[kClients].set(origin, new WeakRef(dispatcher))\n  }\n\n  [kFactory] (origin) {\n    const mockOptions = Object.assign({ agent: this }, this[kOptions])\n    return this[kOptions] && this[kOptions].connections === 1\n      ? new MockClient(origin, mockOptions)\n      : new MockPool(origin, mockOptions)\n  }\n\n  [kMockAgentGet] (origin) {\n    // First check if we can immediately find it\n    const ref = this[kClients].get(origin)\n    if (ref) {\n      return ref.deref()\n    }\n\n    // If the origin is not a string create a dummy parent pool and return to user\n    if (typeof origin !== 'string') {\n      const dispatcher = this[kFactory]('http://localhost:9999')\n      this[kMockAgentSet](origin, dispatcher)\n      return dispatcher\n    }\n\n    // If we match, create a pool and assign the same dispatches\n    for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {\n      const nonExplicitDispatcher = nonExplicitRef.deref()\n      if (nonExplicitDispatcher && typeof keyMatcher !== 'string' && matchValue(keyMatcher, origin)) {\n        const dispatcher = this[kFactory](origin)\n        this[kMockAgentSet](origin, dispatcher)\n        dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches]\n        return dispatcher\n      }\n    }\n  }\n\n  [kGetNetConnect] () {\n    return this[kNetConnect]\n  }\n}\n\nmodule.exports = MockAgent\n","'use strict'\n\nconst { promisify } = require('util')\nconst Client = require('../client')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockClient provides an API that extends the Client to influence the mockDispatches.\n */\nclass MockClient extends Client {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockClient\n","'use strict'\n\nconst { UndiciError } = require('../core/errors')\n\nclass MockNotMatchedError extends UndiciError {\n  constructor (message) {\n    super(message)\n    Error.captureStackTrace(this, MockNotMatchedError)\n    this.name = 'MockNotMatchedError'\n    this.message = message || 'The request does not match any registered mock dispatches'\n    this.code = 'UND_MOCK_ERR_MOCK_NOT_MATCHED'\n  }\n}\n\nmodule.exports = {\n  MockNotMatchedError\n}\n","'use strict'\n\nconst { getResponseData, buildKey, addMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kDispatchKey,\n  kDefaultHeaders,\n  kDefaultTrailers,\n  kContentLength,\n  kMockDispatch\n} = require('./mock-symbols')\nconst { InvalidArgumentError, InvalidReturnValueError } = require('../core/errors')\n\n/**\n * Defines the scope API for a interceptor reply\n */\nclass MockScope {\n  constructor (mockDispatch) {\n    this[kMockDispatch] = mockDispatch\n  }\n\n  /**\n   * Delay a reply by a set amount in ms.\n   */\n  delay (waitInMs) {\n    if (typeof waitInMs !== 'number' || !Number.isInteger(waitInMs) || waitInMs <= 0) {\n      throw new InvalidArgumentError('waitInMs must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].delay = waitInMs\n    return this\n  }\n\n  /**\n   * For a defined reply, never mark as consumed.\n   */\n  persist () {\n    this[kMockDispatch].persist = true\n    return this\n  }\n\n  /**\n   * Allow one to define a reply for a set amount of matching requests.\n   */\n  times (repeatTimes) {\n    if (typeof repeatTimes !== 'number' || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {\n      throw new InvalidArgumentError('repeatTimes must be a valid integer > 0')\n    }\n\n    this[kMockDispatch].times = repeatTimes\n    return this\n  }\n}\n\n/**\n * Defines an interceptor for a Mock\n */\nclass MockInterceptor {\n  constructor (opts, mockDispatches) {\n    if (typeof opts !== 'object') {\n      throw new InvalidArgumentError('opts must be an object')\n    }\n    if (typeof opts.path === 'undefined') {\n      throw new InvalidArgumentError('opts.path must be defined')\n    }\n    if (typeof opts.method === 'undefined') {\n      throw new InvalidArgumentError('opts.method must be defined')\n    }\n\n    this[kDispatchKey] = buildKey(opts)\n    this[kDispatches] = mockDispatches\n    this[kDefaultHeaders] = {}\n    this[kDefaultTrailers] = {}\n    this[kContentLength] = false\n  }\n\n  createMockScopeDispatchData(statusCode, data, responseOptions = {}) {\n    const responseData = getResponseData(data)\n    const contentLength = this[kContentLength] ? { 'content-length': responseData.length } : {}\n    const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers }\n    const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers }\n\n    return { statusCode, data, headers, trailers };\n  }\n\n  validateReplyParameters(statusCode, data, responseOptions) {\n    if (typeof statusCode === 'undefined') {\n      throw new InvalidArgumentError('statusCode must be defined')\n    }\n    if (typeof data === 'undefined') {\n      throw new InvalidArgumentError('data must be defined')\n    }\n    if (typeof responseOptions !== 'object') {\n      throw new InvalidArgumentError('responseOptions must be an object')\n    }\n  }\n\n  /**\n   * Mock an undici request with a defined reply.\n   */\n  reply (replyData) {\n    // Values of reply aren't available right now as they\n    // can only be available when the reply callback is invoked.\n    if (typeof replyData === 'function') {\n      // We'll first wrap the provided callback in another function,\n      // this function will properly resolve the data from the callback\n      // when invoked.\n      const wrappedDefaultsCallback = (opts) => {\n        // Our reply options callback contains the parameter for statusCode, data and options.\n        const resolvedData = replyData(opts);\n\n        // Check if it is in the right format\n        if (typeof resolvedData !== 'object') {\n          throw new InvalidArgumentError('reply options callback must return an object')\n        }\n\n        const { statusCode, data, responseOptions = {}} = resolvedData;\n        this.validateReplyParameters(statusCode, data, responseOptions);\n        // Since the values can be obtained immediately we return them\n        // from this higher order function that will be resolved later.\n        return { \n          ...this.createMockScopeDispatchData(statusCode, data, responseOptions)\n        }\n      }\n\n      // Add usual dispatch data, but this time set the data parameter to function that will eventually provide data.\n      const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback)\n      return new MockScope(newMockDispatch);\n    }\n\n    // We can have either one or three parameters, if we get here,\n    // we should have 2-3 parameters. So we spread the arguments of\n    // this function to obtain the parameters, since replyData will always\n    // just be the statusCode. \n    const [statusCode, data, responseOptions = {}] = [...arguments];   \n    this.validateReplyParameters(statusCode, data, responseOptions);\n\n    // Send in-already provided data like usual\n    const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData)\n    return new MockScope(newMockDispatch)\n    \n  }\n\n  /**\n   * Mock an undici request with a defined error.\n   */\n  replyWithError (error) {\n    if (typeof error === 'undefined') {\n      throw new InvalidArgumentError('error must be defined')\n    }\n\n    const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error })\n    return new MockScope(newMockDispatch)\n  }\n\n  /**\n   * Set default reply headers on the interceptor for subsequent replies\n   */\n  defaultReplyHeaders (headers) {\n    if (typeof headers === 'undefined') {\n      throw new InvalidArgumentError('headers must be defined')\n    }\n\n    this[kDefaultHeaders] = headers\n    return this\n  }\n\n  /**\n   * Set default reply trailers on the interceptor for subsequent replies\n   */\n  defaultReplyTrailers (trailers) {\n    if (typeof trailers === 'undefined') {\n      throw new InvalidArgumentError('trailers must be defined')\n    }\n\n    this[kDefaultTrailers] = trailers\n    return this\n  }\n\n  /**\n   * Set reply content length header for replies on the interceptor\n   */\n  replyContentLength () {\n    this[kContentLength] = true\n    return this\n  }\n}\n\nmodule.exports.MockInterceptor = MockInterceptor\nmodule.exports.MockScope = MockScope\n","'use strict'\n\nconst { promisify } = require('util')\nconst Pool = require('../pool')\nconst { buildMockDispatch } = require('./mock-utils')\nconst {\n  kDispatches,\n  kMockAgent,\n  kClose,\n  kOriginalClose,\n  kOrigin,\n  kOriginalDispatch,\n  kConnected\n} = require('./mock-symbols')\nconst { MockInterceptor } = require('./mock-interceptor')\nconst Symbols = require('../core/symbols')\nconst { InvalidArgumentError } = require('../core/errors')\n\n/**\n * MockPool provides an API that extends the Pool to influence the mockDispatches.\n */\nclass MockPool extends Pool {\n  constructor (origin, opts) {\n    super(origin, opts)\n\n    if (!opts || !opts.agent || typeof opts.agent.dispatch !== 'function') {\n      throw new InvalidArgumentError('Argument opts.agent must implement Agent')\n    }\n\n    this[kMockAgent] = opts.agent\n    this[kOrigin] = origin\n    this[kDispatches] = []\n    this[kConnected] = 1\n    this[kOriginalDispatch] = this.dispatch\n    this[kOriginalClose] = this.close.bind(this)\n\n    this.dispatch = buildMockDispatch.call(this)\n    this.close = this[kClose]\n  }\n\n  get [Symbols.kConnected] () {\n    return this[kConnected]\n  }\n\n  /**\n   * Sets up the base interceptor for mocking replies from undici.\n   */\n  intercept (opts) {\n    return new MockInterceptor(opts, this[kDispatches])\n  }\n\n  async [kClose] () {\n    await promisify(this[kOriginalClose])()\n    this[kConnected] = 0\n    this[kMockAgent][Symbols.kClients].delete(this[kOrigin])\n  }\n}\n\nmodule.exports = MockPool\n","'use strict'\n\nmodule.exports = {\n  kAgent: Symbol('agent'),\n  kOptions: Symbol('options'),\n  kFactory: Symbol('factory'),\n  kDispatches: Symbol('dispatches'),\n  kDispatchKey: Symbol('dispatch key'),\n  kDefaultHeaders: Symbol('default headers'),\n  kDefaultTrailers: Symbol('default trailers'),\n  kContentLength: Symbol('content length'),\n  kMockAgent: Symbol('mock agent'),\n  kMockAgentSet: Symbol('mock agent set'),\n  kMockAgentGet: Symbol('mock agent get'),\n  kMockDispatch: Symbol('mock dispatch'),\n  kClose: Symbol('close'),\n  kOriginalClose: Symbol('original agent close'),\n  kOrigin: Symbol('origin'),\n  kIsMockActive: Symbol('is mock active'),\n  kNetConnect: Symbol('net connect'),\n  kGetNetConnect: Symbol('get net connect'),\n  kConnected: Symbol('connected')\n}\n","'use strict'\n\nconst { MockNotMatchedError } = require('./mock-errors')\nconst { kHeadersList } = require('../core/symbols')\nconst {\n  kDispatches,\n  kMockAgent,\n  kOriginalDispatch,\n  kOrigin,\n  kIsMockActive,\n  kGetNetConnect\n} = require('./mock-symbols')\n\nfunction matchValue (match, value) {\n  if (typeof match === 'string') {\n    return match === value\n  }\n  if (match instanceof RegExp) {\n    return match.test(value)\n  }\n  if (typeof match === 'function') {\n    return match(value) === true\n  }\n  return false\n}\n\nfunction matchHeaders (mockDispatch, headers) {\n  if (typeof mockDispatch.headers === 'undefined') {\n    return true\n  }\n  if (typeof headers !== 'object' || typeof mockDispatch.headers !== 'object') {\n    return false\n  }\n\n  for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch.headers)) {\n    const header = typeof headers.get === 'function' ? headers.get(matchHeaderName) : headers[matchHeaderName]\n\n    if (!matchValue(matchHeaderValue, header)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction matchKey (mockDispatch, { path, method, body, headers }) {\n  const pathMatch = matchValue(mockDispatch.path, path)\n  const methodMatch = matchValue(mockDispatch.method, method)\n  const bodyMatch = typeof mockDispatch.body !== 'undefined' ? matchValue(mockDispatch.body, body) : true\n  const headersMatch = matchHeaders(mockDispatch, headers)\n  return pathMatch && methodMatch && bodyMatch && headersMatch\n}\n\nfunction getResponseData (data) {\n  if (Buffer.isBuffer(data)) {\n    return data\n  } else if (typeof data === 'object') {\n    return JSON.stringify(data)\n  } else {\n    return data.toString()\n  }\n}\n\nfunction getMockDispatch (mockDispatches, key) {\n  // Match path\n  let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(path, key.path))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for path '${key.path}'`)\n  }\n\n  // Match method\n  matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`)\n  }\n\n  // Match body\n  matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== 'undefined' ? matchValue(body, key.body) : true)\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`)\n  }\n\n  // Match headers\n  matchedMockDispatches = matchedMockDispatches.filter((mockDispatch) => matchHeaders(mockDispatch, key.headers))\n  if (matchedMockDispatches.length === 0) {\n    throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === 'object' ? JSON.stringify(key.headers) : key.headers}'`)\n  }\n\n  return matchedMockDispatches[0]\n}\n\nfunction addMockDispatch (mockDispatches, key, data) {\n  const baseData = { times: null, persist: false, consumed: false }\n  const replyData = typeof data === 'function' ? { callback: data } : { ...data };\n  const newMockDispatch = { ...baseData, ...key, data: { error: null, ...replyData } }\n  mockDispatches.push(newMockDispatch)\n  return newMockDispatch\n}\n\nfunction deleteMockDispatch (mockDispatches, key) {\n  const index = mockDispatches.findIndex(dispatch => {\n    if (!dispatch.consumed) {\n      return false\n    }\n    return matchKey(dispatch, key)\n  })\n  if (index !== -1) {\n    mockDispatches.splice(index, 1)\n  }\n}\n\nfunction buildKey (opts) {\n  const { path, method, body, headers } = opts\n  return {\n    path,\n    method,\n    body,\n    headers\n  }\n}\n\nfunction generateKeyValues (data) {\n  return Object.entries(data).reduce((keyValuePairs, [key, value]) => [...keyValuePairs, key, value], [])\n}\n\nasync function getResponse (body) {\n  const buffers = []\n  for await (const data of body) {\n    buffers.push(data)\n  }\n  return Buffer.concat(buffers).toString('utf8')\n}\n\n/**\n * Mock dispatch function used to simulate undici dispatches\n */\nfunction mockDispatch (opts, handler) {\n  // Get mock dispatch from built key\n  const key = buildKey(opts)\n  let mockDispatch = getMockDispatch(this[kDispatches], key)\n\n  // Here's where we resolve a callback if a callback is present for the dispatch data.\n  if (mockDispatch.data.callback) {\n    mockDispatch.data = { ...mockDispatch.data, ...mockDispatch.data.callback(opts) }\n  }\n\n  // Parse mockDispatch data\n  const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch\n  let { times } = mockDispatch\n  if (typeof times === 'number' && times > 0) {\n    times = --mockDispatch.times\n  }\n\n  // If persist is true, skip\n  // Or if times is a number and > 0, skip\n  // Otherwise, mark as consumed\n\n  if (!(persist === true || (typeof times === 'number' && times > 0))) {\n    mockDispatch.consumed = true\n  }\n\n  // If specified, trigger dispatch error\n  if (error !== null) {\n    deleteMockDispatch(this[kDispatches], key)\n    handler.onError(error)\n    return true\n  }\n\n  // Handle the request with a delay if necessary\n  if (typeof delay === 'number' && delay > 0) {\n    setTimeout(() => {\n      handleReply(this[kDispatches])\n    }, delay)\n  } else {\n    handleReply(this[kDispatches])\n  }\n\n  function handleReply (mockDispatches) {\n    const responseData = getResponseData(typeof data === 'function' ? data(opts) : data);\n    const responseHeaders = generateKeyValues(headers)\n    const responseTrailers = generateKeyValues(trailers)\n\n    handler.onHeaders(statusCode, responseHeaders, resume)\n    handler.onData(Buffer.from(responseData))\n    handler.onComplete(responseTrailers)\n    deleteMockDispatch(mockDispatches, key)\n  }\n\n  function resume () {}\n\n  return true\n}\n\nfunction buildMockDispatch () {\n  const agent = this[kMockAgent]\n  const origin = this[kOrigin]\n  const originalDispatch = this[kOriginalDispatch]\n\n  return function dispatch (opts, handler) {\n    if (agent[kIsMockActive]) {\n      try {\n        mockDispatch.call(this, opts, handler)\n      } catch (error) {\n        if (error instanceof MockNotMatchedError) {\n          const netConnect = agent[kGetNetConnect]()\n          if (netConnect === false) {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`)\n          }\n          if (checkNetConnect(netConnect, origin)) {\n            originalDispatch.call(this, opts, handler)\n          } else {\n            throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`)\n          }\n        } else {\n          throw error\n        }\n      }\n    } else {\n      originalDispatch.call(this, opts, handler)\n    }\n  }\n}\n\nfunction checkNetConnect (netConnect, origin) {\n  const url = new URL(origin)\n  if (netConnect === true) {\n    return true\n  } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {\n    return true\n  }\n  return false\n}\n\nfunction buildMockOptions (opts) {\n  if (opts) {\n    const { agent, ...mockOptions } = opts\n    return mockOptions\n  }\n}\n\nmodule.exports = {\n  getResponseData,\n  getMockDispatch,\n  addMockDispatch,\n  deleteMockDispatch,\n  buildKey,\n  generateKeyValues,\n  matchValue,\n  getResponse,\n  mockDispatch,\n  buildMockDispatch,\n  checkNetConnect,\n  buildMockOptions\n}\n","/* eslint-disable */\n\n'use strict'\n\n// Extracted from node/lib/internal/fixed_queue.js\n\n// Currently optimal queue size, tested on V8 6.0 - 6.6. Must be power of two.\nconst kSize = 2048;\nconst kMask = kSize - 1;\n\n// The FixedQueue is implemented as a singly-linked list of fixed-size\n// circular buffers. It looks something like this:\n//\n//  head                                                       tail\n//    |                                                          |\n//    v                                                          v\n// +-----------+ <-----\\       +-----------+ <------\\         +-----------+\n// |  [null]   |        \\----- |   next    |         \\------- |   next    |\n// +-----------+               +-----------+                  +-----------+\n// |   item    | <-- bottom    |   item    | <-- bottom       |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |                  |  [empty]  |\n// |   item    |               |   item    |       bottom --> |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |    ...    |               |    ...    |                  |    ...    |\n// |   item    |               |   item    |                  |   item    |\n// |   item    |               |   item    |                  |   item    |\n// |  [empty]  | <-- top       |   item    |                  |   item    |\n// |  [empty]  |               |   item    |                  |   item    |\n// |  [empty]  |               |  [empty]  | <-- top  top --> |  [empty]  |\n// +-----------+               +-----------+                  +-----------+\n//\n// Or, if there is only one circular buffer, it looks something\n// like either of these:\n//\n//  head   tail                                 head   tail\n//    |     |                                     |     |\n//    v     v                                     v     v\n// +-----------+                               +-----------+\n// |  [null]   |                               |  [null]   |\n// +-----------+                               +-----------+\n// |  [empty]  |                               |   item    |\n// |  [empty]  |                               |   item    |\n// |   item    | <-- bottom            top --> |  [empty]  |\n// |   item    |                               |  [empty]  |\n// |  [empty]  | <-- top            bottom --> |   item    |\n// |  [empty]  |                               |   item    |\n// +-----------+                               +-----------+\n//\n// Adding a value means moving `top` forward by one, removing means\n// moving `bottom` forward by one. After reaching the end, the queue\n// wraps around.\n//\n// When `top === bottom` the current queue is empty and when\n// `top + 1 === bottom` it's full. This wastes a single space of storage\n// but allows much quicker checks.\n\nclass FixedCircularBuffer {\n  constructor() {\n    this.bottom = 0;\n    this.top = 0;\n    this.list = new Array(kSize);\n    this.next = null;\n  }\n\n  isEmpty() {\n    return this.top === this.bottom;\n  }\n\n  isFull() {\n    return ((this.top + 1) & kMask) === this.bottom;\n  }\n\n  push(data) {\n    this.list[this.top] = data;\n    this.top = (this.top + 1) & kMask;\n  }\n\n  shift() {\n    const nextItem = this.list[this.bottom];\n    if (nextItem === undefined)\n      return null;\n    this.list[this.bottom] = undefined;\n    this.bottom = (this.bottom + 1) & kMask;\n    return nextItem;\n  }\n}\n\nmodule.exports = class FixedQueue {\n  constructor() {\n    this.head = this.tail = new FixedCircularBuffer();\n  }\n\n  isEmpty() {\n    return this.head.isEmpty();\n  }\n\n  push(data) {\n    if (this.head.isFull()) {\n      // Head is full: Creates a new queue, sets the old queue's `.next` to it,\n      // and sets it as the new main queue.\n      this.head = this.head.next = new FixedCircularBuffer();\n    }\n    this.head.push(data);\n  }\n\n  shift() {\n    const tail = this.tail;\n    const next = tail.shift();\n    if (tail.isEmpty() && tail.next !== null) {\n      // If there is another queue, it forms the new tail.\n      this.tail = tail.next;\n    }\n    return next;\n  }\n};\n","'use strict'\n\nconst Dispatcher = require('./dispatcher')\nconst {\n  ClientDestroyedError,\n  ClientClosedError,\n  InvalidArgumentError\n} = require('./core/errors')\nconst FixedQueue = require('./node/fixed-queue')\nconst { kSize, kRunning, kPending, kBusy, kUrl } = require('./core/symbols')\n\nconst kClients = Symbol('clients')\nconst kNeedDrain = Symbol('needDrain')\nconst kQueue = Symbol('queue')\nconst kDestroyed = Symbol('destroyed')\nconst kClosedPromise = Symbol('closed promise')\nconst kClosedResolve = Symbol('closed resolve')\nconst kOnDrain = Symbol('onDrain')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kQueued = Symbol('queued')\nconst kGetDispatcher = Symbol('get dispatcher')\nconst kAddClient = Symbol('add client')\nconst kRemoveClient = Symbol('remove client')\n\nclass PoolBase extends Dispatcher {\n  constructor () {\n    super()\n\n    this[kQueue] = new FixedQueue()\n    this[kClosedPromise] = null\n    this[kClosedResolve] = null\n    this[kDestroyed] = false\n    this[kClients] = []\n    this[kNeedDrain] = false\n    this[kQueued] = 0\n\n    const pool = this\n\n    this[kOnDrain] = function onDrain (origin, targets) {\n      const queue = pool[kQueue]\n\n      let needDrain = false\n\n      while (!needDrain) {\n        const item = queue.shift()\n        if (!item) {\n          break\n        }\n        pool[kQueued]--\n        needDrain = !this.dispatch(item.opts, item.handler)\n      }\n\n      this[kNeedDrain] = needDrain\n\n      if (!this[kNeedDrain] && pool[kNeedDrain]) {\n        pool[kNeedDrain] = false\n        pool.emit('drain', origin, [pool, ...targets])\n      }\n\n      if (pool[kClosedResolve] && queue.isEmpty()) {\n        Promise\n          .all(pool[kClients].map(c => c.close()))\n          .then(pool[kClosedResolve])\n      }\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      pool.emit('connect', origin, [pool, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      pool.emit('disconnect', origin, [pool, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      pool.emit('connectionError', origin, [pool, ...targets], err)\n    }\n  }\n\n  get [kBusy] () {\n    return this[kNeedDrain]\n  }\n\n  get [kPending] () {\n    let ret = this[kQueued]\n    for (const { [kPending]: pending } of this[kClients]) {\n      ret += pending\n    }\n    return ret\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const { [kRunning]: running } of this[kClients]) {\n      ret += running\n    }\n    return ret\n  }\n\n  get [kSize] () {\n    let ret = this[kQueued]\n    for (const { [kSize]: size } of this[kClients]) {\n      ret += size\n    }\n    return ret\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosedPromise] != null\n  }\n\n  close (cb) {\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (!this[kClosedPromise]) {\n        if (this[kQueue].isEmpty()) {\n          this[kClosedPromise] = Promise.all(this[kClients].map(c => c.close()))\n        } else {\n          this[kClosedPromise] = new Promise((resolve) => {\n            this[kClosedResolve] = resolve\n          })\n        }\n        this[kClosedPromise] = this[kClosedPromise].then(() => {\n          this[kDestroyed] = true\n        })\n      }\n\n      if (cb) {\n        this[kClosedPromise].then(() => cb(null, null))\n      } else {\n        return this[kClosedPromise]\n      }\n    } catch (err) {\n      if (cb) {\n        cb(err)\n      } else {\n        return Promise.reject(err)\n      }\n    }\n  }\n\n  destroy (err, cb) {\n    this[kDestroyed] = true\n\n    if (typeof err === 'function') {\n      cb = err\n      err = null\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    while (true) {\n      const item = this[kQueue].shift()\n      if (!item) {\n        break\n      }\n      item.handler.onError(err)\n    }\n\n    const promise = Promise.all(this[kClients].map(c => c.destroy(err)))\n    if (cb) {\n      promise.then(() => cb(null, null))\n    } else {\n      return promise\n    }\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosedPromise]) {\n        throw new ClientClosedError()\n      }\n\n      const dispatcher = this[kGetDispatcher]()\n\n      if (!dispatcher) {\n        this[kNeedDrain] = true\n        this[kQueue].push({ opts, handler })\n        this[kQueued]++\n      } else if (!dispatcher.dispatch(opts, handler)) {\n        dispatcher[kNeedDrain] = true\n        this[kNeedDrain] = !this[kGetDispatcher]()\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return !this[kNeedDrain]\n  }\n\n  [kAddClient] (client) {\n    client\n      .on('drain', this[kOnDrain])\n      .on('connect', this[kOnConnect])\n      .on('disconnect', this[kOnDisconnect])\n      .on('connectionError', this[kOnConnectionError])\n\n    this[kClients].push(client)\n\n    if (this[kNeedDrain]) {\n      process.nextTick(() => {\n        if (this[kNeedDrain]) {\n          this[kOnDrain](client[kUrl], [this, client])\n        }\n      })\n    }\n\n    return this\n  }\n\n  [kRemoveClient] (client) {\n    client.close(() => {\n      const idx = this[kClients].indexOf(client)\n      if (idx !== -1) {\n        this[kClients].splice(idx, 1)\n      }\n    })\n\n    this[kNeedDrain] = this[kClients].some(dispatcher => (\n      !dispatcher[kNeedDrain] &&\n      dispatcher.closed !== true &&\n      dispatcher.destroyed !== true\n    ))\n  }\n}\n\nmodule.exports = {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kRemoveClient,\n  kGetDispatcher\n}\n","'use strict'\n\nconst {\n  PoolBase,\n  kClients,\n  kNeedDrain,\n  kAddClient,\n  kGetDispatcher\n} = require('./pool-base')\nconst Client = require('./client')\nconst {\n  InvalidArgumentError\n} = require('./core/errors')\nconst util = require('./core/util')\nconst { kUrl } = require('./core/symbols')\nconst buildConnector = require('./core/connect')\n\nconst kOptions = Symbol('options')\nconst kConnections = Symbol('connections')\nconst kFactory = Symbol('factory')\n\nfunction defaultFactory (origin, opts) {\n  return new Client(origin, opts)\n}\n\nclass Pool extends PoolBase {\n  constructor (origin, {\n    connections,\n    factory = defaultFactory,\n    connect,\n    connectTimeout,\n    tls,\n    maxCachedSessions,\n    socketPath,\n    ...options\n  } = {}) {\n    super()\n\n    if (connections != null && (!Number.isFinite(connections) || connections < 0)) {\n      throw new InvalidArgumentError('invalid connections')\n    }\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout == null ? 10e3 : connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kConnections] = connections || null\n    this[kUrl] = util.parseOrigin(origin)\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kFactory] = factory\n  }\n\n  [kGetDispatcher] () {\n    let dispatcher = this[kClients].find(dispatcher => !dispatcher[kNeedDrain])\n\n    if (dispatcher) {\n      return dispatcher\n    }\n\n    if (!this[kConnections] || this[kClients].length < this[kConnections]) {\n      dispatcher = this[kFactory](this[kUrl], this[kOptions])\n      this[kAddClient](dispatcher)\n    }\n\n    return dispatcher\n  }\n}\n\nmodule.exports = Pool\n","'use strict'\n\nconst { kProxy } = require('./core/symbols')\nconst url = require('url')\nconst Agent = require('./agent')\nconst Dispatcher = require('./dispatcher')\nconst { InvalidArgumentError } = require('./core/errors')\n\nconst kAgent = Symbol('proxy agent')\n\nclass ProxyAgent extends Dispatcher {\n  constructor (opts) {\n    super(opts)\n    this[kProxy] = buildProxyOptions(opts)\n    this[kAgent] = new Agent(opts)\n  }\n\n  dispatch (opts, handler) {\n    const { host } = url.parse(opts.origin)\n    return this[kAgent].dispatch(\n      {\n        ...opts,\n        origin: this[kProxy].uri,\n        path: opts.origin + opts.path,\n        headers: {\n          ...opts.headers,\n          host\n        }\n      },\n      handler\n    )\n  }\n\n  async close () {\n    await this[kAgent].close()\n  }\n}\n\nfunction buildProxyOptions (opts) {\n  if (typeof opts === 'string') {\n    opts = { uri: opts }\n  }\n\n  if (!opts || !opts.uri) {\n    throw new InvalidArgumentError('Proxy opts.uri is mandatory')\n  }\n\n  return {\n    uri: opts.uri,\n    protocol: opts.protocol || 'https'\n  }\n}\n\nmodule.exports = ProxyAgent\n",null,"module.exports = require(\"assert\");","module.exports = require(\"async_hooks\");","module.exports = require(\"buffer\");","module.exports = require(\"diagnostics_channel\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"perf_hooks\");","module.exports = require(\"querystring\");","module.exports = require(\"stream\");","module.exports = require(\"stream/web\");","module.exports = require(\"tls\");","module.exports = require(\"tty\");","module.exports = require(\"url\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(3109);\n",""],"names":[],"sourceRoot":""}